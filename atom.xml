<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>临渊羡鱼</title>
  
  
  <link href="https://boneink.github.io/atom.xml" rel="self"/>
  
  <link href="https://boneink.github.io/"/>
  <updated>2022-08-23T04:00:00.000Z</updated>
  <id>https://boneink.github.io/</id>
  
  <author>
    <name>BoneInk</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WhiteRabbitTracke项目运行和问题</title>
    <link href="https://boneink.github.io/2022/08/23/WhiteRabbitTracker%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C%E5%92%8C%E9%97%AE%E9%A2%98/"/>
    <id>https://boneink.github.io/2022/08/23/WhiteRabbitTracker%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C%E5%92%8C%E9%97%AE%E9%A2%98/</id>
    <published>2022-08-23T04:00:00.000Z</published>
    <updated>2022-08-23T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WhiteRabbitTracke项目运行和问题"><a href="#WhiteRabbitTracke项目运行和问题" class="headerlink" title="WhiteRabbitTracke项目运行和问题"></a>WhiteRabbitTracke项目运行和问题</h2><hr><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><ul><li><p>虚拟机镜像选择：</p><p>编译阶段使用Windows 10 x86 1709及之后的镜像。</p><p>运行阶段使用Windows 7 x86 sp1。</p></li><li><p>拉取项目：</p><p>采用git指令直接拉取包含子项目在内的所有内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recursive https://github.com/AndreaNaspi/WhiteRabbitTracker.githttps://github.com/AndreaNaspi/WhiteRabbitTracker.git</span><br></pre></td></tr></table></figure><p>由于网络原因，可能无法拉取，因此可以手动下载解压：</p><p>主项目：<a href="https://github.com/AndreaNaspi/WhiteRabbitTracker">GitHub - AndreaNaspi&#x2F;WhiteRabbitTracker: WhiteRabbitTracker: Analyzing malware evasions with information flow tracking</a></p><p>子项目：<a href="https://github.com/zyantific/zydis/tree/564f0b843ca28b7b9b29dabfc2da1ae6abc9fee9">GitHub - zyantific&#x2F;zydis at 564f0b843ca28b7b9b29dabfc2da1ae6abc9fee9</a></p><p>zydis的子项目：<a href="https://github.com/zyantific/zycore-c/tree/0c372cdefe799e99812c008a0b74537bfa5fe077">GitHub - zyantific&#x2F;zycore-c at 0c372cdefe799e99812c008a0b74537bfa5fe077</a></p><p>之后将zydis放置于<code>WhiteRabbitTracker/deps/</code>下，将zycore放置于<code>WhiteRabbitTracker/deps/zydis/dependencies/</code>下即可。</p></li><li><p>配置相关环境：</p><p>虽然zydis号称几乎不需要任何额外的库，但是在编译时一些基础的工具时必要的。</p><p>安装以下工具：<code>Cmake</code>,<code>Visual Studio x86 2019</code>(2017也可以，对应的SDK和WDK最好要与之对应)，visual studio 2019对应的<code>SDK</code>和<code>WDK</code>（也可以不对应，但是SDK和WDK版本一定要一致，且一定要对应Windows 10 1709之后的版本，同时SDK安装时后会提示安装对应的Visual Studio扩展，一定要记得安装，否则VS无法检测到对应的WDK），额外安装<code>WDK 8.1</code>。</p><p>下载<code>Intel Pin v3.15</code>压缩文件，在C盘根目录创建<code>pin315</code>目录，将压缩文件内文件解压到改目录下，在环境配置中添加该目录。</p></li><li><p>编译项目：</p><p>首先要对<code>zydis</code>进行编译，用VS打开<code>zydis/msvc/</code>下的<code>Zydis.sln</code>，导入解决方案，检查所有项目的配置页的VS库版本号和WDK号是否正确或者满足，无误后，运行模式选择<code>Debug MT DLL</code>，(MT代表静态链接，会将所需的链接库都一次编译进来，否则后续可能会提示缺少必要组件，同时，最好选择用管理员权限打开VS，防止某些文件无法访问，DLL后缀代表生成DLL文件)，同时选择<code>Win32</code>，之后运行，默认会先编译Zydis和Zycore，生成必要的组件后，运行第一个示例。</p><p>完成后，会在<code>deps/zydis/msvc/bin/DebugX86</code>下找到<code>WhiteRabbitTracker</code>需要的<code>Zydis.dll</code>, <code>Zycore.dll</code>, <code>Zydis.lib</code> 和 <code>Zycore.li</code>，这代表编译没有问题。</p><p>同样的，用VS2019打开<code>WhiteRabbitTracker/solution.sln</code>,会提示升级库，WDK选择8.1。</p><p>如果编译提示找不到某些库，那就是WDK之类的地址没有对，修改根目录下的<code>Locals.props</code>，由于使用的是32位系统，因此不存在<code>Program Files (x86)</code>文件夹，仅有<code>Program Files</code>文件夹，所以需要修改<code>WinHPath</code>标签对应的地址。</p><p>编译成功后，在<code>pin</code>的目录下，可以找到<code>WhiteRabbitTracker.dll</code>文件。通过以下指令即可实现对软件的反逃逸。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Pin315\pin.exe -t WhiteRabbitTracker32.dll [options] -- &lt;file.exe&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="运行尝试："><a href="#运行尝试：" class="headerlink" title="运行尝试："></a>运行尝试：</h4><p>最好在Windows 7 sp1 x86下运行，将前一个虚拟机中<code>pin315</code>目录复制到新的虚拟机中即可使用。</p><p>同样的，使用指令对<code>pafish.exe</code>进行反逃逸，对比直接运行<code>patfish.exe</code>的结果，成功使之将虚拟机识别为真实环境。</p><p>    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;WhiteRabbitTracke项目运行和问题&quot;&gt;&lt;a href=&quot;#WhiteRabbitTracke项目运行和问题&quot; class=&quot;headerlink&quot; title=&quot;WhiteRabbitTracke项目运行和问题&quot;&gt;&lt;/a&gt;WhiteRabbitTra</summary>
      
    
    
    
    
    <category term="软件逃逸" scheme="https://boneink.github.io/tags/%E8%BD%AF%E4%BB%B6%E9%80%83%E9%80%B8/"/>
    
    <category term="IntelPin" scheme="https://boneink.github.io/tags/IntelPin/"/>
    
    <category term="恶意软件检测" scheme="https://boneink.github.io/tags/%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>挖矿样本特征总结</title>
    <link href="https://boneink.github.io/2022/06/27/%E6%8C%96%E7%9F%BF%E6%A0%B7%E6%9C%AC%E7%89%B9%E5%BE%81%E6%80%BB%E7%BB%93/"/>
    <id>https://boneink.github.io/2022/06/27/%E6%8C%96%E7%9F%BF%E6%A0%B7%E6%9C%AC%E7%89%B9%E5%BE%81%E6%80%BB%E7%BB%93/</id>
    <published>2022-06-27T04:00:00.000Z</published>
    <updated>2022-06-27T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、挖矿病毒的套路-https-zhuanlan-zhihu-com-p-164557943"><a href="#一、挖矿病毒的套路-https-zhuanlan-zhihu-com-p-164557943" class="headerlink" title="一、挖矿病毒的套路: https://zhuanlan.zhihu.com/p/164557943"></a>一、挖矿病毒的套路: <a href="https://zhuanlan.zhihu.com/p/164557943">https://zhuanlan.zhihu.com/p/164557943</a></h3><ol><li><p>DTStealer(又名“永恒之蓝下载器木马”)</p><ul><li><p>病毒运行后，除了执行挖矿行为，占用终端资源以外，还会窃取终端信息并回传服务器，并利用钓鱼邮件、SMBexec、WMIexec、常见漏洞等方式，在内、外网肆意传播。</p><p>该病毒内网传播方式较多，在部署火绒查杀后，还有被其他已经中毒终端攻击攻击的可能，出现火绒“文件实时监控”的查杀记录。</p></li><li><p>感染症状<br>如您的终端出现以下症状，极有可能感染了此病毒。<br>（1）出现以下名称的任务计划:<br>l Drivers<br>l WebServers<br>l DnsScan<br>l Bluetooths<br>l Credentials<br>l Rtsa·<br>l 00-00-00-00-00-00或??-??-??-??-??-??(MAC地址)<br>l Bluetea<br>l Blackball<br>（2）以下位置可能会生成的病毒文件:<br>l C:\Windows\temp\svchost.exe<br>l %AppData%\Microsoft\cred.ps1<br>l %AppData%\flashplayer.tmp<br>l %AppData%\Microsoft\Windows\StartMenu\Programs\Startup\FlashPlayer.lnk<br>（3）U盘内出现以下文件：<br>l blue3.bin<br>l blue6.bin<br>l (D-K)blue3.lnk<br>l (D-K)blue6.lnk<br>（4）火绒出现”隐藏执行PowerShell”、“利用PowerShell执行可疑脚本”等系统加固拦截<br><img src="https://pic2.zhimg.com/v2-8ac149f62555c15478d4565a9863bc75_b.jpg" alt="image"><br>（5)可能会出现的网址访问拦截:<br>l <a href="http://beahh.com/">http://beahh.com</a><br>l <a href="http://ackng.com/">http://ackng.com</a><br>l <a href="http://zer2.com/">http://zer2.com</a></p></li></ul></li><li><p>WannaMine</p><ul><li>该挖矿病毒于2017年底被发现，也是企业内较为常见的挖矿病毒、病毒运行后会扫描企业网络内是否启用了445端口的终端，并通过”永恒之蓝”漏洞在内网横向传播，感染更多终端进行挖矿。</li><li>感染症状<br>如果火绒“文件实时监控”拦截查杀以下目录内的“永恒之蓝”传播组件，则有可能感染了此病毒。<br>l C:\Windows\SpeechsTracing<br>l C:\Windows\NetworkDistribution<br>火绒”文件实时监控”查杀此挖矿程序：<br>l C:\Windows\SysWOW64\dllhostex.exe</li></ul></li><li><p>隐匿者(MyKings)</p><ul><li><p>隐匿者(MyKings)是由多个子僵尸网络构成的多重僵尸网络，除挖矿外，该僵尸网络还包含DDoS、Proxy、RAT等恶意功能。自2017年以来，该僵尸网络至今处于持续更新、传播的状态。</p><p>该病毒会感染MBR，在系统引导时进行加载，加载时机多早于正常的软件启动，成功加载后除了执行恶意行为外，还会对自身进行保护。</p></li><li><p>感染症状</p><p>终端被感染后，会出现以下特征：</p><p>（1）安全软件部署后，无法正常运行</p><p>l Sql Server日志内，出现大量”sa”账户登陆失败日志。</p><p>l Sql Server的作业内，出现异常定时作业。</p><p>（2）出现以下任务计划</p><p>l My</p><p>l Mysa</p><p>l ok</p><p>（3）出现以下文件：</p><p>l C:\Windows\debug\lsmo.exe</p><p>l C:\Windows\debug\lsmos.exe</p><p>l C:\Windows\debug\ok.dat</p><p>l C:\Windows\System32\ok.exe</p><p>l C:\Windows\temp\conhost.exe</p><p>l C:\Windows\System\msinfo.exe</p></li></ul></li><li><p>匿影挖矿</p><ul><li><p>匿影挖矿于2019年2月被发现，该病毒会利用大量网络上的公共资源(例如免费图床)存放病毒模块。在企业内，会利用”永恒之蓝”在内网横向传播，感染更多终端进行挖矿。病毒运行后，会利用驱动阻碍安全软件正常运行，并对自身进行保护。</p><p>该挖矿会利用驱动妨碍安全软件正常运行。</p></li><li><p>终端被感染后，出现以下文件：</p><p>l C:\Windows\Temp\retboolDriver.sys</p><p>l C:\Windows\Temp\FlrefoxDriver.sys</p><p>l C:\ProgramData\dll*</p><p>l C:\ProgramData\kuaizipUpdateChecker.dll</p><p>l C:\ProgramData\MS_17_010_Scan.exe</p><p>l C:\ProgramData\Microsoft\Chromme.exe</p><p>l C:\ProgramData\Flrefox.exe</p></li></ul></li><li><p>紫狐</p><ul><li><p>紫狐病毒最初发现于2018年，多年来一直保持活跃，除了挖矿外，该病毒还有流量暗刷、DDoS、盗号、恶意推广等恶意行为。并会通过软件捆绑、Ghost镜像、永恒之蓝、Sql暴破、服务漏洞等方式进行传播。</p><p>该病毒会通过驱动对自身进行保护。</p></li><li><p>感染症状</p><p>被感染终端，会出现以下文件：</p><p>l C:\Windows\System32\Ms********App.dll(*为任意字符)</p></li></ul></li></ol><h3 id="二、Avast-Q4-x2F-21-Threat-report：https-decoded-avast-io-threatresearch-avast-q4-21-threat-report"><a href="#二、Avast-Q4-x2F-21-Threat-report：https-decoded-avast-io-threatresearch-avast-q4-21-threat-report" class="headerlink" title="二、Avast Q4&#x2F;21 Threat report：https://decoded.avast.io/threatresearch/avast-q4-21-threat-report/"></a>二、Avast Q4&#x2F;21 Threat report：<a href="https://decoded.avast.io/threatresearch/avast-q4-21-threat-report/">https://decoded.avast.io/threatresearch/avast-q4-21-threat-report/</a></h3><p>CoinHelper是流行的硬币矿工之一，在 21 年第四季度仍然非常活跃，主要<code>Russia</code>针对<code>Ukraine</code>. 当恶意软件在受害者的系统上执行时，<code>CoinHelper</code>通过网络下载臭名昭著的 XMRig 矿工<code>Tor</code>并开始挖矿。除了硬币挖掘，CoinHelper 还收集有关受害者的各种信息，以识别他们的地理位置、他们安装的 AV 解决方案以及他们正在使用的硬件。</p><p>该恶意软件以捆绑的形式与许多流行的应用程序、破解软件（例如<code>MS Office</code>，游戏和游戏作弊程序（例如<code>Minecraft</code>and <code>Cyberpunk 2077</code>），甚至是干净的安装程序（例如<code>Google Chrome</code>or <code>AV products</code>）以及隐藏在 中<code>Windows 11 ISO image</code>，等等）一起传播。通过种子下载捆绑的应用程序也支持传播范围，进一步滥用了下载软件的非官方方式。</p><p>尽管我们观察到多种加密货币（包括以太坊或比特币）被配置为开采，但有一种特殊类型脱颖而出—— <code>Monero</code>. 尽管门罗币被设计为匿名的，但由于地址使用错误和矿池运作机制，我们能够更深入地了解恶意软件作者的门罗币挖矿操作，并发现总的货币收益CoinHelper<code>339,694.86 USD</code>截至 2021 年 11 月 29 日。</p><h3 id="三、关于CoinHelper（https-decoded-avast-io-janrubin-toss-a-coin-to-your-helper-）"><a href="#三、关于CoinHelper（https-decoded-avast-io-janrubin-toss-a-coin-to-your-helper-）" class="headerlink" title="三、关于CoinHelper（https://decoded.avast.io/janrubin/toss-a-coin-to-your-helper/）:"></a>三、关于CoinHelper（<a href="https://decoded.avast.io/janrubin/toss-a-coin-to-your-helper/%EF%BC%89">https://decoded.avast.io/janrubin/toss-a-coin-to-your-helper/）</a>:</h3><p>CoinHelper 大多与 WinRAR 和游戏秘籍等破解软件安装程序捆绑在一起。</p><p>其传播方式之一为通过MyKing的僵尸网络的剪切板窃取进行传播（<a href="https://decoded.avast.io/janrubin/the-king-is-dead-long-live-mykings/%EF%BC%89%E3%80%82">https://decoded.avast.io/janrubin/the-king-is-dead-long-live-mykings/）。</a></p><p>通过剪切板窃取，误导用户在下载软件时，使用被绑定了CoinHelper的软件，从而无意中执行该程序。</p><p>感染流程：</p><p><img src="https://decoded.avast.io/wp-content/uploads/sites/2/2021/11/image-29.png" alt="image"></p><ol><li><p>修复损坏的存档、执行第二阶段和确保持久性：</p><p>下载获得一个名称和图标均正常的exe文件（为一个已经编译的Autolt二进制文件）。</p><p>提取后，可以获得三个组件：</p><ul><li><code>asacpiex.dll</code>（一个损坏（修改）的 7zip 存档，带有恶意软件的第二阶段）</li><li><code>CL_Debug_Log.txt</code>（干净的 7zip 独立可执行文件）</li><li><code>glue\ChromeSetup.exe</code></li></ul><p>第一阶段还包含一个非常简单但有效的附加功能：攻击者收集有关受害者的信息，重点关注受害者的操作系统、安装的 RAM 数量、CPU 和显卡信息，以及系统上存在的安全解决方案。所有收集到的信息都被格式化并连接成一个字符串。</p><p>然后，该字符串通过 GET 请求以用户代理的形式发送到硬编码的 URL 地址。在我们的示例中，硬编码的 URL 看起来像<code>https://2no[.]co/1wbYc7</code>.</p></li><li><p>修复asacpiex.dll后，将其保存为CR_Debug_Log.txt到Temp文件夹中。</p><p>为了解压档案，恶意软件使用密码JDQJndnqwdnqw2139dn21n3b312idDQDB。这是这些 AutoIt dropper 最常用的密码。但是，它不是唯一的，到目前为止，我们还计算了两个额外的密码：</p><p>dkwqdqw9324328NDQDN@@!)(#($%&amp;^!ND21<br>jDWQJkdqkwdqo2m@mdwmsxPAS,sq%<br>解包显示两个附加文件：</p><p>32.exe<br>64.exe</p><p>根据操作系统的体系结构以及 AES 指令集是否可用，这些文件之一将被复制到<br><code>C:\Users\&lt;username&gt;\AppData\Roaming\Microsoft\Windows\Helper.exe</code><br>并执行（通过计划任务）。</p><p>这两个文件都再次编译了 AutoIt 脚本，具有通过 Tor 网络以硬币矿工的形式向受害者分发更多有效负载的功能。</p><p>尽管<code>Helper.exe</code>它是迄今为止最常见的恶意软件名称，但它并不是唯一的可能性。我们在野外看到的其他选项例如：</p><ul><li><code>fuck.exe</code></li><li><code>Helperr.exe</code></li><li><code>svchost.exe</code></li><li><code>System.exe</code></li><li><code>system32.exe</code></li><li><code>WAPDWA;DJ.exe</code></li><li><code>WorkerB.exe</code></li></ul><p>关于hepler.exe：主要目标是通过 Tor 网络将 XMRig 硬币矿工投放到受害者的系统上。</p><p><code>Helper.exe</code>还拥有许多其他功能，例如在受害者的 PC 上执行多个系统检查、将自身注入<code>%WINDIR%\System32\attrib.exe</code>系统二进制文件、检查系统的“空闲”以加强挖掘等等。</p><p>通过tor网络将coinminer下载到受感染系统的准备：</p><p>首先，该恶意软件包含两个额外的十六进制文件。第一个再次是一个干净的 7zip 二进制文件（但不同于<code>CL_Debug_Log.txt</code>），第二个是一个 7zip 存档，其中包含一个干净的 Tor 二进制文件和所属库：</p><ul><li><p><code>libcrypto-1_1-x64.dll</code></p></li><li><p><code>libevent-2-1-7.dll</code></p></li><li><p><code>libevent_core-2-1-7.dll</code></p></li><li><p><code>libevent_extra-2-1-7.dll</code></p><ul><li><code>libgcc_s_seh-1.dll</code></li></ul></li><li><p><code>libssl-1_1-x64.dll</code></p></li><li><p><code>libssp-0.dll</code></p><ul><li><code>libwinpthread-1.dll</code></li></ul></li><li><p><code>tor.exe</code></p></li><li><p><code>zlib1.dll</code></p></li></ul><p>tor解压密码：DxSqsNKKOxqPrM4Y3xeK<br>Tor 执行后，它会监听<code>9303</code>localhost ( <code>127.0.0.1</code>) 上的端口并等待请求。为防止此时出现混淆，请注意默认情况下此执行是隐藏的，因为<code>tor.exe</code>不应将其误认为是 Tor 浏览器。<code>tor.exe</code>是一个提供 Tor 路由的进程（没有 GUI）。在常见的 Tor 浏览器安装中，通常可以在<code>\&lt;Tor browser root folder&gt;\Browser\TorBrowser\Tor\tor.exe</code>.<br>该脚本还包含 C&amp;C 服务器的一些 Base64 编码的 Tor 地址，并尝试哪个是活着的。这是通过通过精心制作的请求（以十六进制形式）初始化 SOCKS4 通信来完成的：所需的服务器地址<br> <code>04 01 00 50 00 00 00 FF 00 $host 00</code><br> 该恶意脚本仅仅在收到一个包含了0x5A字节的标准协议响应后才会进一步与服务器进行通信。</p><p>恶意软件能从服务器上下载四个文件：</p><ul><li><code>public/upd.txt</code></li><li><code>public/64/64.txt</code>（或者<code>public/32/32.txt</code>如果使用脚本的“32 位变体”）</li><li><code>public/vc/amd.txt</code></li><li><code>public/vc/nvidia.txt</code></li></ul><p>文件<code>64.txt</code>( <code>32.txt</code>)、<code>amd.txt</code>和<code>nvidia.txt</code>都是 <strong>XMRig coinminers（编码和压缩），用于 CPU 或相应的 GPU 卡</strong>。</p><p>该<code>upd.txt</code>文件是一个纯文本文件，其中包含由<code>_</code>和<code>!</code>符号界定的版本号，例如<code>_!1!_</code>. 恶意软件会询问服务器当前版本多少，如果版本较新，则所有 coinminers都会更新。</p><p>矿工从 C&amp;C 下载为十六进制字符串，以常量字符串结尾<code>_!END!_</code>。移除结束存根并解码字符串后，我们得到一个 7zip 存档。我们可以使用<code>DxSqsNKKOxqPrM4Y3xeK</code>密码来解压它。</p><p>解压后，我们可以得到这些文件：</p><ul><li><code>SysBackup.txt</code>– 适用于 CPU 矿工（32 位和 64 位）</li><li><code>SysBackupA.txt</code>– 当还检测到 AMD GPU 时</li><li><code>SysBackupN.txt</code>– 当还检测到 NVIDIA GPU 时</li></ul><p>这些文件再次以十六进制形式出现，这次以<code>0x</code>前缀开头，没有结束存根。</p><hr><p><strong>挖矿</strong></p><p>挖矿（和 7zip 解包）是通过进程注入执行的。CPU 挖矿是通过注入新创建和挂起的 <code>%WINDIR%\System32\attrib.exe</code>.</p><p>所有其他组件的执行，例如 GPU 挖掘或从 Tor 下载的 coinminer 有效载荷的解包，都是通过注入自身来完成的，这意味着使用一个新的暂停实例<code>Helper.exe</code>进行注入。当支持 GPU 挖矿时，CPU 和 GPU 并行执行。</p><p>根据我们的研究，我们只看到 XMRig 被部署为最终的挖矿有效载荷。该恶意软件使用通用参数执行它，其中一种方法值得一提——为挖矿服务器“设置密码”的参数<code>-p</code>。在标准情况下，密码并不重要，因此恶意软件作者通常使用“ <code>x</code>”作为密码。然而，在这种情况下，恶意软件会生成受害者的 GUID 并将其附加到通常的“ <code>x</code>”中。</p><p><strong>持久性</strong></p><p>与第一阶段类似，在第二阶段开始时，会检查并在必要时创建特定的互斥锁：</p><ul><li><code>QPRZ1bWvXh</code></li><li><code>QPRZ1bWvXh2</code></li></ul><p>正如我们所看到的，与第一阶段（）相比，只有互斥锁中间的数字发生了变化<code>QPRZ3bWvXh</code>。第二个互斥体附加了一个常量<code>2</code>。我们也看到<code>QPRZ2bWvXh</code>了使用，再次更改中间数字。</p><p>为了尽可能长时间地隐藏，恶意软件使用原生 AutoIt <code>ProcessExists</code>功能检查多个进程，以检查任何正在运行的系统监控和分析工具：</p><ul><li><code>aida64.exe</code></li><li><code>AnVir.exe</code></li><li><code>anvir64.exe</code></li><li><code>GPU-Z.exe</code></li><li><code>HWiNFO32.exe</code></li><li><code>HWiNFO64.exe</code></li><li><code>i7RealTempGT.exe</code></li><li><code>OpenHardwareMonitor.exe</code></li><li><code>pchunter64.exe</code></li><li><code>perfmon.exe</code></li><li><code>ProcessHacker.exe</code></li><li><code>ProcessLasso.exe</code></li><li><code>procexp.exe</code></li><li><code>procexp64.exe</code></li><li><code>RealTemp.exe</code></li><li><code>RealTempGT.exe</code></li><li><code>speedfan.exe</code></li><li><code>SystemExplorer.exe</code></li><li><code>taskmgr.exe</code></li><li><code>VirusTotalUpload2.exe</code></li></ul><p>当发现该工具时，恶意软件会暂时禁用挖掘。有关运行硬币矿工的信息存储在两个文件中：</p><ul><li><code>mn.pid</code></li><li><code>gmn.pid</code></li></ul><p>该恶意软件还监控受害者目前是否实际使用他们的 PC。如果用户空闲了一段时间，在我们的特殊情况下为 3 分钟，当前的挖矿将终止，并执行一个新的挖矿过程并设置为在所有线程上利用 100% 的 CPU。此信息 (PID) 存储在名为<code>mn.ld</code>. 主动使用 PC 时，挖矿设置为可用性能的 50%。另一方面，GPU 挖掘<strong>仅</strong>在用户没有主动使用他们的 PC 时（2 分钟）执行。</p><p>该恶意软件还列出了系统上存在的所有控制台窗口，并找出那些可见性设置为隐藏的控制台窗口。如果找到这样的窗口并且它不属于 CoinHelper，则恶意软件会</p><p>程。</p><p><strong>数据收集和反病毒检查</strong></p><p>与之前的 AutoIt 阶段类似，它<code>Helper.exe</code>也会收集有关受感染系统的信息。</p><p>如果检测到任何在列表中的卡并且视频适配器名称与“ <code>Advanced Micro Devices, Inc.</code>”或“ <code>NVIDIA</code>”匹配，则恶意软件使用 XMRig 来利用 GPU 进行挖矿。</p></li><li><p>除了我们开始调查的 Yandex 磁盘存储之外，我们可以确认，传播 CoinHelper 的另一种重要方法是通过放置在专注于破解软件的互联网论坛上的恶意种子。</p></li></ol><h3 id="四、DirtyMoe-Introduction-and-General-Overview-of-Modularized-Malware：https-decoded-avast-io-martinchlumecky-dirtymoe-1"><a href="#四、DirtyMoe-Introduction-and-General-Overview-of-Modularized-Malware：https-decoded-avast-io-martinchlumecky-dirtymoe-1" class="headerlink" title="四、DirtyMoe: Introduction and General Overview of Modularized Malware：https://decoded.avast.io/martinchlumecky/dirtymoe-1/"></a>四、DirtyMoe: Introduction and General Overview of Modularized Malware：<a href="https://decoded.avast.io/martinchlumecky/dirtymoe-1/">https://decoded.avast.io/martinchlumecky/dirtymoe-1/</a></h3><ol><li><p>DirtyMoe整体介绍：</p><p>DirtyMoe 恶意软件使用了一个简单的想法，即如何同时<strong>模块化、不可检测和不可跟踪</strong>。该恶意软件的目标主要集中在 Cryptojacking 和 DDoS 攻击。DirtyMoe 通过 EternalBlue 和至少三个其他漏洞在系统级权限下作为 Windows 服务运行。特定功能由恶意软件作者远程控制，他们可以在几个小时内将数千个 DirtyMoe 实例重新配置为所需的功能。DirtyMoe 只是下载一个加密的有效载荷，对应于所需的功能，并将有效载荷注入自身。</p></li><li><p>感染方式：</p><p>攻击者通过端口扫描和漏洞开放数据库，发现并瞄准大量弱计算机。PurpleFox 是 DirtyMoe 常用的漏洞利用工具包。之后通过如EnternalBlue漏洞或 SMB 密码暴力破解 Windows 等获取管理员权限。</p><p>用 DirtyMoe 感染受害者机器的另一种方法是钓鱼电子邮件，其中包含可以通过 Internet Explorer 攻击目标的 URL。</p><p>此外，通过受感染的正常文件来部署也是方式之一。</p><p>当其中一个漏洞利用成功并获得系统权限时，DirtyMoe 可以安装在受害者的机器上。我们观察到 DirtyMoe 利用 Windows MSI Installer 来部署恶意软件。MSI Installer 提供了一种在多个平台和 Windows 版本上安装适当软件的简单方法。每个版本都需要安装文件和注册表项的不同位置。恶意软件作者可以轻松地为目标系统和平台设置 DirtyMoe 配置。</p><p>MSI Installer 通过 MSI 安装程序将受害者环境准备到适当的状态。他们专注于禁用反间谍软件和文件保护功能。此外，MSI 软件包使用一项系统功能，该功能有助于覆盖系统文件以进行恶意软件部署。</p><p>MSI Installer 通过修改注册表，修改系统文件从而避免自身被检测。</p><p>DirtyMoe 服务在 maware 部署期间在系统中注册。在开始时，该服务提取并加载 DirtyMoe 驱动程序以保护自己。加载驱动程序时，该服务会从文件系统和注册表中清除有关该驱动程序的所有证据。</p><p>DirtyMoe 恶意软件由两个进程组成，即<em>DirtyMoe Core</em>和<em>DirtyMoe Executioner</em>，由 DirtyMoe 服务创建，如果进程被创建和配置，则会自行终止。DirtyMoe 服务通过多个随时间终止的进程和线程创建<em>核心</em>和<em>执行器进程。</em>因此，取证和跟踪方法更加困难。</p></li><li><p>安装：</p><p><em>DirtyMoe Core</em>负责将恶意代码注入执行它的<em>DirtyMoe Executioner</em>。注入的代码，称为 MOE 对象或模块，是从 C&amp;C 服务器下载的。MOE 对象是<em>DirtyMoe Core</em>解密并注入<em>DirtyMoe Executioner</em>的加密 PE 文件。</p><p>此外，确定<em>DirtyMoe Core</em>介绍行为的初始有效负载由 MSI 安装程序部署为<code>sysupdate.log</code>文件。因此，<em>DirtyMoe Core</em>可以通过有效负载注入来更新或更改自己的功能。</p></li><li><p>控制和行动：</p><p><em>DirtyMoe Core</em>和<em>DirtyMoe Executioner</em>为恶意软件作者提供了一个接口，他们可以远程模块化 DirtyMoe 并通过 MOE 对象更改用途和配置。<em>DirtyMoe Core</em>与命令和控制 (C&amp;C) 服务器通信以获取攻击者命令。因此，整个复杂的层次结构高度模块化，配置和控制非常灵活。</p><p>C&amp;C 通信的阴险之处在于 DirtyMoe 没有使用固定的 IP 地址，而是实施了一种独特的机制来混淆最终的 C&amp;C 服务器地址。因此，不可能阻止受害者机器上的 C&amp;C 服务器，因为每次 C&amp;C 通信的服务器地址都不同。此外，该机制基于无法轻易阻止的 DNS 请求，因为它会影响日常通信。</p><blockquote><p>关于 DirtyMoe 模块化，如果恶意软件作者不需要进行有针对性的攻击，加密挖掘似乎是一种持续使用受害者机器的活动。因此，加密采矿是和平时期的一项活动。然而，绿盟科技威胁情报中心发现了分布式拒绝服务（DDoS）攻击[<a href="https://decoded.avast.io/martinchlumecky/dirtymoe-1/#ref">1]</a>。一般来说，DirtyMoe 可以将任意恶意软件部署到受感染的系统中，例如信息窃取器、勒索软件、木马等。</p></blockquote></li><li><p>自我保护机制：</p><p> DirtyMoe 驱动程序提供了广泛的功能；请参阅以下候选名单：</p><ul><li>Minifilter：对目录枚举的影响（隐藏、插入、修改）</li><li>注册表隐藏：可以隐藏已定义的注册表项</li><li>服务隐藏：修补<code>service.exe</code>结构以隐藏所需的服务</li><li>驱动隐藏：可以在系统中隐藏自己</li></ul><p>DirtyMoe 代码包含许多可以被大多数 AV 捕获的恶意模式。恶意软件作者使用 <strong>VMprotect 来混淆 DirtyMoe 服务 DLL 文件</strong>。下载的 DirtyMoe 对象使用硬编码密钥使用对称密码进行加密。我们已经看到了几个 MOE 对象，<strong>它们本质上包含相同的 PE 文件，只是 PE 标头不同</strong>。尽管如此，即使是这些轻微的修改也足以让使用的密码产生完全不同的 MOE 对象。因此，<strong>静态检测不能应用于 MOE 加密对象</strong>。此外，DirtyMoe 不会将解密后的 MOE 对象（PE 文件）转储到文件系统中，而是<strong>直接将 MOE 对象注入内存</strong>。</p><p> DirtyMoe 工作人员是通过多个进程和线程启动的。工作人员最初运行为<code>svchost.exe</code>，但 DirtyMoe 驱动程序将工作人员的进程名称更改为<code>fontdrvhost.exe</code>。DirtyMoe 有两个相互保护的工作进程（<em>Core</em>和<em>Executioner</em>）。因此，如果第一个工作人员被杀死，第二个工作人员将启动第一个工作人员的新实例，反之亦然。</p><p><strong>反检测</strong>补充：DirtyMoe: Deployment：<a href="https://decoded.avast.io/martinchlumecky/dirtymoe-4/">https://decoded.avast.io/martinchlumecky/dirtymoe-4/</a></p><p><strong>DisableAntiSpyware</strong><br><code>HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Windows Defender\DisableAntiSpyware = 1</code><br>Microsoft Defender Antivirus 可以通过将<code>DisableAntiSpyware</code>注册表项设置为 1 来禁用。因此，如果系统没有第三方防病毒产品，则系统没有针对恶意软件的保护，包括间谍软件。</p><p><strong>SFCDisable</strong><br><code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\SFCDisable = 4</code><br>Windows 文件保护 (WFP) 可防止非系统应用程序替换可能导致操作系统完整性和稳定性问题的关键 Windows 系统文件。WFP 通常在所有版本的 Windows中默认启用。</p><p>自然地，DirtyMoe 希望避免 WFP 检测到对系统文件进行任何操作的情况。因此，该<code>SFCDisable</code>值设置为4，启用 WFP，但 GUI 不会弹出每个 WFP 操作。效果是 WFP 已启用，因此不会调用系统警报，但会为用户隐藏 WFP 警告。<strong>这仅适用于 Windows XP。</strong></p><p><strong>SFCScan</strong><br><code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\SFCScan = 0</code><br>系统文件检查器 (SFC) 提供扫描受系统保护的文件的能力。SFC 验证文件版本，如果它检测到任何文件操作，SFC 将文件更新为正确的版本。这种注册表操作有助于禁用 SFC 保护滥用的 Windows 服务。此设置仅影响文件扫描，但 WFP 仍可处于活动状态。</p><p><strong>SvcHostSplitThresholdInKB</strong><br><code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SvcHostSplitThresholdInKB = 0xFFFFFFFF</code><br>关键的注册表操作控制系统启动和设备配置的某些方面。</p><p>在大多数情况下，Windows 服务从 Windows 通过通用主机进程 (svchost.exe) 执行的动态链接库运行。托管进程可以在一个进程中加载更多服务 (DLL) 作为线程。这是 Windows XP 时代的历史遗留物，当时系统内存曾经是一种稀缺商品。该系统使用了一些托管所有 Windows 服务的服务主机进程，由 DLL 文件表示，因为进程的创建和维护在系统内存方面是昂贵的。</p><p>如今，没有理由将服务分组在几个进程中，由此产生的积极影响是提高了系统的稳定性和安全性，以及更容易进行错误分析。服务现在通常不再共享进程；提供系统功能的小程序有一个独占的内存位置。并且如果 svchost.exe 进程崩溃，它不再拖着整个服务链。</p><p>Windows 10 带有一个阈值 ( <code>SvcHostSplitThresholdInKB</code>)，用于确定何时应将服务创建为常规进程。默认值为 380,000，因此如果系统内存小于 3.5 GB，则使用分组服务模型。也就是说，增大阈值可以减少宿主进程的数量，从而判断服务进程是否被拆分。</p><p>我们以 Windows 10 为例，如果该值设置为 1，则主机进程数约为。70. 等于最大值 ( <code>0xFFFFFFFF</code>) 的阈值导致主机进程数仅为 26。</p><p>最大值<code>SvcHostSplitThresholdInKB</code>可以隐藏有关运行进程的详细信息。因此，恶意软件作者将阈值设置为最大值以隐藏线程中的恶意服务活动。结果，恶意服务在其线程之一中的一个主机进程中运行。因此，跟踪和取证分析变得更加困难，因为 svchost 进程托管了许多其他服务，并且很难将系统活动分配给恶意软件服务。</p></li></ol><h3 id="五、Crackonosh-A-New-Malware-Distributed-in-Cracked-Software：https-decoded-avast-io-danielbenes-crackonosh-a-new-malware-distributed-in-cracked-software"><a href="#五、Crackonosh-A-New-Malware-Distributed-in-Cracked-Software：https-decoded-avast-io-danielbenes-crackonosh-a-new-malware-distributed-in-cracked-software" class="headerlink" title="五、Crackonosh: A New Malware Distributed in Cracked Software：https://decoded.avast.io/danielbenes/crackonosh-a-new-malware-distributed-in-cracked-software/"></a>五、Crackonosh: A New Malware Distributed in Cracked Software：<a href="https://decoded.avast.io/danielbenes/crackonosh-a-new-malware-distributed-in-cracked-software/">https://decoded.avast.io/danielbenes/crackonosh-a-new-malware-distributed-in-cracked-software/</a></h3><p>下图描述了整个 Crackonosh 安装过程。</p><p><a href="https://decoded.avast.io/wp-content/uploads/sites/2/2021/06/Installation-process.png"><img src="https://decoded.avast.io/wp-content/uploads/sites/2/2021/06/Installation-process.png" alt="img"></a>安装示意图</p><ol><li>首先，受害者运行破解软件的安装程序。</li><li>安装程序运行<code>maintenance.vbs</code></li><li><code>Maintenance.vbs</code>然后使用开始安装<code>serviceinstaller.msi</code></li><li><code>Serviceinstaller.msi</code>注册并运行<code>serviceinstaller.exe</code>，主要的恶意软件可执行文件。</li><li><code>Serviceintaller.exe</code> 运行<code>StartupCheckLibrary.DLL</code>。</li><li><code>StartupCheckLibrary.DLL</code>下载并运行<code>wksprtcli.dll</code>。</li><li><code>Wksprtcli.dll</code> 提取更新并<code>winlogui.exe</code> 删除它包含的内容，解密并放置在文件夹中。</li></ol><p>规避和禁用安全软件所采取的具体措施包括：</p><ul><li>在安全模式下删除防病毒软件</li><li>停止 Windows 更新(它会删除以下注册表项以停止 Windows Defender 并关闭自动更新。)</li><li>用绿色勾选系统托盘图标替换 Windows 安全</li><li>使用的库不使用将<code>DllMain</code>库作为主可执行文件 (by <code>rundll32.exe</code>) 运行时使用的常用库，而是从其他一些导出函数开始。</li><li>Serviceinstaller 测试它是否在安全模式下运行</li></ul><p>为了防止分析，它会采取以下操作来测试以确定它是否在 VM 中运行：</p><ul><li>检查注册表项：<ul><li><code>SOFTWARE\VMware, Inc</code></li><li><code>SOFTWARE\Microsoft\Virtual Machine\Guest\Parameters</code></li><li><code>SOFTWARE\Oracle\VirtualBox Guest Additions</code></li></ul></li><li>测试计算机时间是否在某个合理的时间间隔内，例如在恶意软件创建之后和 2023 年之前 ( <code>wksprtcli.dll</code>)</li></ul><p>此外，如前所述，它会延迟运行以更好地隐藏自己。我们发现特定安装程序使用硬编码的日期和时间来延迟，如下所示。</p><table><thead><tr><th><strong>SHA of installer</strong></th><th><strong>Installer doesn’t run before</strong></th></tr></thead><tbody><tr><td>9EC3DE9BB9462821B5D034D43A9A5DE0715FF741E0C171ADFD7697134B936FA3</td><td>2018-06-10 13:08:20</td></tr><tr><td>8C52E5CC07710BF7F8B51B075D9F25CD2ECE58FD11D2944C6AB9BF62B7FBFA05</td><td>2018-06-19 14:06:37</td></tr><tr><td>93A3B50069C463B1158A9BB3A8E3EDF9767E8F412C1140903B9FE674D81E32F0</td><td>2018-07-04 17:33:20</td></tr><tr><td>6A3C8A3CA0376E295A2A9005DFBA0EB55D37D5B7BF8FCF108F4FFF7778F47584</td><td>2018-07-10 15:35:57</td></tr><tr><td>4B01A9C1C7F0AF74AA1DA11F8BB3FC8ECC3719C2C6F4AD820B31108923AC7B71</td><td>2018-07-25 13:56:35</td></tr><tr><td>65F39206FE7B706DED5D7A2DB74E900D4FAE539421C3167233139B5B5E125B8A</td><td>2018-08-03 15:50:40</td></tr><tr><td>C6817D6AFECDB89485887C0EE2B7AC84E4180323284E53994EF70B89C77768E1</td><td>2018-08-14 12:36:30</td></tr><tr><td>7F836B445D979870172FA108A47BA953B0C02D2076CAC22A5953EB05A683EDD4</td><td>2018-09-13 12:29:50</td></tr><tr><td>D8C092DE1BF9B355E9799105B146BAAB8C77C4449EAD2BDC4A5875769BB3FB8A</td><td>2018-10-01 13:52:22</td></tr><tr><td>E497EE189E16CAEF7C881C1C311D994AE75695C5087D09051BE59B0F0051A6CF</td><td>2018-10-19 14:15:35</td></tr><tr><td>D7A9BF98ACA2913699B234219FF8FDAA0F635E5DD3754B23D03D5C3441D94BFB</td><td>2018-11-07 12:47:30</td></tr></tbody></table><p>它还采取了特定的行动来隐藏自己，以免使用可能会泄露其存在的工具的可能的高级用户。</p><p>它使用类似 Windows 的名称和描述，例如 <code>winlogui.exe</code>Windows 登录 GUI 应用程序。</p><p>它还检查正在运行的进程并将其与下面的阻止列表进行比较。如果它找到具有指定名称的进程<code>winrmsrv.exe</code>并<code>winlogui.exe</code>终止自身并等待PC的下一次启动。</p><ul><li><ul><li>Blocklist:<ul><li>dumpcap.exe</li><li>fiddler.exe </li><li>frst.exe </li><li>frst64.exe </li><li>fse2.exe </li><li>mbar.exe </li><li>messageanalyzer.exe </li><li>netmon.exe </li><li>networkminer.exe </li><li>ollydbg.exe </li><li>procdump.exe </li><li>procdump64.exe </li><li>procexp.exe </li><li>procexp64.exe </li><li>procmon.exe </li><li>procmon64.exe </li><li>rawshark.exe </li><li>rootkitremover.exe </li><li>sdscan.exe </li><li>sdwelcome.exe </li><li>splunk.exe </li><li>splunkd.exe </li><li>spyhunter4.exe </li><li>taskmgr.exe</li><li>tshark.exe </li><li>windbg.exe </li><li>wireshark-gtk.exe </li><li>wireshark.exe </li><li>x32dbg.exe </li><li>x64dbg.exe </li><li>X96dbg.exe</li></ul></li></ul></li></ul><h3 id="六、HackBoss-A-cryptocurrency-stealing-malware-distributed-through-Telegram：https-decoded-avast-io-romanalinkeova-hackboss-a-cryptocurrency-stealing-malware-distributed-through-telegram"><a href="#六、HackBoss-A-cryptocurrency-stealing-malware-distributed-through-Telegram：https-decoded-avast-io-romanalinkeova-hackboss-a-cryptocurrency-stealing-malware-distributed-through-telegram" class="headerlink" title="六、HackBoss: A cryptocurrency-stealing malware distributed through Telegram：https://decoded.avast.io/romanalinkeova/hackboss-a-cryptocurrency-stealing-malware-distributed-through-telegram/"></a>六、HackBoss: A cryptocurrency-stealing malware distributed through Telegram：<a href="https://decoded.avast.io/romanalinkeova/hackboss-a-cryptocurrency-stealing-malware-distributed-through-telegram/">https://decoded.avast.io/romanalinkeova/hackboss-a-cryptocurrency-stealing-malware-distributed-through-telegram/</a></h3><p>在窃取加密货币的恶意软件属于三个主要类别之一： </p><ul><li><code>Password stealers</code>：专注于窃取加密货币钱包或带有密码的文件的恶意软件。</li><li><code>Coinminers</code>：使用受害者机器的计算能力来挖掘加密货币的恶意软件。</li><li><code>Keyloggers</code>：记录击键以记录密码或助记词的恶意软件。</li></ul><p>这三类与加密货币相关的恶意软件加起来是过去一年中常见的第三大恶意软件类型。</p><p><img src="https://decoded.avast.io/wp-content/uploads/sites/2/2021/04/image-16.png" alt="img"><em>自 2020 年 3 月至 2021 年 3 月以来最常见的恶意软件类型</em></p><p>HackBoss 是一个简单的窃取加密货币的恶意软件，但它的金钱收益非常可观。这种恶意软件最有趣的方面是它传递给受害者的方式。HackBoss 的作者拥有一个 Telegram 频道，他们将其用作传播恶意软件的主要来源.</p><p>Hack Boss 频道上宣传虚假破解或黑客应用程序的帖子通常包含一个指向加密或匿名文件存储的链接，可以从中下载应用程序。该帖子还包含对应用程序假定功能的虚假描述以及应用程序 UI 的屏幕截图。它有时还包含一个指向 YouTube 频道的链接<code>https://www.youtube.com/channel/UC1IEdha7riKwVCfPk</code>（该频道在发布时已被删除）<code>Bank God</code> ，并带有促销视频。</p><p>Hack Boss 频道上宣传虚假破解或黑客应用程序的帖子通常包含一个指向加密或匿名文件存储的链接，可以从中下载应用程序。该帖子还包含对应用程序假定功能的虚假描述以及应用程序 UI 的屏幕截图。它有时还包含一个指向 YouTube 频道的链接<code>https://www.youtube.com/channel/UC1IEdha7riKwVCfPk</code>（该频道在发布时已被删除）<code>Bank God</code> ，并带有促销视频。</p><h3 id="七、SkidMap病毒利用Redis未授权访问漏洞攻击，数千台云主机沦为矿机（Linux）：https-mp-weixin-qq-com-s-biz-MzI5ODk3OTM1Ng-amp-mid-2247498404-amp-idx-2-amp-sn-bb356408fb8abc6e8d5a3411a42daa7a-amp-scene-19-wechat-redirect"><a href="#七、SkidMap病毒利用Redis未授权访问漏洞攻击，数千台云主机沦为矿机（Linux）：https-mp-weixin-qq-com-s-biz-MzI5ODk3OTM1Ng-amp-mid-2247498404-amp-idx-2-amp-sn-bb356408fb8abc6e8d5a3411a42daa7a-amp-scene-19-wechat-redirect" class="headerlink" title="七、SkidMap病毒利用Redis未授权访问漏洞攻击，数千台云主机沦为矿机（Linux）：https://mp.weixin.qq.com/s?__biz=MzI5ODk3OTM1Ng==&amp;mid=2247498404&amp;idx=2&amp;sn=bb356408fb8abc6e8d5a3411a42daa7a&amp;scene=19#wechat_redirect"></a>七、SkidMap病毒利用Redis未授权访问漏洞攻击，数千台云主机沦为矿机（Linux）：<a href="https://mp.weixin.qq.com/s?__biz=MzI5ODk3OTM1Ng==&amp;mid=2247498404&amp;idx=2&amp;sn=bb356408fb8abc6e8d5a3411a42daa7a&amp;scene=19#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzI5ODk3OTM1Ng==&amp;mid=2247498404&amp;idx=2&amp;sn=bb356408fb8abc6e8d5a3411a42daa7a&amp;scene=19#wechat_redirect</a></h3><ul><li>利用redis未授权访问漏洞入侵云主机；</li><li>下载门罗币、莱特币、比特币挖矿木马，通过挖矿牟利；</li><li>添加SSH公钥，以持久化远控失陷主机；</li><li>下载功能更加复杂的恶意软件包：接受远程指令，清除系统审计日志，安装服务，关闭SELinux降低系统安全性，通过安装Linux内核模块隐藏恶意行为。</li></ul><p>SkidMap病毒在2019年9月左右被发现，主要目标为感染肉鸡挖矿，该病毒的明显特征为通过加载Linux恶意内核模块来隐藏其恶意行为，增加了运维人员排查威胁的难度。</p><p>此次SkidMap病毒感染后会下载XMRig（门罗币挖矿木马）、cpuminer（莱特币和比特币挖矿木马），同时写入SSH后门公钥以方便远程登录，然后下载恶意程序包gold8.tar.gz，通过3DES解压后释放多个模块，完成挖矿木马启动、替换pam_unix.so文件留置登陆后门、上传日志到远程服务器，安装远控程序rctl的功能，还会安装Linux内核模块对恶意行为进行隐藏。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWWAXmCiceVcSLGmpT1yiabDzr7RZpFMhPrhk6Jspzj7HrYGXyX9sd8XVcK1k7vjV9lATGgrzibcKrqvw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><center>SkidMap病毒最新变种的恶意行为</center><h3 id="八、Sysrv-hello僵尸网络集木马、后门、蠕虫于一身，攻击Linux、Windows主机挖矿：https-mp-weixin-qq-com-s-biz-MzI5ODk3OTM1Ng-amp-mid-2247497474-amp-idx-1-amp-sn-87eb580380ee3ff5efd389da419f82c9-amp-scene-19-wechat-redirect"><a href="#八、Sysrv-hello僵尸网络集木马、后门、蠕虫于一身，攻击Linux、Windows主机挖矿：https-mp-weixin-qq-com-s-biz-MzI5ODk3OTM1Ng-amp-mid-2247497474-amp-idx-1-amp-sn-87eb580380ee3ff5efd389da419f82c9-amp-scene-19-wechat-redirect" class="headerlink" title="八、Sysrv-hello僵尸网络集木马、后门、蠕虫于一身，攻击Linux、Windows主机挖矿：https://mp.weixin.qq.com/s?__biz=MzI5ODk3OTM1Ng==&amp;mid=2247497474&amp;idx=1&amp;sn=87eb580380ee3ff5efd389da419f82c9&amp;scene=19#wechat_redirect"></a>八、Sysrv-hello僵尸网络集木马、后门、蠕虫于一身，攻击Linux、Windows主机挖矿：<a href="https://mp.weixin.qq.com/s?__biz=MzI5ODk3OTM1Ng==&amp;mid=2247497474&amp;idx=1&amp;sn=87eb580380ee3ff5efd389da419f82c9&amp;scene=19#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzI5ODk3OTM1Ng==&amp;mid=2247497474&amp;idx=1&amp;sn=87eb580380ee3ff5efd389da419f82c9&amp;scene=19#wechat_redirect</a></h3><p>该木马不仅攻击Linux系统，同时发现针对Windows平台的恶意载荷，攻击Windows系统成功后会植入powershell恶意脚本，脚本会进一步拉取Windows平台的相同模块到tmp目录执行。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYNEiasBtqHv28bRC3MkrxibbnSHEhJuHwQAeibPCibia9Iy2ziaF5d54icrnwg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>Linux系统下sysrv模块通过使用52013端口作为互斥量，端口开启状态判定为已感染环境直接退出，否则打开本地该端口进行占用。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYV8s9ib6NewG6XaLqLNNvO81uFTBCoTteIksff5gnbbkCoTjuu59fssg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYDexNqyxSGjrQCsj9V8wC2OS6EyFDtldt5RDIsqzUkHJmOmSXh7bZdg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>sysrv通过检测进程，判断network01进程（矿机进程）是否正常运行，如果未正常运行，就在tmp目录进一步释放出文件内嵌的elf文件，并命名为network01将其执行。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYlJjo4gvwviaIic78sFnS3PUdibSNu9ax8bcd1edyBU1JMUTPJjwnvhGfw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYicnYbPzf4tfL3RibSMCcHqPJaTfnp5mUIcPiaCs3Ry3hoX0EZycdD1AQw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYg2eSEYmpwQmxt7sO0qmQvDX6wEtsSlJafOC50RMzLRIDxJEib5XJsrw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>network01模块为门罗币矿机程序，该团伙通过清理可能的竞品挖矿进程或其他占CPU资料较多的进程实现独占CPU资源挖矿。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYibI5wb4WAPI0RoV0flaAVENJCjbkK9svXXNAqWqVP5cLBMameQrLoXw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>sysrv确认挖矿行为正常运行后，会开始进行蠕虫式的攻击传播：进行随机IP的端口扫描与漏洞利用，会尝试对mysql，Tomcat服务进行爆破攻击，尝试对Weblogic服务使用CVE-2020-14882漏洞（该漏洞公告由Oracle官方于2020年10月21日公开）进行远程代码执行攻击，这一横向扩散行为使该团伙控制的肉鸡规模迅速增大。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYrlm1UUrMpua7c2uqIUOc31pmBIjagN1gefmgYCpgnPKXRH2ATcoSYQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYKzbGSl4jicDxKzkt9CNYhKniaGhuxMdUz1xRw4xEqFZN190SicXeNwwPw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>hello_src_exp爆破，漏洞利用组合攻击</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYnEjXuw46MJfOpdlPb3QQXf7vRByRyUCDgcmVo9MDrsF0dcngxAN3NQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>攻击mysql服务使用的弱口令爆破字典</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYlf0XjYQzofW8lhJUkwmvUL6TNKqicUbx5Ichej0ictiasKpibANIpnmvGg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>攻击Tomcat服务使用的爆破口令</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYiannQk0ybp2bC8sRaMuV28RGazCX0PaFDHI9MTtCLI4TywfykEnhb5Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>对Weblogic组件利用CVE-2020-14882 远程代码执行漏洞攻击，该安全漏洞为2020年10月Oracle官方公告修复，属于相对比较新的漏洞攻击武器。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYO9MicAygYgvoIuOMFRicePv2oiblSukMgXsqfoZ55LvRNzdUXMRGEBBfg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYZkqS78hCgOHDLDIzmbAUADicMHbORVOnDvG1SSpj3Jj3kdeJkoZdZGg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="九、Putting-an-end-to-Retadup-A-malicious-worm-that-infected-hundreds-of-thousands：https-decoded-avast-io-janvojtesek-putting-an-end-to-retadup-a-malicious-worm-that-infected-hundreds-of-thousands-（据文章介绍，服务器已被清查）"><a href="#九、Putting-an-end-to-Retadup-A-malicious-worm-that-infected-hundreds-of-thousands：https-decoded-avast-io-janvojtesek-putting-an-end-to-retadup-a-malicious-worm-that-infected-hundreds-of-thousands-（据文章介绍，服务器已被清查）" class="headerlink" title="九、Putting an end to Retadup: A malicious worm that infected hundreds of thousands：https://decoded.avast.io/janvojtesek/putting-an-end-to-retadup-a-malicious-worm-that-infected-hundreds-of-thousands/（据文章介绍，服务器已被清查）"></a>九、Putting an end to Retadup: A malicious worm that infected hundreds of thousands：<a href="https://decoded.avast.io/janvojtesek/putting-an-end-to-retadup-a-malicious-worm-that-infected-hundreds-of-thousands/%EF%BC%88%E6%8D%AE%E6%96%87%E7%AB%A0%E4%BB%8B%E7%BB%8D%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B7%B2%E8%A2%AB%E6%B8%85%E6%9F%A5%EF%BC%89">https://decoded.avast.io/janvojtesek/putting-an-end-to-retadup-a-malicious-worm-that-infected-hundreds-of-thousands/（据文章介绍，服务器已被清查）</a></h3><p>Retadup 是一种恶意蠕虫，影响整个拉丁美洲的 Windows 计算机。它的目标是在受害者的计算机上实现持久性，将自身传播得更广泛，并在受感染的计算机上安装额外的恶意软件有效负载。在绝大多数情况下，安装的有效负载是代表恶意软件作者挖掘加密货币的恶意软件。但是，在某些情况下，我们还观察到 Retadup 分发了 Stop 勒索软件和 Arkei 密码窃取程序。</p><p>核心是用 AutoIt 或 AutoHotkey 编写的。在这两种情况下，它都包含两个文件：干净的脚本语言解释器和恶意脚本本身。这与当今大多数 AutoIt 恶意软件不同，后者通常仅由一个包含解释器和恶意脚本的恶意可执行文件组成。在 Retadup 的 AutoHotkey 变种中，恶意脚本作为源代码分发，而在 AutoIt 变种中，脚本首先被编译然后分发。</p><p>首先，程序检查是否存在另一个Retadup实例在运行，以保证任何时间仅有一个实例运行。之后会进行一些基本检查确保自己没有被分析，否则便静默退出。最后进入一个无线循环，定期轮询C&amp;C服务器以获取命令，若收到来自C&amp;C的命令，则执行收到的命令的处理程序，在联系C&amp;C 的同时，它还会定期执行其他尝试来传播自己并恢复其持久性机制。</p><p>几乎所有的 Retadup 样本都会首先检查它们运行的文件系统路径。如果解释器路径或脚本路径与预期不同，则脚本不会执行任何恶意操作。大多数示例还实现了一种延迟执行的方法。在执行开始时，它们要么执行一次长睡眠，要么执行一系列多次短睡眠。最后，一些变体还检查名称为<code>vmtoolsd.exe</code> 或 <code>procmon.exe</code>的进程是否正在运行、名称为<code>C:\CWSandbox\</code>或<code>C:\cuckoo\``SbieDll.dll``api_log.dll</code>的目录是否存在以及名称为 或 的模块是否已加载到当前进程中。</p><p><strong>Retadup 通过在其中创建注册表值<code>HKCU\Software\Microsoft\Windows\CurrentVersion\Run</code>和&#x2F;或创建计划任务来实现持久性</strong>。计划任务是使用<code>schtasks.exe</code>实体程序创建的，并设置为每分钟执行一次。Retadup 的 AutoIt 变体通常使用硬编码的注册表值.名称，而 AutoHotkey 变体倾向于使用注册表值和随机生成名称的计划任务。</p><p>Retadup主要通过将恶意快捷方式文件放到驱动器中实现传播。首先，它会遍历除了C盘外的所有驱动器根目录下的文件夹，并在每个文件夹下创建一个快捷方式，该快捷方式与源文件名相同，仅附加一个如<code>copy fpl.lnk</code>的字符后缀，它模拟真实的文件夹从而诱导用户执行。Retadup还将干净的AutoIt&#x2F;AutoHotkey 解释器和恶意脚本复制到系统隐藏目录，该目录位于相对于所选中的<code>LNK</code>文件的硬编码路径中。</p><p>每个 Retadup 样本都配置了一组C&amp;C 域名和端口，样本通过向他们发出 HTTP GET 请求来单独联系他们，样本会在发出的请求的URL的路径中对受害者的一些信息进行编码。虽然编码信息的确切内容和形式在不同的 Retadup 变体中有所不同，但所有 Retadup 变体都会在路径的开头对受害者的 ID 进行编码。</p><p>C&amp;C 服务器从接收到的 GET 请求的路径中解析信息，并返回一个包含要执行的命令的类似混淆的 HTTP 响应。</p><p>对于执行下载的命令，其执行附加 PE 有效负载的方式通常使用多层间接。首先获取 AutoIt 脚本，而不是直接下载和执行 PE 有效负载。AutoIt 脚本中嵌入了一个能够加载嵌入式 PE 文件的 shellcode。shellcode 被复制到通过<code>VirtualAlloc</code>. AutoIt 功能<code>DllCallAddress</code> 然后用于将控制权转移到 shellcode，shellcode 又将控制权加载并传递给最终的 PE 有效负载。这种间接的目的大概是为了避免将 PE 有效负载放到磁盘上，这会增加检测的机会。但上述工作流程并不是专门使用的。在其他一些情况下，我们还观察到 AutoIt 脚本直接下载 PE 文件，删除其区域标识符并直接从磁盘运行它。</p><p>由于内核以 AutoHotkey 源代码或 AutoIt 字节码（易于反编译）的形式分发，因此作者试图对其进行混淆以使分析更加困难。</p><p><strong>挖矿有效载荷</strong></p><p>矿工有效载荷以 32 位 PE 文件的形式出现，并且通常与各种打包程序&#x2F;加密程序打包在一起。以解压样本<code>9c46a0e48ea9b104f982e5ed04735b0078938866e3822712b5a5374895296d08</code>为例：它解密内存中的 XMRig PE 文件，并通过进程挖空将其注入到新创建的进程中。它还动态构建一个 XMRig 配置文件，将其放到磁盘上并将其传递给新创建的进程。该恶意软件在检测到<code>taskmgr.exe</code>运行时停止挖掘，因此用户更难检测到其增加的 CPU 使用率。注入 XMRig 的进程也充当看门狗。如果注入的工作进程因任何原因终止，则看门狗进程会生成一个新的工作进程来替换它。</p><p>从我们的角度来看，这个矿工最有趣的方面是注入方法。在足够高的水平上，注入只是常规的过程空心化。然而，虽然进程空心化通常是通过调用更高级别的函数来实现的，例如<code>WriteProcessMemory</code>or <code>NtMapViewOfSection</code>，但矿工选择了一种更隐蔽的方式直接使用系统调用。这比常规的进程空心化更难实现，但它可能允许作者绕过一些安全解决方案的用户态钩子。</p><p>大多数常规的流程空心实现直接使用从<code>ntdll</code>导出的未记录函数（例如<code>NtUnmapViewOfSection</code>）来实现流程注入。但是，许多终端安全解决方案能够通过挂钩众所周知的函数来检测这种注入方法。因此，某些恶意软件（例如Formbook）会将<code>ntdll</code>的第二个副本加载到其内存中，并调用从该副本导出的函数（这也称为“拉各斯岛”方法）。这背后的想法是，新副本<code>ntdll</code> （通常直接从磁盘读取）可能不包含原始副本所包含的钩子，因此安全软件可能看不到恶意软件调用了哪些函数。</p><p>(ntdll.dll是重要的Windows NT内核级文件。描述了windows本地NTAPI的接口。当Windows启动时，ntdll.dll就驻留在内存中特定的<a href="https://baike.baidu.com/item/%E5%86%99%E4%BF%9D%E6%8A%A4">写保护</a>区域，使别的程序无法占用这个内存区域。)</p><p>该矿机使用了上述“拉各斯岛”使用新的未挂钩<code>ntdll</code>副本的方法，但它也更进了一步。与进程空心相关的函数不会通过<code>ntdll</code>. 相反，矿工解析这些函数的主体并提取它们相应的系统调用号（在 Windows 上，系统调用号可以在版本之间更改，因此它们不能简单地在示例中硬编码）。一旦恶意软件获得了必要的系统调用号，它就会直接使用<code>sysenter</code> 指令调用系统调用。</p><p>这是可能的，因为大多数使用的<code>ntdll</code>函数只是系统调用的简单包装器。这样做的结果是恶意软件不调用任何导出的函数，因此常规的用户空间钩子可能不会拦截这些“函数”的使用。</p><p>由于矿工是32位PE文件，上述方法在32位系统上运行良好。但是WOW64呢？当然，矿工不能只从 32 位代码调用 64 位系统调用。相反，它使用了所谓的<a href="http://rce.co/knockin-on-heavens-gate-dynamic-processor-mode-switching/">天堂之门</a>技术来突破WOW64仿真层。一旦恶意软件通过天堂之门并执行 64 位代码，它就可以直接调用 64 位系统调用，然后返回到 32 位代码。Heaven’s Gate 技术的使用还允许矿工从 WoW64 子系统中注入 64 位版本的 XMRig。</p><p>（WoW64子系统是一个轻量级的compatibility layer, 在所有版本的windows上都拥有同样的接口. 它的主要目的是用来创建32-bit环境, 为了让32位的应用程序可以不经过任何修改就运行在64-bit的系统上, 它提供了必须的接口.</p><p>WOW64 是在用户模式下实现的，作为 ntdll.dll 和内核之间的层。WOW64 及其支持的一些 DLL 仅仅是可以加载到 32 位进程中的 64 位的 DLL。对于所有其他情况，进程保持为纯进程。32 位的进程无法加载 64 位的 DLL，反之亦然。）</p><p>矿工本身不使用任何特殊的混淆（作者可能假设他们使用的加密器就足够了）。但是，创建 XMRig 配置文件的代码包含使用硬编码密钥使用 Vigenère 密码加密的字符串。这似乎是一项基本的努力，使重新利用矿工变得更加困难。否则，其他恶意软件作者修补接收挖矿收入的地址并将矿工用于他们自己的邪恶目的将是微不足道的。</p><h3 id="十、F-Scrack-mimikatz-–-A-bundle-of-tools：https-decoded-avast-io-ondrejmokos-f-scrack-mimikatz-a-bundle-of-tools"><a href="#十、F-Scrack-mimikatz-–-A-bundle-of-tools：https-decoded-avast-io-ondrejmokos-f-scrack-mimikatz-a-bundle-of-tools" class="headerlink" title="十、F-Scrack-mimikatz – A bundle of tools：https://decoded.avast.io/ondrejmokos/f-scrack-mimikatz-a-bundle-of-tools/"></a>十、F-Scrack-mimikatz – A bundle of tools：<a href="https://decoded.avast.io/ondrejmokos/f-scrack-mimikatz-a-bundle-of-tools/">https://decoded.avast.io/ondrejmokos/f-scrack-mimikatz-a-bundle-of-tools/</a></h3><p>最近，在分析试图绕过各种 applocking 技术的样本时，我们重新审视了旧的各种工具包，其唯一目的是为运营商赚钱。尽管该活动似乎长期不活跃，但它表明创建能够赚钱的恶意软件几乎不需要编写原始代码，所需要的只是使用公开可用的代码片段将现有工具捆绑在一起。</p><p>该链以包含两个文件的自解压存档开始 -<code>Xagent.exe</code>和<code>depszip</code>. Depszip 是一个 ZIP 存档，其中包含各种辅助文件。Xagent.exe 是使用 PyInstaller 创建的二进制文件，并设置为在解压缩 SFX 存档后自动运行。调用了原始 Python 脚本<code>F-Scrack-mimikatz.py</code>并表明该代码源自<a href="https://github.com/qianniaoge/F-Scrack">F-Scrack</a>工具。</p><p>运行Mimikatz（用于从内存中提取铭文密码、哈希、PIN码等）：存档 depszip 包含 x86 和 x64 版本<code>mimi32.exe</code>以及<code>mimi64.exe</code>.  Mimikatz 找到的凭据被上传到<code>u.swb[.]one/upload/win</code>并用于构建攻击列表。然后使用该攻击列表在本地计算机上运行脚本，使用工具<a href="https://github.com/Twi1ight/AD-Pentest-Script/blob/master/wmiexec.vbs">wmiexec.vbs</a>和称为<a href="https://attack.mitre.org/techniques/T1117">Squibldoo</a>的技术。这种技术可能允许绕过安全工具和应用程序白名单的检测，将<code>regsvr32.exe</code>其用作执行代码的“代理”。执行的代码托管在<code>xmr.enjoytopic[.]tk/d/regxmr222.sct</code>.</p><p>通过攻击列表和Squibldoo技术攻击连接到相同LAN的其他计算机（进行端口扫描）。</p><p>之后通国ThreadNum类利用永恒之蓝漏洞排队检查并攻击指定IP和端口。之后通过无身份验证或者使用默认用户名和弱密码尝试访问服务，并查找如贸易、VIP、比特币、门罗币等有用的数据库。将找到的数据库和凭证返回，删除其他数据库并创建要求赎金的条目。</p><p>通过一个VBScript，按照泄露的Vault7文档描述，使用Vmic.exe设置持久性，此外，他还通过注册表设置持久性。它创造了两个键，一个使用mshta.exe运行来自于xmr.enjoytopic[.]tk&#x2F;d&#x2F;ps3.txt的代码，一个使用 Squiblydoo运行来自xmr.enjoytopic[.]tk&#x2F;d&#x2F;regxmr999.sct的代码。</p><p>除了设置持久性之外，该脚本还在受感染的机器上下载并运行 XMRig。XMRig 二进制文件有多个版本。这些二进制文件是定制的——除了运行 XMRig，它们还创建一个计划任务，通过Squibldoo 运行在</p><ul><li><code>xmr.enjoytopic[.]tk/d/regxmr222.sct</code>,</li><li><code>down.cacheoffer[.]tk/d2/reg9.sct</code>,</li><li><code>xmr.enjoytopic[.]tk/d/regxmr999.sct</code></li></ul><p>的代码，并使用vmic.exe保持持久性。</p><p>此外，还用过一个PowerShell脚本，从png.realtimenews[.]tk&#x2F;m.png下载XMRig脚本并运行，并通过每分钟的计划任务写入和运行自身。</p><h3 id="十一、Clipsa-–-Multipurpose-password-stealer：https-decoded-avast-io-janrubin-clipsa-multipurpose-password-stealer-（内容过长，暂时放一放）"><a href="#十一、Clipsa-–-Multipurpose-password-stealer：https-decoded-avast-io-janrubin-clipsa-multipurpose-password-stealer-（内容过长，暂时放一放）" class="headerlink" title="十一、Clipsa – Multipurpose password stealer：https://decoded.avast.io/janrubin/clipsa-multipurpose-password-stealer/（内容过长，暂时放一放）"></a>十一、Clipsa – Multipurpose password stealer：<a href="https://decoded.avast.io/janrubin/clipsa-multipurpose-password-stealer/%EF%BC%88%E5%86%85%E5%AE%B9%E8%BF%87%E9%95%BF%EF%BC%8C%E6%9A%82%E6%97%B6%E6%94%BE%E4%B8%80%E6%94%BE%EF%BC%89">https://decoded.avast.io/janrubin/clipsa-multipurpose-password-stealer/（内容过长，暂时放一放）</a></h3><p>Clipsa 是一个多用途密码窃取器，用 Visual Basic 编写，专注于从不安全的 WordPress 网站窃取加密货币、暴力破解和窃取管理员凭据、替换剪贴板中的加密地址以及在受感染机器上挖掘加密货币。Clipsa 的几个版本还部署了 XMRig 硬币矿工，以从受感染的计算机中赚取更多的钱。</p><p>我们估计攻击媒介很可能是媒体播放器（<code>Ultra XVid Codec Pack.exe</code>或<code>Installer_x86-x64_89006.exe</code>）的恶意编解码器包安装程序。尝试为其媒体播放器安装这些编解码器的用户会无意中下载恶意安装程序而不是干净的安装程序。一旦用户开始安装过程，他们就会在他们的机器上部署 Clipsa，恶意软件会立即开始其恶意行为。</p><p>Clipsa 使用带有多个参数（命令行参数）的单个可执行二进制文件。这些参数区分作为单独进程同时运行的程序阶段。每个阶段专注于不同的功能，并由 Clipsa 的初始化过程开始，该过程没有任何参数。</p><p>Clipsa 将这些参数用于相位：</p><ol><li><p>无参数</p></li><li><p>–CLIPS</p></li><li><p>–CLIPSS</p></li><li><p>–WALLS</p></li><li><p>–PARSE</p></li><li><p>–BRUTE</p></li></ol><p>阶段 2-4 旨在窃取用户数据，重点关注加密钱包相关数据。第 5 阶段和第 6 阶段的重点是查找易受攻击的 WordPress 网站并窃取其管理凭据。在本分析的其余部分，我们将重点关注这些阶段中的每一个。</p><ol><li><p>无参数阶段：</p><ul><li><p>预安装</p><p>当恶意软件在受感染的机器上运行时，程序无需任何参数即可直观地启动。此阶段允许 Clipsa 在系统上安装和隐藏自身。然后它继续初始化执行恶意操作的其他阶段。</p><p>在预安装阶段，Clipsa 会创建一个消息对话框，使其看起来像是某种设置过程。但是，这个对话框（见下图）实际上只是一个伪装，所以用户认为他们下载的编解码器包正在被安装。事实是该对话框仅显示随机生成的数字（增量相加）并打印总和。Clipsa 还在增量之间添加了随机睡眠，使过程看起来很自然。</p><p><img src="https://lh5.googleusercontent.com/BniDt3p_-XAMargEsAu0knBw16faRT2Fa7dEc6E9QpNLNDq04aFJJ9_a8esJL7sxljKRxhbTbFea4KXTIw0lczlMAyKNbvAnG3BbNfQ1aUxJU1zCvUmxrdduO8kpHRPbSDf9d0MG" alt="img"></p><center>以伪装方式说明设置进度的图</center><p>在总和达到 99% 后，该过程关闭对话框。在虚构的设置过程中，恶意软件不会执行任何恶意或有用的操作。我们认为这种行为的目的是延迟实际的恶意进程，从而避免在自动沙盒工具中被检测到。</p><p>虚拟设置完成后，Clipsa 使用 Windows Management Instrumentation (WMI) 检查任务管理器是否正在运行：<br><code>Select * from Win32_Process WHERE Name = &#39;taskmgr.exe&#39;</code><br>如果正在运行，则终止程序以避免用户检测。</p></li><li><p>安装</p><p>Clipsa 然后将自身复制到<code>%APPDATA%\Roaming</code>目录中。特定文件夹和二进制文件的命名取决于 Clipsa 的版本。较新版本之一将自身复制到：<br><code>C:\Users\user\AppData\Roaming\AudioDG\condlg.exe</code></p><p><code>C:\Users\user\AppData\Roaming\AudioDG\zcondlg.exe</code></p><p>在安装过程中，还会创建其他目录和文件：<br><code>C:\Users\user\AppData\Roaming\AudioDG\log.datC:\Users\user\AppData\Roaming\AudioDG\obj\C:\Users\user\AppData\Roaming\AudioDG\udb\</code></p><p>此外，将路径<code>condlg.exe</code>添加到注册表自动运行，确保恶意软件的持久性：<br><code>HCU\Software\Microsoft\Windows\CurrentVersion\Run\11f86284</code></p><p>此外，condlg.exe还会创建一个新进程（不带参数），该进程用作释放器并启动其他恶意阶段。然而，这个过程是从隐藏文件夹 AudioDG 开始的，这正是 Clipsa 知道它已经安装在系统上的方式。</p><p>最后但同样重要的是，最初的 Clipsa 流程注定要结束。即使整个 Clipsa 安装过程成功，恶意软件也会向用户显示错误消息，让用户相信编解码器安装失败，让他们认为没有安装任何内容：</p></li><li><p>condlg.dll 文件</p><p>在安装过程中，Clipsa 会检查用户执行恶意软件的目录中是否存在其他文件。此文件通常命名为65923_VTS.vob或setup.dll. 但是，它既不是多媒体容器也不是库。该文件是由 Clipsa 解密的加密文本文件，并保存到一个新文件中：<br>C:\Users\user\AppData\Roaming\AudioDG\condlg.dll</p><p>该文件包含数千个比特币地址。正如我们稍后将看到的，此文件将用于CLIPS 阶段，在此期间，剪贴板中的加密钱包地址被替换。但是，它的存在是可选的，没有它，Clipsa 也能完全发挥作用。</p><p>请注意，原始文件的名称遵循 Clipsa 伪装成媒体播放器的编解码器包安装程序的假设。</p></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、挖矿病毒的套路-https-zhuanlan-zhihu-com-p-164557943&quot;&gt;&lt;a href=&quot;#一、挖矿病毒的套路-https-zhuanlan-zhihu-com-p-164557943&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    
    <category term="恶意软件检测" scheme="https://boneink.github.io/tags/%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8B/"/>
    
    <category term="入侵检测" scheme="https://boneink.github.io/tags/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/"/>
    
    <category term="木马检测" scheme="https://boneink.github.io/tags/%E6%9C%A8%E9%A9%AC%E6%A3%80%E6%B5%8B/"/>
    
    <category term="网络安全" scheme="https://boneink.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>java-常量池与装拆箱机制</title>
    <link href="https://boneink.github.io/2022/05/17/java-%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%B8%8E%E8%A3%85%E6%8B%86%E7%AE%B1%E6%9C%BA%E5%88%B6/"/>
    <id>https://boneink.github.io/2022/05/17/java-%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%B8%8E%E8%A3%85%E6%8B%86%E7%AE%B1%E6%9C%BA%E5%88%B6/</id>
    <published>2022-05-17T04:00:00.000Z</published>
    <updated>2022-05-17T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>java的常量池分为以下三类：</p><ul><li><p>量池，编译阶段）</p></li><li><p>运行时常量池（又称动态常量池，运行阶段）</p></li><li><p>字符串常量池（全局的常量池）</p><p>  <strong>常量</strong> 可分为 <strong>字面常量</strong>（也称为直接常量）和 <strong>符号常量</strong>。<br>  <strong>字面常量</strong>： 是指在程序中无需预先定义就可使用的数字、字符、boolen值、字符串等。简单的说，就是确定值的本身。如 10，2L，2.3f，3.5，“hello”，’a’，true、false、null 等等。<br>  <strong>符号常量</strong>：　是指在程序中用标识符预先定义的，其值在程序中不可改变的量。如 <code>final int a = 5</code>;</p><p>  <strong>常量池</strong><br>  常量池引入的 <strong>目的</strong> 是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。这是一种 享元模式 的实现。</p></li></ul><h3 id="class文件常量池"><a href="#class文件常量池" class="headerlink" title="class文件常量池"></a>class文件常量池</h3><p>class文件常量池，也被称为 <strong>静态常量池</strong> ，它是.class文件所包含的一项信息。用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)。<br>该常量池内的信息：<br><strong>字面量</strong>： 就是上面所说的字面常量。<br><strong>符号引用</strong>： 是一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可（它与直接引用区分一下，<strong>直接引用</strong> 一般是指向方法区的本地指针，相对偏移量或是一个能间接定位到目标的句柄）。<strong>符号引用可以看作是一个虚拟地址，只有在JVM加载完类，确认了字面量的地址，才会将 符号引用 换成 直接引用</strong>。一般包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p><strong>运行时常量池</strong>，又称为 <strong>动态常量池</strong> ，是JVM在完成加载类之后将class文件中常量池载入到内存中，并保存在方法区中。也就是说，运行时常量池中的常量，基本来源于各个class文件中的常量池。 <strong>运行时常量池相对于CLass文件常量池的另外一个重要特征是具备 动态性 ，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。</strong><br>jvm在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，<strong>jvm就会将class常量池中的内容存放到运行时常量池中，也就是说，每个class对应运行时常量池中的一个独立空间，每个class文件存放的位置互不干扰</strong>。而在解析阶段，就会将符号引用替换成对应的直接引用。<br>不过，<strong>String类型</strong> 的字面常量要注意：并不是直接在堆上分配空间来创建对象的，JVM为String 字符串额外维护了一个常量池 <strong>字符串常量池</strong>，所以遇到字符串常量是要先去字符串池中寻找是否有重复，如果有，则返回对应的引用。否则，才创建并添加到字符串常量池中。换句话说，<strong>对于String类型的字面常量，必须要在 字符串常量池 中维护一个全局的引用。</strong></p><h3 id="字符串常量池（string-pool也有叫做string-literal-pool）"><a href="#字符串常量池（string-pool也有叫做string-literal-pool）" class="headerlink" title="字符串常量池（string pool也有叫做string literal pool）"></a>字符串常量池（string pool也有叫做string literal pool）</h3><p>字符串常量池存储的就是字符串的字面常量。详细一点，字符串常量池里的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中。<br>对于运行时常量池和字符串常量池，jdk1.6之前，二者都放在方法区，jdk1.7将字符串常量池移到了堆外内存。运行时常量池为每个class文件的常量池提供一个运行时的内存空间，字符串常量池为所有的class文件的String类型的字面常量维护一个公共的常量池，<strong>Class文件的常量池加载进运行时常量池后，其String字面常量的引用指向要与字符串常量池的维护的要一致</strong>。</p><h2 id="自动装箱拆箱机制-与-缓存机制"><a href="#自动装箱拆箱机制-与-缓存机制" class="headerlink" title="自动装箱拆箱机制 与 缓存机制"></a>自动装箱拆箱机制 与 缓存机制</h2><h3 id="自动装拆箱机制介绍"><a href="#自动装拆箱机制介绍" class="headerlink" title="自动装拆箱机制介绍"></a>自动装拆箱机制介绍</h3><p><strong>装箱</strong>： 可以自动将基本类型直接转换成对应的包装类型。<br><strong>拆箱</strong>： 自动将包装类型转换成对应的基本类型值；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//普通的创建对象方式  </span></span><br><span class="line">   <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">5</span>);  </span><br><span class="line">   <span class="comment">//装箱  </span></span><br><span class="line">   <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">5</span>;  </span><br><span class="line">   <span class="comment">//拆箱  </span></span><br><span class="line">   <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> b+<span class="number">5</span>;</span><br></pre></td></tr></table></figure><pre><code>Java中基本数据类型和包装类型的区别1、包装类是对象，拥有方法和字段，对象的调用都是通过引用对象的地址；基本类型不是   2、包装类型是引用的传递；基本类型是值的传递   3、声明方式不同：                  基本数据类型不需要 new 关键字；                  包装类型需要 new 在堆内存中进行 new 来分配内存空间   4、存储位置不同：                基本数据类型直接将值保存在值栈中；                  包装类型是把对象放在堆中，然后通过对象的引用来调用他们   5、初始值不同：                int 的初始值为 0 、 boolean 的初始值为 false                   包装类型的初始值为 null   6、使用方式不同：                基本数据类型直接赋值使用就好；                  包装类型是在集合如 coolectionMap 时使用</code></pre><h3 id="自动装箱拆箱的原理"><a href="#自动装箱拆箱的原理" class="headerlink" title="自动装箱拆箱的原理"></a>自动装箱拆箱的原理</h3><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_6</span> &#123;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">   <span class="comment">//装箱  </span></span><br><span class="line">   <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">5</span>;  </span><br><span class="line">   <span class="comment">//拆箱  </span></span><br><span class="line">   <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> b+<span class="number">5</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_6</span>  </span><br><span class="line">&#123;  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>   &#123;  </span><br><span class="line">       <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> Integer.valueOf(<span class="number">5</span>);  </span><br><span class="line">       <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> b.intValue() + <span class="number">5</span>;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质上，自动装箱和拆箱，是自动调用了<code>Integer.valueOf()</code>（装箱） 和 <code>Integer.initValue()</code>（拆箱）来完成的。</p><h3 id="包装类的缓存机制"><a href="#包装类的缓存机制" class="headerlink" title="包装类的缓存机制"></a>包装类的缓存机制</h3><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">       <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;  </span><br><span class="line">       <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">5</span>;  </span><br><span class="line">       <span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">129</span>;  </span><br><span class="line">       <span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">129</span>;  </span><br><span class="line">       System.out.println(<span class="string">&quot;a==b &quot;</span>+ (a == b));  </span><br><span class="line">       System.out.println(<span class="string">&quot;c==d &quot;</span>+ (c == d));  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果：<br>    a &#x3D;&#x3D; b  true<br>    c &#x3D;&#x3D; d  false<br>变量a、b、c、d是由装箱得到的，而装箱则是编译器自动添加了Integer.valueOf()方法，而其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;  </span><br><span class="line">       <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)  </span><br><span class="line">           <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];  </span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>代码很简单，判断装箱所使用的基本类型值是否在 [ IntegerCache.low, IntegerCache.high] 的范围内，如果在，返回IntegerCache.cache数组中对应下标的元素。否则，才新建一个对象。<br>IntegerCache的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;  </span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;  </span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;  </span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];  </span><br><span class="line">       <span class="keyword">static</span> &#123;  </span><br><span class="line">           <span class="comment">// high value may be configured by property  </span></span><br><span class="line">           <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;  </span><br><span class="line">           <span class="type">String</span> <span class="variable">integerCacheHighPropValue</span> <span class="operator">=</span>  </span><br><span class="line">               sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);  </span><br><span class="line">           <span class="comment">//获取上限值  </span></span><br><span class="line">           <span class="keyword">if</span> (integerCacheHighPropValue != <span class="literal">null</span>) &#123;  </span><br><span class="line">               <span class="keyword">try</span> &#123;  </span><br><span class="line">                   <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> parseInt(integerCacheHighPropValue);  </span><br><span class="line">                   i = Math.max(i, <span class="number">127</span>);  </span><br><span class="line">                   <span class="comment">// Maximum array size is Integer.MAX_VALUE  </span></span><br><span class="line">                   h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);  </span><br><span class="line">               &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;  </span><br><span class="line">                   <span class="comment">// If the property cannot be parsed into an int, ignore it.  </span></span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">           high = h;  </span><br><span class="line">           <span class="comment">//创建数组  </span></span><br><span class="line">           cache = <span class="keyword">new</span> <span class="title class_">Integer</span>[(high - low) + <span class="number">1</span>];  </span><br><span class="line">           <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low;  </span><br><span class="line">           <span class="comment">//填充数组  </span></span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; cache.length; k++)  </span><br><span class="line">               cache[k] = <span class="keyword">new</span> <span class="title class_">Integer</span>(j++);  </span><br><span class="line">           <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)  </span></span><br><span class="line">           <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">private</span> <span class="title function_">IntegerCache</span><span class="params">()</span> &#123;&#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>从源码中，可以知道，<code>IntegerCache.cache</code>是一个final的Integer数组，这个数组存储的Integer对象元素的值范围是[-128，127]。而且这个数组的初始化代码是包裹在static代码块中，也就是说<code>IntegerCache.cache</code>  <strong>数组的初始化是在类加载时完成的。</strong></p><p>变量a和b的使用的基本类型值为5，未超出[-128,127]的范围，所以就使用缓存数组中的元素，所以a、b的地址是一样的。而c、d使用的基本类型值为129，超出缓存范围，所以都是各自在堆上创建一个对，地址自然就不一样了。</p><h2 id="总结和补充："><a href="#总结和补充：" class="headerlink" title="总结和补充："></a>总结和补充：</h2><ul><li>包装类与String类很相似，都是非可变类，即一经创建后，便不可以修改。正因为这种特性，两者的对象实例在多线程下是安全的，不用担心异步修改的情况，这为他们实现共享提供了很好的保证，只需创建一个对象共享便可。</li><li>包装类的共享实现并不是由JVM来维护一个常量池，而是使用了缓存机制（数组），而且这个缓存是在类加载时完成初始化，并且不可再修改。</li><li>包装类的数组缓存范围是有限，只缓存基本类型值在一个字节范围内，也就是说 -128 ~ 127。（Character的范围是 0~127）</li><li>目前并不是所有包装类都提供缓存机制，只有Byte、Character、Short、Integer 4个包装类提供，Long、Float、Double 不提供。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;常量池&quot;&gt;&lt;a href=&quot;#常量池&quot; class=&quot;headerlink&quot; title=&quot;常量池&quot;&gt;&lt;/a&gt;常量池&lt;/h2&gt;&lt;p&gt;java的常量池分为以下三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;量池，编译阶段）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;运行时常量池（又</summary>
      
    
    
    
    
    <category term="java" scheme="https://boneink.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java-java四种访问权限</title>
    <link href="https://boneink.github.io/2022/05/16/java-java%E5%9B%9B%E7%A7%8D%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/"/>
    <id>https://boneink.github.io/2022/05/16/java-java%E5%9B%9B%E7%A7%8D%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/</id>
    <published>2022-05-16T04:00:00.000Z</published>
    <updated>2022-05-16T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java四种访问权限"><a href="#java四种访问权限" class="headerlink" title="java四种访问权限"></a>java四种访问权限</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>访问权限控制</strong>： 指的是本类及本类内部的成员（成员变量、成员方法、内部类）对其他类的可见性，即这些内容是否允许其他类访问。</p><p>Java 中一共有四种访问权限控制，其权限控制的大小情况是这样的：<strong>public &gt; protected &gt; default(包访问权限) &gt; private</strong> ,具体的权限控制看下面表格，列所指定的类是否有权限允许访问行的权限控制下的内容：</p><table><thead><tr><th>访问权限</th><th>本类</th><th>本包的类</th><th>子类</th><th>非子类的外包类</th></tr></thead><tbody><tr><td>public</td><td>是</td><td>是</td><td>是</td><td>是</td></tr><tr><td>protected</td><td>是</td><td>是</td><td>是</td><td>否</td></tr><tr><td>default</td><td>是</td><td>是</td><td>否</td><td>否</td></tr><tr><td>private</td><td>是</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><p><strong>1、public：</strong> 所修饰的类、变量、方法，在内外包均具有访问权限；<br><strong>2、protected：</strong> 这种权限是为继承而设计的，protected所修饰的成员，对所有子类是可访问的，但只对同包的类是可访问的，对外包的非子类是不可以访问；<br><strong>3、包访问权限（default）：</strong> 只对同包的类具有访问的权限，外包的所有类都不能访问；<br><strong>4、private：</strong> 私有的权限，只对本类的方法可以使用；</p><p><strong>注意： 要区分开 protected 权限、包访问权限，正确使用它们；</strong></p><ul><li>当某个成员能被所有的子类继承，但不能被外包的非子类访问，就是用protected；</li><li>当某个成员的访问权限只对同包的类开放，包括不能让外包的类继承这个成员，就用包访问权限；<br><strong>使用访问权限控制的原因：</strong><br>1）使用户不要碰触那些他们不该碰触的部分；<br>2）类库设计者可以更改类的内部工作的方式，而不会担心这样会对用户产生重大影响；<br>即分割用户操作和类内部工作区域，减少彼此影响。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;java四种访问权限&quot;&gt;&lt;a href=&quot;#java四种访问权限&quot; class=&quot;headerlink&quot; title=&quot;java四种访问权限&quot;&gt;&lt;/a&gt;java四种访问权限&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="java" scheme="https://boneink.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java-switch语句</title>
    <link href="https://boneink.github.io/2022/05/15/java-switch%E8%AF%AD%E5%8F%A5/"/>
    <id>https://boneink.github.io/2022/05/15/java-switch%E8%AF%AD%E5%8F%A5/</id>
    <published>2022-05-15T04:00:00.000Z</published>
    <updated>2022-05-15T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><h3 id="switch-语法格式："><a href="#switch-语法格式：" class="headerlink" title="switch 语法格式："></a>switch 语法格式：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式) &#123;  </span><br><span class="line">       <span class="keyword">case</span> 常量表达式或枚举常量:  </span><br><span class="line">           语句;  </span><br><span class="line">           <span class="keyword">break</span>;  </span><br><span class="line">       <span class="keyword">case</span> 常量表达式或枚举常量 :  </span><br><span class="line">           语句;  </span><br><span class="line">           <span class="keyword">break</span>;  </span><br><span class="line">       ......  </span><br><span class="line">       <span class="keyword">default</span>: 语句;  </span><br><span class="line">           <span class="keyword">break</span>;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>switch 匹配的表达式可以是：</strong></p><ul><li>byte、short、char、int类型及 这4种类型的包装类型；</li><li>枚举类型； </li><li>String 类型；</li></ul><p><strong>case 匹配的表达式可以是：</strong></p><ul><li>常量表达式；</li><li>枚举常量；</li></ul><p><strong>注意一点：</strong> case提供了switch表达式的入口地址，一旦switch表达式与某个case分支匹配，则从该分支的语句开始执行，一直执行下去，即其后的所有case分支的语句也会被执行，直到遇到break语句。</p><h3 id="编译器对-switch-表达式的各种类型的处理："><a href="#编译器对-switch-表达式的各种类型的处理：" class="headerlink" title="编译器对 switch 表达式的各种类型的处理："></a>编译器对 switch 表达式的各种类型的处理：</h3><p><strong>在底层中，swtich 只能支持4种基本类型，其他几个类型是通过一些方式来间接处理的</strong>。</p><ol><li>包装类：<br>通过拆箱，获得其对应的数值：<br>如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">       <span class="type">Byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;  </span><br><span class="line">       <span class="keyword">switch</span> (b) &#123;  </span><br><span class="line">       <span class="keyword">case</span> <span class="number">1</span>:  </span><br><span class="line">           System.out.println(<span class="string">&quot;匹配成功&quot;</span>);  </span><br><span class="line">           <span class="keyword">break</span>;  </span><br><span class="line">       <span class="keyword">case</span> <span class="number">2</span>:  </span><br><span class="line">           System.out.println(<span class="string">&quot;匹配成功&quot;</span>);  </span><br><span class="line">           <span class="keyword">break</span>;  </span><br><span class="line">       &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>对应的反编译：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">      <span class="type">Byte</span> <span class="variable">b</span> <span class="operator">=</span> Byte.valueOf((<span class="type">byte</span>)<span class="number">2</span>);  </span><br><span class="line">       <span class="keyword">switch</span>(b.byteValue())  </span><br><span class="line">       &#123;  </span><br><span class="line">       <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// &#x27;\001&#x27;  </span></span><br><span class="line">           System.out.println(<span class="string">&quot;\u5339\u914D\u6210\u529F&quot;</span>);  </span><br><span class="line">           <span class="keyword">break</span>;  </span><br><span class="line">       <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// &#x27;\002&#x27;  </span></span><br><span class="line">           System.out.println(<span class="string">&quot;\u5339\u914D\u6210\u529F&quot;</span>);  </span><br><span class="line">           <span class="keyword">break</span>;  </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li><li>枚举类型：<br>以JDK提供的枚举类型的线程状态类 <code>Thread.state</code> 类为例：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   Thread.<span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> Thread.State.RUNNABLE;  </span><br><span class="line">   <span class="keyword">switch</span> (state) &#123;  </span><br><span class="line">   <span class="keyword">case</span> NEW:  </span><br><span class="line">       System.out.println(<span class="string">&quot;线程处于创建状态&quot;</span>);  </span><br><span class="line">       <span class="keyword">break</span>;  </span><br><span class="line">   <span class="keyword">case</span> RUNNABLE:  </span><br><span class="line">       System.out.println(<span class="string">&quot;线程处于可运行状态&quot;</span>);  </span><br><span class="line">       <span class="keyword">break</span>;  </span><br><span class="line">   <span class="keyword">case</span> TERMINATED:  </span><br><span class="line">       System.out.println(<span class="string">&quot;线程结束&quot;</span>);  </span><br><span class="line">       <span class="keyword">break</span>;  </span><br><span class="line">   <span class="keyword">default</span>:  </span><br><span class="line">       <span class="keyword">break</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   反编译代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Sex</span> <span class="variable">sex</span> <span class="operator">=</span> Sex.MALE;  </span><br><span class="line">       <span class="keyword">switch</span>($SWITCH_TABLE$Test_2018_1_14$Sex()[sex.ordinal()])  </span><br><span class="line">       &#123;  </span><br><span class="line">       <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// &#x27;\001&#x27;  </span></span><br><span class="line">           System.out.println(<span class="string">&quot;sex:male&quot;</span>);  </span><br><span class="line">           <span class="keyword">break</span>;  </span><br><span class="line">       <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// &#x27;\002&#x27;  </span></span><br><span class="line">           System.out.println(<span class="string">&quot;sex:female&quot;</span>);  </span><br><span class="line">           <span class="keyword">break</span>;  </span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>   从编译代码中发现，编译器对于枚举类型的处理，是通过创建一个辅助数组来处理，这个数组是通过一个<code>$SWITCH_TABLE$java$lang$Thread$State()</code> 方法创建的，数组是一个int[]类型数组，数组很简单，<strong>在每个枚举常量的序号所对应的数组下标位置的赋一个值，按序号大小赋值，从1开始递增</strong>。 其代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int 数组  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> $SWITCH_TABLE$java$lang$Thread$State[];  </span><br><span class="line"><span class="comment">//创建数组的方法  </span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span>[] $SWITCH_TABLE$java$lang$Thread$State()  </span><br><span class="line">   &#123;  </span><br><span class="line">       $SWITCH_TABLE$java$lang$Thread$State;  </span><br><span class="line">       <span class="keyword">if</span>($SWITCH_TABLE$java$lang$Thread$State == <span class="literal">null</span>) goto _L2; <span class="keyword">else</span> goto _L1  </span><br><span class="line">_L1:  </span><br><span class="line">       <span class="keyword">return</span>;  </span><br><span class="line">_L2:  </span><br><span class="line">       JVM INSTR pop ;  </span><br><span class="line">       <span class="type">int</span> ai[] = <span class="keyword">new</span> <span class="title class_">int</span>[Thread.State.values().length];  </span><br><span class="line">       <span class="keyword">try</span>  </span><br><span class="line">       &#123;  </span><br><span class="line">           ai[Thread.State.BLOCKED.ordinal()] = <span class="number">3</span>;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">catch</span>(NoSuchFieldError _ex) &#123; &#125;  </span><br><span class="line">       <span class="keyword">try</span>  </span><br><span class="line">       &#123;  </span><br><span class="line">           ai[Thread.State.NEW.ordinal()] = <span class="number">1</span>;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">catch</span>(NoSuchFieldError _ex) &#123; &#125;  </span><br><span class="line">       <span class="keyword">try</span>  </span><br><span class="line">       &#123;  </span><br><span class="line">           ai[Thread.State.RUNNABLE.ordinal()] = <span class="number">2</span>;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">catch</span>(NoSuchFieldError _ex) &#123; &#125;  </span><br><span class="line">       <span class="keyword">try</span>  </span><br><span class="line">       &#123;  </span><br><span class="line">           ai[Thread.State.TERMINATED.ordinal()] = <span class="number">6</span>;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">catch</span>(NoSuchFieldError _ex) &#123; &#125;  </span><br><span class="line">       <span class="keyword">try</span>  </span><br><span class="line">       &#123;  </span><br><span class="line">           ai[Thread.State.TIMED_WAITING.ordinal()] = <span class="number">5</span>;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">catch</span>(NoSuchFieldError _ex) &#123; &#125;  </span><br><span class="line">       <span class="keyword">try</span>  </span><br><span class="line">       &#123;  </span><br><span class="line">           ai[Thread.State.WAITING.ordinal()] = <span class="number">4</span>;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">catch</span>(NoSuchFieldError _ex) &#123; &#125;  </span><br><span class="line">       <span class="type">return</span> <span class="variable">$SWITCH_TABLE$java$lang$Thread$State</span> <span class="operator">=</span> ai;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>String类型：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">       <span class="type">String</span>  <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;China&quot;</span>;  </span><br><span class="line">       <span class="keyword">switch</span> (s) &#123;  </span><br><span class="line">       <span class="keyword">case</span> <span class="string">&quot;America&quot;</span>:  </span><br><span class="line">                System.out.println(<span class="string">&quot;匹配到美国&quot;</span>);  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">       <span class="keyword">case</span> <span class="string">&quot;China&quot;</span>:  </span><br><span class="line">               System.out.println(<span class="string">&quot;匹配到中国&quot;</span>);  </span><br><span class="line">               <span class="keyword">break</span>;  </span><br><span class="line">       <span class="keyword">case</span> <span class="string">&quot;Japan&quot;</span>:  </span><br><span class="line">                System.out.println(<span class="string">&quot;匹配到日本&quot;</span>);  </span><br><span class="line">       <span class="keyword">default</span>:  </span><br><span class="line">           <span class="keyword">break</span>;  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>反编译：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>   &#123;  </span><br><span class="line">       <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;China&quot;</span>;  </span><br><span class="line">       String s1;  </span><br><span class="line">       <span class="keyword">switch</span>((s1 = s).hashCode())  </span><br><span class="line">       &#123;  </span><br><span class="line">       <span class="keyword">default</span>:  </span><br><span class="line">           <span class="keyword">break</span>;  </span><br><span class="line">       <span class="keyword">case</span> <span class="number">65078583</span>:  </span><br><span class="line">           <span class="keyword">if</span>(s1.equals(<span class="string">&quot;China&quot;</span>))  </span><br><span class="line">               System.out.println(<span class="string">&quot;\u5339\u914D\u5230\u4E2D\u56FD&quot;</span>);  </span><br><span class="line">           <span class="keyword">break</span>;  </span><br><span class="line">       <span class="keyword">case</span> <span class="number">71341030</span>:  </span><br><span class="line">           <span class="keyword">if</span>(s1.equals(<span class="string">&quot;Japan&quot;</span>))  </span><br><span class="line">               System.out.println(<span class="string">&quot;\u5339\u914D\u5230\u65E5\u672C&quot;</span>);  </span><br><span class="line">           <span class="keyword">break</span>;  </span><br><span class="line">       <span class="keyword">case</span> <span class="number">775550446</span>:  </span><br><span class="line">           <span class="keyword">if</span>(s1.equals(<span class="string">&quot;America&quot;</span>))  </span><br><span class="line">               System.out.println(<span class="string">&quot;\u5339\u914D\u5230\u7F8E\u56FD&quot;</span>);  </span><br><span class="line">           <span class="keyword">break</span>;  </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>从反编译的代码可以看出，switch 的String变量、case 的String常量都变成对应的字符串的 hash 值。也就是说，switch仍然没有超出它的限制，只是通过<strong>使用 String对象的hash值来进行匹配比较</strong>，从而支持 String 类型。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;switch语句&quot;&gt;&lt;a href=&quot;#switch语句&quot; class=&quot;headerlink&quot; title=&quot;switch语句&quot;&gt;&lt;/a&gt;switch语句&lt;/h2&gt;&lt;h3 id=&quot;switch-语法格式：&quot;&gt;&lt;a href=&quot;#switch-语法格式：&quot; cla</summary>
      
    
    
    
    
    <category term="java" scheme="https://boneink.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java-String性质</title>
    <link href="https://boneink.github.io/2022/05/14/java-String%E6%80%A7%E8%B4%A8/"/>
    <id>https://boneink.github.io/2022/05/14/java-String%E6%80%A7%E8%B4%A8/</id>
    <published>2022-05-14T04:00:00.000Z</published>
    <updated>2022-05-14T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="String性质"><a href="#String性质" class="headerlink" title="String性质"></a>String性质</h2><h3 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h3><p>String一旦创建，就是不可变的，其通过两个方法维护其不可变性：</p><ol><li>final类 和 final的私有成员<br>String的部分源码：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span>  </span><br><span class="line">   <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;  </span><br><span class="line">   <span class="comment">/** The value is used for character storage. */</span>  </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];  </span><br><span class="line">   <span class="comment">/** Cache the hash code for the string */</span>  </span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0  </span></span><br><span class="line">   <span class="comment">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span>  </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">6849794470754667710L</span>;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p> 我们可以发现 <strong>String是一个final类，且3个成员都是私有的</strong>，这就意味着String是不能被继承的，这就防止出现：程序员通过继承重写String类的方法的手段来使得String类是“可变的”的情况。<br> 同时，尽管String是通过维护一个内部的char数组实现的，但是无法通过修改外部char数组元素的方式修改String内容：<br> 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">       <span class="type">char</span>[] arr = <span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;;        </span><br><span class="line">       <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);        </span><br><span class="line">       arr[<span class="number">3</span>]=<span class="string">&#x27;e&#x27;</span>;      </span><br><span class="line">       System.out.println(<span class="string">&quot;str= &quot;</span>+str);  </span><br><span class="line">       System.out.println(<span class="string">&quot;arr[]= &quot;</span>+Arrays.toString(arr));  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p> <strong>运行结果</strong></p><blockquote><p>str&#x3D; abcd<br>arr[]&#x3D; [a, b, c, e]</p></blockquote><p> 字符串str使用数组arr来构造一个对象，当数组arr修改其元素值后，字符串str并没有跟着改变。查看String创建对应的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">char</span> value[])</span> &#123;  </span><br><span class="line">       <span class="built_in">this</span>.value = Arrays.copyOf(value, value.length);  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p> 可以看出<strong>String在使用外部char数组构造对象时，是重新复制了一份外部char数组</strong>，从而不会让外部char数组的改变影响到String对象。<br>2. 一旦发生改变就创建新对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex, <span class="type">int</span> endIndex)</span> &#123;  </span><br><span class="line">       <span class="comment">//........  </span></span><br><span class="line">       <span class="keyword">return</span> ((beginIndex == <span class="number">0</span>) &amp;&amp; (endIndex == value.length)) ? <span class="built_in">this</span>  </span><br><span class="line">               : <span class="keyword">new</span> <span class="title class_">String</span>(value, beginIndex, subLen);  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p> 从源码可以看出，如果不是切割整个字符串的话，就会新建一个对象。也就是说，<strong>只要与原字符串不相等，就会新建一个String对象</strong>。</p><h3 id="tring的-操作-与-字符串常量池"><a href="#tring的-操作-与-字符串常量池" class="headerlink" title="tring的+操作 与 字符串常量池"></a>tring的+操作 与 字符串常量池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">       <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Love You&quot;</span>;        </span><br><span class="line">       <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;Love&quot;</span>+<span class="string">&quot; You&quot;</span>;  </span><br><span class="line">       <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s2 + <span class="string">&quot;&quot;</span>;  </span><br><span class="line">       <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Love You&quot;</span>);  </span><br><span class="line">       System.out.println(<span class="string">&quot;s == s2 &quot;</span>+(s==s2));  </span><br><span class="line">       System.out.println(<span class="string">&quot;s == s3 &quot;</span>+(s==s3));  </span><br><span class="line">       System.out.println(<span class="string">&quot;s == s4 &quot;</span>+(s==s4));  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><blockquote><p>s &#x3D;&#x3D; s2  true<br>s &#x3D;&#x3D; s3  false<br>s &#x3D;&#x3D; s4  false</p></blockquote><p>由于编译器在编译期间会对代码尽可能优化，所以常量表达式的计算会在编译期间完成。因此s2的值在编译期间已经完成，并同s一起在类加载时创建并维护在字符串常量池中，由于常量池中的每个字符串只存在一个，因此s2和s指向同一个对象，二者相等。但s3和s4的表达式中含有非常量，需要在执行时才能计算。因此不会和s相等。<br>而对于+操作，通过jad命令 jad MyTest.class反编译代码可得：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span>  </span><br><span class="line">&#123;  </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">MyTest</span><span class="params">()</span>   &#123;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>   &#123;  </span><br><span class="line">       <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Love You&quot;</span>;  </span><br><span class="line">       <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;Love You&quot;</span>;<span class="comment">//已经得到计算结果  </span></span><br><span class="line">       <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> (<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(String.valueOf(s2))).toString();  </span><br><span class="line">       <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Love You&quot;</span>);  </span><br><span class="line">       System.out.println((<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;s == s2 &quot;</span>)).append(s == s2).toString());  </span><br><span class="line">       System.out.println((<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;s == s3 &quot;</span>)).append(s == s3).toString());  </span><br><span class="line">       System.out.println((<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;s == s4 &quot;</span>)).append(s == s4).toString());  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，编译器将 + 号处理成了<code>StringBuilder.append()</code>方法。也就是说，在运行期间，链接字符串的计算都是通过 创建StringBuilder对象，调用<code>append()</code>方法来完成的，而且是每一个链接字符串的表达式都要创建一个 StringBuilder对象。因此<strong>对于循环中反复执行字符串链接时，应该考虑直接使用StringBuilder来代替 + 链接，避免重复创建StringBuilder的性能开销。</strong> </p><h4 id="String-intern-方法："><a href="#String-intern-方法：" class="headerlink" title="String.intern()方法："></a>String.intern()方法：</h4><p>该方法可以将String类型的对象转移到常量池中，但在jdk6和jdk7中，该方法实现的方式不同：</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td>JDK6</td><td>JDK7 及之后</td></tr><tr><td>intern() 方法</td><td>会把首次遇到的字符串实例复制到常量池中，并返回此引用</td><td>会把首次遇到的字符串实例的引用添加到常量池中，并返回此引用</td></tr></tbody></table><p>同时，jdk7中，如果某个字符串不再被引用，便会从常量池中回收。<br>通过两段代码理解两种实现方法的不同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>); <span class="comment">//常量池中创建&quot;1&quot;，堆中创建&quot;1&quot;</span></span><br><span class="line">s1.intern();          <span class="comment">//常量池中已有&quot;1&quot;，所以jdk6和jkd7都是返回指向常量池&quot;1&quot;的引用，</span></span><br><span class="line">                      <span class="comment">//但因为该语句没有赋值操作，所以s1仍指向堆中&quot;1&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;      <span class="comment">//s2指向常量池中已存在的&quot;1&quot;</span></span><br><span class="line">System.out.println(s1==s2);  <span class="comment">//s1指向堆中&quot;1&quot;，s2指向常量池中&quot;1&quot;，false</span></span><br></pre></td></tr></table></figure><p> jdk6、7、8 都返回 false<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>); <span class="comment">//常量池生成一个&quot;1&quot;，堆生成一个&quot;11&quot;</span></span><br><span class="line">                                               <span class="comment">//s3指向堆中&quot;11&quot;</span></span><br><span class="line">                                       <span class="comment">//中间还有2个匿名的new String(&quot;1&quot;)暂不讨论</span></span><br><span class="line">s3.intern();             <span class="comment">//因为常量池中不存在&quot;11&quot;，</span></span><br><span class="line">                         <span class="comment">//jdk6会将堆中&quot;11&quot;复制到常量池中，</span></span><br><span class="line">                         <span class="comment">//jdk7则将堆中&quot;11&quot;的引用添加到常量池中，</span></span><br><span class="line">                         <span class="comment">//此时s3仍指向堆中&quot;11&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;        <span class="comment">//因为常量池中已存在&quot;11&quot;或其引用，s4指向常量池中&quot;11&quot;</span></span><br><span class="line">System.out.println(s3==s4);  <span class="comment">//jdk6中，s4指向常量池中&quot;11&quot;，s3指向堆中&quot;11&quot;，false</span></span><br><span class="line">                             <span class="comment">//jdk7中，s4指向常量池中指向堆中&quot;11&quot;的引用，true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p> 在 jdk6 中返回 false，jdk7 及以上返回 true<br> intern() 方法优点：执行速度非常快，直接使用 &#x3D;&#x3D; 进行比较要比使用 equals() 方法快很多；内存占用少。虽然 intern() 方法的优点看上去很诱人，但由于 intern() 操作每次都需要与常量池中的数据进行比较以查看常量池中是否存在等值数据，同时 JVM 需要确保常量池中的数据的唯一性，这就涉及到加锁机制，这些操作都是有需要占用 CPU 时间的，所以如果进行 intern 操作的是大量不会被重复利用的 String 的话，则有点得不偿失。由此可见，String.intern() 主要 <strong>适用于只有有限值，并且这些有限值会被重复利用的场景</strong>，如数据库表中的列名、人的姓氏、编码类型等。<br>此外，在比较字符串是否相等时，除了常见的equal()，还可以使用hashCode()，比较二者的该方法返回值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;String性质&quot;&gt;&lt;a href=&quot;#String性质&quot; class=&quot;headerlink&quot; title=&quot;String性质&quot;&gt;&lt;/a&gt;String性质&lt;/h2&gt;&lt;h3 id=&quot;不可变性&quot;&gt;&lt;a href=&quot;#不可变性&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="java" scheme="https://boneink.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java-加强型for循环与Iterator</title>
    <link href="https://boneink.github.io/2022/05/13/java-%E5%8A%A0%E5%BC%BA%E5%9E%8Bfor%E5%BE%AA%E7%8E%AF%E4%B8%8EIterator/"/>
    <id>https://boneink.github.io/2022/05/13/java-%E5%8A%A0%E5%BC%BA%E5%9E%8Bfor%E5%BE%AA%E7%8E%AF%E4%B8%8EIterator/</id>
    <published>2022-05-13T04:00:00.000Z</published>
    <updated>2022-05-13T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="加强型for循环与Iterator"><a href="#加强型for循环与Iterator" class="headerlink" title="加强型for循环与Iterator"></a>加强型for循环与Iterator</h2><ol><li><p>for-Each循环</p><p>数组中：</p><p>在数组中的 for-Each 最终会被编译器处理成一个普通的for循环，也就是说 for-Each循环是完全与普通for循环等价的，没有任何特殊的命令。</p><p>虽然for-Each 写起来方便，但也有以下几个局限性：</p><ul><li><p>只能对元素进行顺序的访问；</p></li><li><p>只能访问数组或集合中的所有元素；</p></li><li><p>循环中没有当前的索引，无法对指定的元素操作。如更换当前索引位置的元素。</p></li></ul><p>集合中：</p><p>直接采用普通for循环和get()方法进行list遍历。每次调用get()时都会对list进行一次遍历，因此比较消耗性能。</p><p>因此一般采用迭代器进行遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    <span class="comment">//获取集合的迭代器</span></span><br><span class="line">    Iterator&lt;String&gt; itor = list.iterator();</span><br><span class="line">    <span class="comment">//集合的普通for循环</span></span><br><span class="line">    <span class="keyword">for</span>(;itor.hasNext();)&#123;<span class="comment">//相当于 while(itor.hasNext())</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">item</span> <span class="operator">=</span> itor.next();</span><br><span class="line">        System.out.println(item);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对应的for-Each循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(String item:list)&#123;<span class="comment">//for-Each</span></span><br><span class="line">    System.out.println(item);</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p> 针对for-Each循环的处理：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>   &#123;  </span><br><span class="line">       <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();  </span><br><span class="line">       list.add(<span class="string">&quot;aa&quot;</span>);  </span><br><span class="line">       list.add(<span class="string">&quot;bb&quot;</span>);  </span><br><span class="line">       <span class="keyword">for</span>(String item:list)  </span><br><span class="line">       &#123;  </span><br><span class="line">           <span class="keyword">if</span>(<span class="string">&quot;bb&quot;</span>.equals(item))  </span><br><span class="line">               list.add(<span class="string">&quot;cc&quot;</span>);  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p> 其对应的反编译代码：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>   &#123;  </span><br><span class="line">       <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();  </span><br><span class="line">       list.add(<span class="string">&quot;aa&quot;</span>);  </span><br><span class="line">       list.add(<span class="string">&quot;bb&quot;</span>);  </span><br><span class="line">       <span class="keyword">for</span>(<span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator(); iterator.hasNext();)  </span><br><span class="line">       &#123;  </span><br><span class="line">           <span class="type">String</span> <span class="variable">item</span> <span class="operator">=</span> (String)iterator.next();  </span><br><span class="line">           <span class="keyword">if</span>(<span class="string">&quot;bb&quot;</span>.equals(item))  </span><br><span class="line">               list.add(<span class="string">&quot;cc&quot;</span>);  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br> <strong>与数组类似，编译器最终也就是将集合中的for-Each循环处理成集合的普通for循环</strong>。<br> 集合循环遍历时所使用的迭代器Iterator有一个要求：<strong>在迭代的过程中，除了使用迭代器（如:<code>Iterator.remove()</code>方法）对集合增删元素外，是不允许直接对集合进行增删操作。</strong> 否则将会抛出 ConcurrentModificationException异常。所以， <strong>由于集合的for-Each循环本质上使用的还是Iterator来迭代，因此也要注意这个陷阱</strong>  。<br> 集合中的for-Each循环的局限性与数组的for-Each循环是一样的。集合的for-Each循环是不能对集合进行增删操作、也不能获取索引。而集合的普通for循环可以使用的迭代器提供了对集合的增删方法（如：<code>Iterator.remove</code>，<code>ListIterator.add()</code>），获取索引的方法（如：<code>ListIterator.nextIndex()</code>、<code>ListIterator.previousIndex()</code>）。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;加强型for循环与Iterator&quot;&gt;&lt;a href=&quot;#加强型for循环与Iterator&quot; class=&quot;headerlink&quot; title=&quot;加强型for循环与Iterator&quot;&gt;&lt;/a&gt;加强型for循环与Iterator&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;f</summary>
      
    
    
    
    
    <category term="java" scheme="https://boneink.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java-自增自减与贪心规则</title>
    <link href="https://boneink.github.io/2022/05/12/java-%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E4%B8%8E%E8%B4%AA%E5%BF%83%E8%A7%84%E5%88%99/"/>
    <id>https://boneink.github.io/2022/05/12/java-%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E4%B8%8E%E8%B4%AA%E5%BF%83%E8%A7%84%E5%88%99/</id>
    <published>2022-05-12T04:00:00.000Z</published>
    <updated>2022-05-12T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="自增自减与贪心规则"><a href="#自增自减与贪心规则" class="headerlink" title="自增自减与贪心规则"></a>自增自减与贪心规则</h3><ol><li>自增自减是包含两个两个操作，不是线程安全的</li></ol><p>   自增自减运算符包含两个操作：<strong>一个加1（减1）的操作和一个赋值的操作</strong></p><p>   <strong>自增自减不是原子性操作，也就是说不是线程安全的运算。</strong> 因此，在多线程下，如果你要对共享变量实现自增自减操作，就要加锁，或者使用JDK提供的原子操作类（如<code>AtomincInteger</code>，<code>AtomicLong</code>等）提供的原子性自增自减方。</p><p>   来看个例子，验证一下。下面的例子提供三个静态变量（一个是原子操作类），创建了10个线程，每个线程都对这三个变量以不同的方式进行加1操作,并循环1000次。</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;    </span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;    </span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">//原子性操作类    </span></span><br><span class="line"><span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;<span class="comment">//创建10个线程            </span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;                </span><br><span class="line">            <span class="meta">@Override</span>                </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;                    </span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;<span class="comment">//计算1000次</span></span><br><span class="line">                        a = a + <span class="number">1</span>;</span><br><span class="line">                        b++;</span><br><span class="line">                        atomicInt.incrementAndGet();<span class="comment">//自增的原子性方法</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;        <span class="comment">// 判断当前的活动线程是不是只有main线程，以确保10个计算线程执行完成。</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;a=a+1在多线程下的结果是：&quot;</span> + a);</span><br><span class="line">        System.out.println(<span class="string">&quot;b++在多线程下的结果是：&quot;</span> + b);</span><br><span class="line">        System.out.println(<span class="string">&quot;原子操作类AtomicInteger在多线程下的结果是：&quot;</span> + atomicInt.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   运行结果：</p><blockquote><p>a&#x3D;a+1在多线程下的结果是：8883<br>b++在多线程下的结果是：8974<br>原子操作类AtomicInteger在多线程下的结果是：10000</p></blockquote><p>     从运行的结果可以看出，<code>a=a+1、b++</code>不是线程安全的，没有计算出正确的结果10000。也就是说这两个表达式都不是原子性操作。事实上，它们都包含了两个计算操作。</p><ol start="2"><li><p>编译器的贪心规则：</p><ul><li><p>Java中的运算是从左往右进行的；</p></li><li><p>java编译器有一种规则——贪心规则。<strong>也就是说，编译器会尽可能多地结合有效的符号。</strong></p></li></ul><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;    </span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">5</span>;    </span><br><span class="line"><span class="type">int</span> c=a+++b;    </span><br><span class="line">System.out.println(<span class="string">&quot;a的值是: &quot;</span>+a);    </span><br><span class="line">System.out.println(<span class="string">&quot;b的值是: &quot;</span>+b);</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>a的值是: 6<br>b的值是: 5</p></blockquote><p>从结果可以确认，<code>a+++b</code> 其实是解析成了 <code>a++ +b</code></p><p>贪心规则的主要目的就是为了分析String字符串，看看下面的例子就会明白：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;\17&quot;</span>;    </span><br><span class="line">System.out.println(<span class="string">&quot;\\17 转义字符的值是：&quot;</span>+s+<span class="string">&quot;  长度是：&quot;</span>+s.length());    </span><br><span class="line">s = <span class="string">&quot;\171&quot;</span>;    </span><br><span class="line">System.out.println(<span class="string">&quot;\\171 转义字符的值是：&quot;</span>+s+<span class="string">&quot;  长度是：&quot;</span>+s.length());    </span><br><span class="line">s = <span class="string">&quot;\1717&quot;</span>;    </span><br><span class="line">System.out.println(<span class="string">&quot;\\1717 转义字符的值是：&quot;</span>+s+<span class="string">&quot;  长度是：&quot;</span>+s.length());    </span><br><span class="line">s = <span class="string">&quot;\17178&quot;</span>;    </span><br><span class="line">System.out.println(<span class="string">&quot;\\17178 转义字符的值是：&quot;</span>+s+<span class="string">&quot;  长度是：&quot;</span>+s.length());</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>\17 转义字符的值是：   长度是：1<br>\171 转义字符的值是：y   长度是：1<br>\1717 转义字符的值是：y7   长度是：2<br>\17178 转义字符的值是：y78   长度是：3</p></blockquote><p>“\17” 经转义得到一个特殊字符 “” 。而“\171” 转义后也得到一个字符 “y”。但 “\1717”、“\17178” 得到的字符串大于1，不再是一个字符，分别是 “y7”、“y78”。</p><p>也就是说,“\1717” 字符串只转义了“\171” 部分，再链接 “7” 部分。“\17178” 字符串只转义了 “\171” 部分,再连接 “78”。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;自增自减与贪心规则&quot;&gt;&lt;a href=&quot;#自增自减与贪心规则&quot; class=&quot;headerlink&quot; title=&quot;自增自减与贪心规则&quot;&gt;&lt;/a&gt;自增自减与贪心规则&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;自增自减是包含两个两个操作，不是线程安全的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;</summary>
      
    
    
    
    
    <category term="java" scheme="https://boneink.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java-基本数据类型</title>
    <link href="https://boneink.github.io/2022/05/11/java-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://boneink.github.io/2022/05/11/java-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2022-05-11T04:00:00.000Z</published>
    <updated>2022-05-11T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><ol><li><p>基本数据类型中，取值范围较大的是高级类型，低的是低级，低级向高级转换可以直接转换（隐式），反之则要显式强制转换,字面常量也可以隐式转换： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>;  <span class="comment">//8是字面常量</span></span><br><span class="line">    <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">9</span>;  <span class="comment">//9是字面常量</span></span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">9</span>+<span class="number">5</span>;<span class="comment">//常量表达式</span></span><br><span class="line">    <span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> (<span class="type">short</span>) (c+<span class="number">10</span>); <span class="comment">//变量表达式，需要显式强制转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>整形字面常量隐式转换的限制：</strong></p><ul><li>整形字面常量的大小超出目标类型所能表示的范围时，要手动强制类型转换。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte b = 128;//编译错误，128超出byte类型所能表示的范围byte c = (byte)128;//编译通过</span><br></pre></td></tr></table></figure><ul><li><p>对于传参数时，必须要显式地进行强制类型转换，明确转换的类型</p><ol start="2"><li><p><em><em>复合运算符（+&#x3D;、-&#x3D;、</em>&#x3D;、&#x2F;&#x3D;、%&#x3D;）是可以将右边表达式的类型自动强制转换成左边的类型</em>*</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>;      </span><br><span class="line">    <span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">5</span>;     </span><br><span class="line">    s += a;    </span><br><span class="line">    s += a+<span class="number">5</span>;   </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>  <code>s+=a、s+=a+5</code>;的表达式计算结果都是int类型，但都不需要手动强制转换。其实，如果是反编译这段代码的class文件，你会发现s+&#x3D;a;，其实是被编译器处理成了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s=(<span class="type">short</span>)(s+a)</span><br></pre></td></tr></table></figure><p><strong>也就是说对于所有的复合运算的隐式类型转换，其实是编译器自动添加类型转换的代码。</strong></p></li></ol></li></ul><ol start="3"><li><p>char类型在基本类中是一个比较特殊的存在。这种特殊性在于<strong>char类型是一个无符号类型，所以char类型与其他基本类型不是子集与父集间的关系（其他类型都是有符号的类型）。也就是说，char类型与byte、short之间的转换都需要显式的强制类型转换（小类型自动转换成大类型失败）。</strong></p><p>  同时，<strong>由于char类型是一个无符号类型，所以对于整形字面常量的隐式转换的限制，不仅包括字面常量数值的大小不能超出2个字节，还包括字面常量数值不能为负数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>; <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">2</span>;<span class="comment">//编译通过     </span></span><br><span class="line">c = <span class="number">100000000000</span>;<span class="comment">//编译不通过，超出char类型的范围 </span></span><br><span class="line"><span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> -<span class="number">2</span><span class="comment">//字面常量为负数，编译不通过      </span></span><br><span class="line">d = (<span class="type">char</span>)-<span class="number">100</span>;<span class="comment">//编译通过 char f = (char)b; //编译通过，必须显式的强制类型转换      </span></span><br><span class="line">f = b;<span class="comment">//编译不通过，不能隐式转换 </span></span><br><span class="line"><span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> c;<span class="comment">//编译通过，可以不需要强制类型转换 </span></span><br><span class="line"><span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> (<span class="type">short</span>) c;<span class="comment">//编译通过，必须显式地强制类型转换</span></span><br></pre></td></tr></table></figure><p>  char类型是无符号的类型，这种无符号也体现在在其转换成int类型时，也就是说，<strong>char类型在扩展时，也是按无符号的方式扩展，扩展位填0</strong>。我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> -<span class="number">5</span>;</span><br><span class="line">   <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>)s;     </span><br><span class="line">   System.out.println(c==s);  <span class="comment">//false    </span></span><br><span class="line">   System.out.println(<span class="string">&quot;(int)c = &quot;</span>+(<span class="type">int</span>)c); <span class="comment">//转换成int类型，值为65531    </span></span><br><span class="line">   System.out.println(<span class="string">&quot;(short)c = &quot;</span>+(<span class="type">short</span>)c); <span class="comment">//-5    </span></span><br><span class="line">   System.out.println(<span class="string">&quot;(int)s = &quot;</span>+(<span class="type">int</span>)s);<span class="comment">//-5</span></span><br></pre></td></tr></table></figure></li></ol><p>运行结果：</p><blockquote><p>false<br> (int)c &#x3D; 65531<br> (short)c &#x3D; -5<br> (int)s &#x3D; -5</p></blockquote><p>  <strong>从上面的结果发现，char类型的c 与 short类s其实存储字节码内容是一样的，但由于前者是无符号，所以扩展成int类型的结果是 65531，而不是 -5。运算符&#x3D;&#x3D;比较的就是他们扩展成int类型的值，所以为fasle。</strong></p><p><strong>对char类型的类型转换，可以总结成以下几点：</strong></p><ul><li><p>char类型与byte、short的相互转换，都需要显式地强类型制转换。</p></li><li><p>对于数值是负数的，都需要进行显式地强制类型转换，特别是在整形字面常量的隐式转换中。</p></li><li><p>char类型转换成int、long类型是符合 小类型转大类型的规则，即无需要强制类型转换。</p></li></ul><ol start="4"><li><p><strong>java的运算结果的类型有两个性质：</strong></p><ul><li><p>运算结果的类型必须是int类型或int类型以上。</p></li><li><p>最高类型低于int类型的，运算结果都为int类型。否则，运算结果与表达式中最高类型一致。</p></li></ul></li><li><p>浮点类型</p><p>浮点型所能表示的有效位是有限的，所以哪怕是整数，只要超出有效位数，也只能存储相似值，也就是该数值的最低有效位将会丢失,从而造精度丢失。<br><strong>float类型的二进制有效位是24位，对应十进制的7 ~ 8位数字；double类型的二进制53位，对应十进制的10 ~ 11位数字。</strong></p><p>double、float类型 所能表示的范围比int、long类型表示的范围要广，也浮点类型属于大类型。但是，并不能完美地表整形，浮点类型的精度丢失会造成一些问题。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    </span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3000000</span>;    </span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">30000000</span>;    </span><br><span class="line"><span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> a;    </span><br><span class="line"><span class="type">float</span> <span class="variable">f2</span> <span class="operator">=</span> b;    </span><br><span class="line">System.out.println(<span class="string">&quot;3000000==3000001 &quot;</span>+(f1==f1+<span class="number">1</span>));    </span><br><span class="line">System.out.println(<span class="string">&quot;30000000==30000001 &quot;</span>+(f2==f2+<span class="number">1</span>));    </span><br><span class="line">System.out.println(<span class="string">&quot;3000000的有效二进制位数：&quot;</span>+ Integer.toBinaryString(a).length());    </span><br><span class="line">System.out.println(<span class="string">&quot;30000000的有效二进制位数：&quot;</span>+ Integer.toBinaryString(b).length());&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>3000000 &#x3D;&#x3D; 3000001  false<br>30000000 &#x3D;&#x3D; 30000001  true<br>3000000的有效二进制位数： 22<br>30000000的有效二进制位数： 25</p></blockquote><p>上面的例子很好体现了精度丢失所带来的后果：<code>30000000==30000001</code> 的比较居然为true了。而造成这种结果的原因就是 30000000的有效二进制位数是25位，超出了float所能表示的有效位24位，最后一位就被舍去，所以就造成在刚加的1也被舍去，因此30000000的加一操作前后的浮点型表示是一样的。</p><p>当然，<strong>并不是超出浮点型的有效位就不能精确表示，其实，主要看的是最高有效位与最低非0有效位之间的 “间隙”，如果间隙的在浮点型的有效位数内，自然可以精确表示，因为舍去的低有效位都是0，自然就无所谓了。</strong>如果上面的例子的浮点型用的是double就不会丢失精度了，因为double的精度是52位。</p><p><strong>解决浮点型精度丢失的问题</strong>：JDK为此提供了两个高精度的大数操作类给我们：BigInteger、BigDecimal。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本数据类型&quot;&gt;&lt;a href=&quot;#基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;基本数据类型&quot;&gt;&lt;/a&gt;基本数据类型&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;基本数据类型中，取值范围较大的是高级类型，低的是低级，低级向高级转换可以直接转换（隐式），</summary>
      
    
    
    
    
    <category term="java" scheme="https://boneink.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>挖矿木马总结</title>
    <link href="https://boneink.github.io/2022/03/01/%E6%8C%96%E7%9F%BF%E6%9C%A8%E9%A9%AC%E6%80%BB%E7%BB%93/"/>
    <id>https://boneink.github.io/2022/03/01/%E6%8C%96%E7%9F%BF%E6%9C%A8%E9%A9%AC%E6%80%BB%E7%BB%93/</id>
    <published>2022-03-01T04:00:00.000Z</published>
    <updated>2022-03-01T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="挖矿木马总结"><a href="#挖矿木马总结" class="headerlink" title="挖矿木马总结"></a>挖矿木马总结</h1><h3 id="腾讯《2020年挖矿木马年度报告》"><a href="#腾讯《2020年挖矿木马年度报告》" class="headerlink" title="腾讯《2020年挖矿木马年度报告》"></a>腾讯《2020年挖矿木马年度报告》</h3><p>2020 年各类数字加密货币价格迎来暴涨，比特币价格一度超过 5 万美元 &#x2F; BTC，市值达到 9200 亿美 元，是 2019 年底的 10 倍之多，达到了历史最高点。同期挖矿木马最偏好的门罗币价格也同步增长 6 倍，这意味着黑客通过进行门罗币挖矿，兑现后收益可达到以往收益的 6 倍。在如此大利益诱惑之下， 黑产团伙已闻风而动，纷纷加入了对主机计算资源的争夺，一个典型现象就是，有大量挖矿木马在运行 时，会尝试清除竞争对手木马。</p><h4 id="挖矿家族Top"><a href="#挖矿家族Top" class="headerlink" title="挖矿家族Top"></a>挖矿家族Top</h4><p>2020 年度挖矿木马家族排名前三的分别为 DTLMiner（永恒之蓝下载器木马）、H2Miner、 GuardMiner，榜单中有通过永恒之蓝漏洞传播的为 DTLMiner、NSABuffMiner、 NSAGluptebaMiner，有利用 Redis、Hadoop、Weblogic、Drupal、thinkphp 等应用程序漏洞传播的 为 H2Miner、GuardMiner、z0Miner、8220Miner 等家族，以及主要通过弱口令爆破进行传播的为 KoiMiner 家族。</p><p><img src="https://wx2.sinaimg.cn/large/69b019d1gy1gnzmju6hq1j20fc0btdg1.jpg"></p><h4 id="入侵通道"><a href="#入侵通道" class="headerlink" title="入侵通道"></a>入侵通道</h4><ol><li><p>利用漏洞</p><p>远程代码执行漏洞（RCE）可以让远程攻击者直接向后台服务器远程注入操作系统命令或者恶意代码，从而控制后台系统，挖矿木马攻击时最常用的远程代码执行漏洞 TOP 统计如下：</p></li></ol><p><img src="https://wx4.sinaimg.cn/large/69b019d1gy1gnzmm3b76sj20fe09v0ue.jpg"></p><p><img src="https://wx4.sinaimg.cn/large/69b019d1gy1gnzmmn5o43j20fo0an3z2.jpg"></p><ol start="2"><li><p>爆破攻击</p><p>用户在设置系统登陆密码时，为了方便记忆往往采用默认的空口令或者非常简单的密码例如 admin、root、test、111111、123456 等，使用这些密码导致黑客可以轻易猜解并登陆，从而入侵系统。</p><p>许多挖矿木马在传播时也会针对系统的弱密码进行爆破攻击，根据腾讯安全 2020 年云上安全报告提供的数据，默认用户名、端口名被爆破攻击的次数达数十亿次之多。常被挖矿木马爆破攻击的服务类型包括 SSH、Mssql、Redis 等，各类型爆破攻击对应的挖矿家族如下：</p><p>MS SQL</p><p>永恒之蓝下载器木马、GuardMiner 、MrbMiner、BasedMiner、贪吃蛇挖矿木马、快 GO 旷工</p><p>SSH 爆破</p><p>永恒之蓝下载器木马、Ks3_Miner、LoggerMiner、8220Miner、DDG</p><p>Redis 爆破</p><p>永恒之蓝下载器木马、H2Miner、GuardMiner、DDG</p><p>Msql 爆破</p><p>Mykings</p></li><li><p>僵尸网络渠道</p><p>具有僵尸网络特征的挖矿木马 TOP 榜如下，其中前三位是 DTLMiner（永恒之蓝下载器木马）、H2Miner、GuardMiner 为老牌僵尸网络，由于控制该僵尸网络的幕后黑客团伙仍在不断更新其攻击方法，使其在出现后的数年里仍然保持很高的活跃度。</p><p>在 2020 年新活跃的挖矿木马家族以 Linux 服务器为攻击对象的居多，例如通过 SSH 弱口令攻击的 Outlaw、Prometei，通过 Docker Remote API 漏洞入侵的 TeamTNT，以及通过 Nexus Repository Manager 3 弱密码入侵，利用 Mysql、Tomcat 弱口令爆破，Weblogic 远程代码执行漏洞进行横向扩散的 Sysrv-hello 家族等等。</p><p><img src="https://wx2.sinaimg.cn/large/69b019d1gy1gnzmnlovikj20fu0btt90.jpg"></p></li><li><p>入侵后开展恶意行为</p><p>4.1 通过linux定时任务</p><p>4.2 通过linux系统服务：启动项&#x2F;安装服务</p><p>4.3 Windows WMI</p></li></ol><h4 id="挖矿类型："><a href="#挖矿类型：" class="headerlink" title="挖矿类型："></a>挖矿类型：</h4><p><strong>基于浏览器的挖矿</strong></p><p>基于浏览器的挖矿劫持的实际攻击对象是网站的服务器。受害者经常是僵尸网络的一部分，因为单个受害者还无法完成工作量证明，一般是多个受害者一起完成一个特定任务。恶意JS脚本（大多数攻击者会直接使用修改的coinhive脚本）一般会被注入网页的广告或者自加载资源，以便用户访问网页时可以自动执行。</p><p>由于受害的是用户，而被攻击的服务器本身没有受到什么损害，所以该攻击难以被网站管理员发现。</p><p>正常的coinhive使用时，会事先询问用户是否允许进行挖矿，用户同意后，赚取的收益的30%由coinhive获得，余下的由网站获得。而攻击者修改后的coinhive脚本运行时，获得的收益全由攻击者获得。</p><p><strong>基于恶意软件的挖矿：</strong></p><p>感染计算机，安装加密矿工（样本），并使用从受害者电脑窃取得来的信息来建立用于非法资金转移的钱包。无需像勒索软件那样对目标进行勒索获取赎金，而是直接从良性互联网用户那里获得加密货币。</p><p>偷渡式挖矿，在受害者系统上只停留很短的时间，然后进入下一个受害者，接着会再次回来并重复这一过程。这种短时间的可用性使其很难被检测到。</p><p>偷渡式下载是一种常见的攻击方法，当用户访问一个嵌入恶意代码的网站时，它会滥用浏览器的合法功能开始自动文件下载或提示下载诱骗用户运行恶意程序。基于恶意软件的挖矿劫持一般会采用这种形式。</p><h3 id="常见的加密货币："><a href="#常见的加密货币：" class="headerlink" title="常见的加密货币："></a>常见的加密货币：</h3><p><strong>比特币</strong>：</p><ol><li>生成coinbase交易，并与其他所有准备打包进区块的交易组成交易列表，通过Merkle树算法生成Merkle根哈希；</li><li>把Merkle根哈希及其他相关字段组装成区块头，将区块头的80字节数据作为工作量证明的输入；</li><li>不停地变更区块头中的随机数，即nonce的数值，并对每次变更后的区块头做双重SHA256运算，将结果值与当前网络的目标值做对比，如果小于目标值则解题成功，工作量证明完成。</li></ol><p><strong>以太坊</strong></p><p>Ethash是以太坊1.0中使用的PoW(工作量证明)算法,它是Hashimoto算法结合Dagger之后产生的一个变种。它的特点是计算的效率基本与CPU无关，却和内存大小和内存带宽正相关。因此通过共享内存的方式大规模部署的矿机芯片并不能在挖矿效率上有线性或者超线性的增长。</p><p>该算法的一般流程如下：</p><p>首先根据块信息计算一个种子(seed, c++代码中为seedhash)<br>使用这个种子，计算出一个16MB的cache数据。轻客户端需要存储这份cache.<br>通过cache，计算出一个1GB(初始大小)的数据集(DAG)，DAG可以理解为是一个完整的搜索空间，全客户端和矿工需要存储完整的DAG，挖矿过程中需要从DAG中重复的随机抽取数据拿去和其他数据计算mixhash，DAG中每个元素的生成只依赖于cache中的少量数据。每到一个新的纪元DAG会完全不一样，并且它的大小也随时间线性增长。<br>由于仅根据cache就可以使用少量内存快速的计算出DAG中指定位置的数据，所以轻客户端只需要存储cache就可以高效的进行校验。</p><p><strong>门罗币</strong></p><p>Monero门罗币XMR计划于2019年的10月份启用最新的RandomX 算法以取代原来的CryptoNight挖矿算法，以继续优化抗ASIC+降低GPU优势来保持门罗POW网络的分散性</p><p>RandomX的行为类似于键控散列函数：它接受一个键。任意输入并产生256位的结果。在底层，RandomX使用虚拟机在一个特殊的指令集中执行程序，该指令集由整数运算、浮点运算和分支组成。这些程序可以动态转换为CPU的本机代码。将RandomX程序转换为x86-64程序集的示例是program.asm…还提供了一种便携式解释模式。</p><p>RandomX可以在具有不同内存需求的两种主要模式下工作：<br>Fast模式-需要2080 MIB共享内存。（该算法要求挖矿者为进程提供超过2G的 RAM，这可能会使加密攻击更难隐藏。）<br>Light模式-只需要256 MIB共享内存，但运行速度要慢得多</p><p><strong>狗狗币</strong></p><p>scrpyt算法是由著名的FreeBSD黑客 Colin Percival为他的备份服务 Tarsnap开发的，当初的设计是为了降低CPU负荷，尽量少的依赖cpu计算，利用CPU闲置时间进行计算，因此scrypt不仅计算所需时间长，而且占用的内存也多，使得并行计算多个摘要异常困难，因此利用rainbow table进行暴力攻击更加困难。scrypt没有在生产环境中大规模应用，并且缺乏仔细的审察和广泛的函数库支持。所以scrpyt一直没有推广开，但是由于其内存依赖的设计特别符合当时对抗专业矿机的设计，成为数字货币算法发展的一个主要应用方向。</p><p>后来有人在SCRYPT的基础上稍作修改形成Scrypt –N算法，改进思路都一样，都是追求更大的内存消耗和计算时间，以有效阻止ASIC专用矿机。</p><p>Scrypt是内存依赖型的POW算法，莱特币采用此算法。第一个使用Scrypt算法的数字货币是Tenebrix，而后该算法被莱特币使用。莱特币创始人在莱特币创世帖中介绍了莱特币采用的共识机制，挖矿算法，发行总量，挖矿难度等相关重要信息。李启威说明了莱特币所使用的挖矿算法为数字货币Tenebrix所使用的Scrypt算法，是一种符合PoW共识机制的算法。Scrypt算法过程中也需要计算哈希值，但是，Scrypt计算过程中需要使用较多的内存资源。</p><p>其它使用Scrypt算法的数字货币还有数码币（DigitalCoin）、狗狗币（DogeCoin）、幸运币（LuckyCoin）、世界币（WorldCoin）等。</p><p><strong>莱特币</strong></p><p>Scrypt算法</p><h3 id="近年来恶意挖矿软件总结："><a href="#近年来恶意挖矿软件总结：" class="headerlink" title="近年来恶意挖矿软件总结："></a>近年来恶意挖矿软件总结：</h3><table><thead><tr><th>文献名</th><th>时间</th><th>期刊&#x2F;会议</th><th>等级</th><th>作者</th><th>学校&#x2F;单位</th><th>贡献</th><th>检测类型</th><th>检测方法</th><th>不足&#x2F;总结</th></tr></thead><tbody><tr><td>Cryptocurrency malware hunting: A deep Recurrent Neural Network  approach</td><td>2020</td><td>Applied  Soft Computing (ASC)</td><td>SCI  Q1</td><td>Abbas  Yazdinejad, Hamed HaddadPajouh, Ali Dehghantanha, Reza M. Parizi, Gautam  Srivastava, Mu-Yen Chen,</td><td>Cyber  Science Lab, School of Computer Science, University of Guelph, Ontario,  Canada</td><td>1.  一个用于检测MS Windows平台上加密货币恶意软件威胁的三层深度循环神经网络(RNN)模型。     2. 一个包含500个真实世界的加密货币恶意软件应用程序和200多个合法加密货币应用程序的数据集。     3. 对传统ml算法和提出的模型进行对比分析，以展示rnnon检测加密货币恶意软件威胁的有效性。</td><td>二进制文件检测</td><td>反编译提取操作码，对每个样本的操作码创建一个特征向量，利用矢量化的数据对深度神经网络模型进行训练。</td><td>拓展：增加字节码、头文件和系统调用等特征，从而降低假阳性率</td></tr><tr><td>An Application Agnostic Defense Against the Dark Arts of  Cryptojacking</td><td>2021</td><td>2021  51st Annual IEEE&#x2F;IFIP International Conference on Dependable Systems and  Networks (DSN)</td><td>CCF  B</td><td>N.  Lachtar, A. A. Elkhail, A. Bacha and H. Malik</td><td></td><td>1.  提出一种应用无关的设计，利用微架构和操作系统层的创新防御加密劫持攻击     2. 演示了通常出现在加密函数中的监控指令     3. 户应用程序的各种指令类型与加密劫持检测的高准确性的相关性     4. 提出一种针对代码混淆、多线程和限制型攻击的健壮设计，同时保留较低误报率。</td><td>二进制文件检测</td><td>分析和统计哈希操作相关的操作码，通过机器学习进行分类操作</td><td></td></tr><tr><td>MineSweeper An In-depth Look into Drive-by Cryptocurrency Mining  and Its Defense</td><td>2018</td><td>Proceedings  of the 2018 ACM SIGSAC Conference on Computer and Communications Security</td><td>CCF  A</td><td>Radhesh  Krishnan Konoth, Emanuele Vineti, Veelasha Moonsamy, Martina Lindorfer,  Christopher Kruegel, Herbert Bos, and Giovanni Vigna</td><td>New  York, NY, USA,</td><td>1.  对偷渡式采矿进行了首次深入评估。       - 互联网上的偷渡式挖矿行为的普遍程度。       - 目前存在多少种偷渡式挖矿服务。       - 偷渡式挖矿采用的规避策略。       - 不同类型的偷渡式挖矿采用的方法。       - 不同类型的偷渡式挖矿的利润。       - 在不同的偷渡式挖矿服务中找到共同特征用于检测。     2. 讨论了为何当前基于黑名单和CPU使用的防御是无效的。     3. 提出了MINESWEEPER这一新的检测方法，通过静态分析识别密码函数，并在运行时监控缓存事件。</td><td>浏览器脚本检测</td><td>1.  匹配原语中的加密计数，计算相似度评分     2. 对于新变体和其他散列算法，计算每个函数循环中加密操作码的计数，对比阈值     3. 对于高度模糊的Wasm模块，检测CPU负载</td><td>1.  爬虫仍需优化。     2. 针对其他设备（如Android手机）的活动研究。     3. 基于静态分析的方法仍容易混淆（但考虑到利润，攻击者会得不偿失）     4. 目前仅针对Wasm的挖矿代码，未来可以考虑分析asm.js。     5. Wasm的加密函数可能会用在其他地方，可能会出现假阳性（但目前wasm还没有被其他用例广泛使用）</td></tr><tr><td>MINOS: A Lightweight Real-Time Cryptojacking Detection System</td><td>2021</td><td>Network  and Distributed Systems Security (NDSS) Symposium 2021</td><td>CCF  B</td><td>Arış,  Ahmet &amp; Naseem, Faraz &amp; Babun, Leonardo &amp; Tekiner, Ege &amp;  Uluagac, Selcuk.</td><td></td><td>1.  提出一种新的加密劫持行为检测机制，在轻量级和端到端框架中实现Wasm二进制分类器：MINOS     2. 提出一种新的Wasm二分类计数，利用二值的灰度图像表示来训练卷积神经网络。     3. MINOS以最小的开销，在真实场景的数据集上以98.97%的准确率检测基于wasm的加密劫持。</td><td>浏览器脚本检测</td><td>收集网站产生的Wasm文件，转换成为灰度图像并导入CNN中进行分类</td><td>未对混淆的分类结果进行阐述</td></tr><tr><td>Cryptomining makes noise Detecting cryptojacking via Machine  Learning</td><td>2021</td><td>Computer  Communications</td><td>CCF  C     SCI Q2</td><td>Maurantonio  Caprolua,Simone Raponia     , Gabriele Oligeria     and Roberto Di Pietroa</td><td></td><td>1.  定义了包含加密劫持攻击的海绵攻击:未经基础设施所有者授权,利用第三方软硬件资源获取个人利益的恶意行为。     2. 详细分析了三种主要加密货币:Bitcoin、Monero和Bytecoin产生的真实网络流量。     3. 分析了两大VPN品牌:NordVPN和ExpressVPN的VPN隧道如何处理由Crypto-clients产生的网络流量。     4. 提出一个基于机器学习的框架:Crypto-Aegis,用于检测几种不同形式的crypto-mining,如单独挖矿和池采矿。     5. 与其他文献中的方案进行了对比,第一个利用机器学习技术通过分析网络流量来检测加密客户端</td><td>流量检测</td><td>分析进站出站流量包大小和达到时间间隔</td><td>1.  本文的错误分类情况大多出现在加密货币之间的错误分类     2. 本文所选正常软件的样本类型偏少     3. 可以考虑综合出站入栈流量</td></tr><tr><td>MineHunter: A Practical Cryptomining Traffic Detection Algorithm  Based on Time Series Tracking</td><td>2021</td><td>Annual  Computer Security Applications Conference (ACSAC)</td><td>CCF  B</td><td>Shize  Zhang, Zhiliang Wang, Jiahai Yang, Xin Cheng, XiaoQian Ma, Hui Zhang, Bo  Wang, Zimu Li, and Jianping Wu</td><td>Association  for Computing Machinery, New York, NY, USA</td><td>1.  分析了加密挖矿的网络流量特征，将加密挖矿的流序列与加密货币的块创建序列相关联     2. 提出一种时间序列跟踪的加密挖掘流量监测算法     3. 在校园网环境中进行了大规模评价实验，效果很好。</td><td>流量监测</td><td>按照加密挖矿的周期和时间间隔对流量进行分类</td><td>未能解决对挖矿软件进行流量分析时，样本的比例悬殊较大引起的高误报率问题</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;挖矿木马总结&quot;&gt;&lt;a href=&quot;#挖矿木马总结&quot; class=&quot;headerlink&quot; title=&quot;挖矿木马总结&quot;&gt;&lt;/a&gt;挖矿木马总结&lt;/h1&gt;&lt;h3 id=&quot;腾讯《2020年挖矿木马年度报告》&quot;&gt;&lt;a href=&quot;#腾讯《2020年挖矿木马年度报告》&quot; c</summary>
      
    
    
    
    
    <category term="恶意软件检测" scheme="https://boneink.github.io/tags/%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8B/"/>
    
    <category term="入侵检测" scheme="https://boneink.github.io/tags/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/"/>
    
    <category term="木马检测" scheme="https://boneink.github.io/tags/%E6%9C%A8%E9%A9%AC%E6%A3%80%E6%B5%8B/"/>
    
    <category term="网络安全" scheme="https://boneink.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>一元多项式的乘法与加法运算</title>
    <link href="https://boneink.github.io/2021/02/15/%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E4%B9%98%E6%B3%95%E4%B8%8E%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97/"/>
    <id>https://boneink.github.io/2021/02/15/%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E4%B9%98%E6%B3%95%E4%B8%8E%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97/</id>
    <published>2021-02-15T04:00:00.000Z</published>
    <updated>2021-02-15T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一元多项式的乘法与加法运算"><a href="#一元多项式的乘法与加法运算" class="headerlink" title="一元多项式的乘法与加法运算"></a>一元多项式的乘法与加法运算</h2><p> 来自PTA平台的一道算法题：</p><p>设计函数分别求两个一元多项式的乘积与和。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出<code>0 0</code>。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 3 4 -5 2  6 1  -2 0</span><br><span class="line">3 5 20  -7 4  3 1</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">15 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 1</span><br><span class="line">5 20 -4 4 -5 2 9 1 -2 0</span><br></pre></td></tr></table></figure><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>个人倾向于使用java来解题，毕竟不用涉及指针之类的。</p><p>开始想的是采用HashMap进行键值对映射，将指数作为key值，系数作为对应的value，相对来说很容易实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        Map&lt;Integer, Integer&gt; item1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n1; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">y1</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            item1.put(y1, x1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        Map&lt;Integer, Integer&gt; item2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n2; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x2</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">y2</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            item2.put(y2, x2);</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; resMul = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry1 : item1.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry2 : item2.entrySet()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">reKeyMul</span> <span class="operator">=</span> entry1.getKey() + entry2.getKey();</span><br><span class="line">                <span class="type">int</span> <span class="variable">reValueMul</span> <span class="operator">=</span> entry1.getValue() * entry2.getValue();</span><br><span class="line">                <span class="keyword">if</span> (reValueMul != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (resMul.get(reKeyMul) != <span class="literal">null</span>) &#123;</span><br><span class="line">                        reValueMul += resMul.get(reKeyMul);</span><br><span class="line">                    &#125;</span><br><span class="line">                    resMul.put(reKeyMul, reValueMul);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; resAdd = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        temp.putAll(item2);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : item1.entrySet()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="comment">//resAdd.put(key, entry.getValue());</span></span><br><span class="line">            <span class="type">int</span> reAdd;</span><br><span class="line">            <span class="keyword">if</span> (temp.get(key) != <span class="literal">null</span>) &#123;</span><br><span class="line">                reAdd = entry.getValue() + temp.get(key);</span><br><span class="line">                temp.remove(key);</span><br><span class="line">            &#125; <span class="keyword">else</span> reAdd = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (reAdd != <span class="number">0</span>)</span><br><span class="line">                resAdd.put(key, reAdd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : temp.entrySet()) &#123;</span><br><span class="line">            resAdd.put(entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resMul.size() == <span class="number">0</span>) System.out.println(<span class="string">&quot;0 0&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            resMul.entrySet().stream().sorted((e1, e2) -&gt; e2.getKey().compareTo(e1.getKey())).forEach(e -&gt; System.out.print(e.getValue() + <span class="string">&quot; &quot;</span> + e.getKey() + <span class="string">&quot; &quot;</span>));</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resAdd.size() == <span class="number">0</span>) System.out.println(<span class="string">&quot;0 0&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            resAdd.entrySet().stream().sorted((e1, e2) -&gt; e2.getKey().compareTo(e1.getKey()));</span><br><span class="line">           Iterator&lt;Map.Entry&lt;Integer,Integer&gt;&gt; iterator=resAdd.entrySet().iterator();</span><br><span class="line">           Map.Entry&lt;Integer,Integer&gt; entry=iterator.next();</span><br><span class="line">           System.out.print(entry.getValue()+<span class="string">&quot; &quot;</span>+entry.getKey());</span><br><span class="line">           <span class="comment">//for( key:resAdd.keySet())</span></span><br><span class="line"><span class="comment">//            //Iterator&lt;Map.Entry&lt;Integer,Integer&gt;&gt; iterator=resAdd.keySet().iterator();</span></span><br><span class="line"><span class="comment">//            Map.Entry&lt;Integer,Integer&gt; key=iterator.next();</span></span><br><span class="line"><span class="comment">//            System.out.print(key.get);</span></span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                entry=iterator.next();</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>+entry.getValue()+<span class="string">&quot; &quot;</span>+entry.getKey());</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在自己的计算机上运行sample没有问题，遂丢到平台查看效果。果然不出所料，结果全部超时，这就意味着要采取更加基础和效率的方式进行。</p><p>采取数组方式记录结果，通过角标表示指数，已知指数绝对值大小不超过1000，即用指数+1000作为角标即可，对应的位置存储系数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Item</span><span class="params">(<span class="type">int</span> y, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.y = y;</span><br><span class="line">            <span class="built_in">this</span>.x = x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getY</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setY</span><span class="params">(<span class="type">int</span> y)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.y = y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getX</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setX</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        <span class="comment">//Map&lt;Integer, Integer&gt; item1 = new HashMap&lt;&gt;();</span></span><br><span class="line">        Item[] items1 = <span class="keyword">new</span> <span class="title class_">Item</span>[n1];</span><br><span class="line">        <span class="type">int</span>[] resSum=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2005</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n1; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">y1</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            items1[i]=<span class="keyword">new</span> <span class="title class_">Item</span>(y1,x1);</span><br><span class="line">            resSum[y1+<span class="number">1000</span>]+=x1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        Item[] items2 = <span class="keyword">new</span> <span class="title class_">Item</span>[n2];</span><br><span class="line">       <span class="comment">// Map&lt;Integer, Integer&gt; items2 = new HashMap&lt;&gt;();</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n2; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x2</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">y2</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            items2[i]=<span class="keyword">new</span> <span class="title class_">Item</span>(y2,x2);</span><br><span class="line">            resSum[y2+<span class="number">1000</span>]+=x2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] resMul=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4010</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n1;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n2;j++)&#123;</span><br><span class="line">                resMul[items1[i].getY()+items2[j].getY()+<span class="number">1000</span>]+=items1[i].getX()*items2[j].getX();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">4009</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(resMul[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag!=<span class="number">0</span>)</span><br><span class="line">                    System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(resMul[i]+<span class="string">&quot; &quot;</span>+(i-<span class="number">1000</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">0</span>)System.out.print(<span class="string">&quot;0 0&quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2004</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(resSum[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag!=<span class="number">0</span>)</span><br><span class="line">                    System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(resSum[i]+<span class="string">&quot; &quot;</span>+(i-<span class="number">1000</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">0</span>)System.out.print(<span class="string">&quot;0 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一元多项式的乘法与加法运算&quot;&gt;&lt;a href=&quot;#一元多项式的乘法与加法运算&quot; class=&quot;headerlink&quot; title=&quot;一元多项式的乘法与加法运算&quot;&gt;&lt;/a&gt;一元多项式的乘法与加法运算&lt;/h2&gt;&lt;p&gt; 来自PTA平台的一道算法题：&lt;/p&gt;
&lt;p&gt;设计函</summary>
      
    
    
    
    
    <category term="Java" scheme="https://boneink.github.io/tags/Java/"/>
    
    <category term="算法练习" scheme="https://boneink.github.io/tags/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"/>
    
    <category term="PTA" scheme="https://boneink.github.io/tags/PTA/"/>
    
  </entry>
  
  <entry>
    <title>从“马宝国”看泛娱乐化</title>
    <link href="https://boneink.github.io/2020/12/01/%E6%97%A5%E8%AE%B0-%E4%BB%8E%E2%80%9C%E9%A9%AC%E5%AE%9D%E5%9B%BD%E2%80%9D%E7%9C%8B%E6%B3%9B%E5%A8%B1%E4%B9%90%E5%8C%96/"/>
    <id>https://boneink.github.io/2020/12/01/%E6%97%A5%E8%AE%B0-%E4%BB%8E%E2%80%9C%E9%A9%AC%E5%AE%9D%E5%9B%BD%E2%80%9D%E7%9C%8B%E6%B3%9B%E5%A8%B1%E4%B9%90%E5%8C%96/</id>
    <published>2020-11-30T21:50:00.000Z</published>
    <updated>2020-11-30T21:50:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深夜小记"><a href="#深夜小记" class="headerlink" title="深夜小记"></a>深夜小记</h2><hr><p>“马宝国”其人其事，在网上流传已成烂梗，原以为只是老骗子一个，除去几句翻来覆去的“名人语录”，便也无他罢了。前几日竟见有媒体专访，乃至导演邀约，评论区亦有“路人”为之开脱，可说是魔幻一般的现实。<br>于是乎便有了“《人民日报》揭批马保国闹剧”一回，看来上头是要警惕泛娱乐化这一趋势。而除去《人民日报》“二流报纸”本质，单就马保国其人，本质上骗子一枚，烂梗一个，并无可取之处。<br>大家玩一玩梗，笑一笑他，这叫适度。<br>可有人因此将玩梗的心情移情到其人本身，说些“他还是个七八十的老爷爷，能这样很不容易了”，“他至少给我带来了欢乐”，“他也就只是个骗子”之类的话，这叫自作多情。<br>他现在七八十，可以想象行骗了多久，又有多少人受骗。为老而不尊，实为老贼。<br>而给我们带来欢乐的，是那些辛苦的视频制作者，而不是他。以此为其脱罪，“窃他人之果”，实为匪盗。<br>如果没有这些恶搞视频，那我们又会如何看待此人，这是一个有趣的事情。我们现在因为一个无意间的恶搞，想要轻易原谅一个老贼，甚至还允许他通过流量骗到更多的钱。那未来一大盗，一土匪，一恶魔，亦可通过一段视频，轻易获得谅解。见微而知著，实为大患。<br>强大的国家不怕几粒“老鼠屎”，怕的是大家都开始喜欢尝“老鼠屎”。<br>文化娱乐，既要松绑，又要警惕。<br> <img src="http://boneink.life/img/diary/natu.png"  align=center /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;深夜小记&quot;&gt;&lt;a href=&quot;#深夜小记&quot; class=&quot;headerlink&quot; title=&quot;深夜小记&quot;&gt;&lt;/a&gt;深夜小记&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;“马宝国”其人其事，在网上流传已成烂梗，原以为只是老骗子一个，除去几句翻来覆去的“名人语录”，便也无他罢了。前几日</summary>
      
    
    
    
    
    <category term="日记" scheme="https://boneink.github.io/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>毕业设计《三国演义》在线统计与分析系统</title>
    <link href="https://boneink.github.io/2020/05/23/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E3%80%8A%E4%B8%89%E5%9B%BD%E6%BC%94%E4%B9%89%E3%80%8B%E5%9C%A8%E7%BA%BF%E7%BB%9F%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F/"/>
    <id>https://boneink.github.io/2020/05/23/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E3%80%8A%E4%B8%89%E5%9B%BD%E6%BC%94%E4%B9%89%E3%80%8B%E5%9C%A8%E7%BA%BF%E7%BB%9F%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-05-23T04:00:00.000Z</published>
    <updated>2020-05-23T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="毕业设计《三国演义》在线设计与分析系统"><a href="#毕业设计《三国演义》在线设计与分析系统" class="headerlink" title="毕业设计《三国演义》在线设计与分析系统"></a>毕业设计《三国演义》在线设计与分析系统</h2><blockquote><p>项目基于 Spring MVC框架，前端使用了Bootstrap和jQuery进行页面设计，使用Mybatis进行sql连接，分词处理使用了开源的Jieba分词库，数据的图表展示使用了EChart进行处理，另外通讯用的是tomcat。<br>项目地址：<a href="https://github.com/BoneInk/RTK-Analysis-System">https://github.com/BoneInk/RTK-Analysis-System</a></p></blockquote><p>记录在这个项目的编写过程中，自己遇到的一些难点和坑点：</p><h3 id="Jieba分词库的选择和使用"><a href="#Jieba分词库的选择和使用" class="headerlink" title="Jieba分词库的选择和使用"></a>Jieba分词库的选择和使用</h3><p>作为一个JavaWeb的项目，直接使用Java版的Jieba库莫过于最舒服的事情，但是自己最初蠢了，试图将Jieba库的源码直接复制进自己的项目中，成功调试出一堆bug。<br>正确的操作：将源代码在IDEA中打开后，导出为jar包，在自己的JavaWeb项目中导入lib中即可调用。</p><h3 id="注册登录弹窗和注册时的用户名可用性实时提醒"><a href="#注册登录弹窗和注册时的用户名可用性实时提醒" class="headerlink" title="注册登录弹窗和注册时的用户名可用性实时提醒"></a>注册登录弹窗和注册时的用户名可用性实时提醒</h3><p>之前大三刚上手时就已经学到了如何实现弹窗，但是作为一个难点，还是要稍微圈起来记一下。<br>在自己的登录页添加如下代码，作为基础框架：</p><pre><code><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal fade&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myModal&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal-dialog&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal-content&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal-header&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal-body&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal-footer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre><p>再添加如下代码作为调用弹窗的按钮：<br>    <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;fp-btn&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">href</span>=<span class="string">&quot;/html/login.html&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;tooltip&quot;</span> <span class="attr">data-placement</span>=<span class="string">&quot;buttom&quot;</span> <span class="attr">data-toggle</span>=<span class="string">&quot;modal&quot;</span> <span class="attr">data-target</span>=<span class="string">&quot;#myModal&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;login btn-fp&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">href</span>=<span class="string">&quot;/html/regis.html&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;tooltip&quot;</span> <span class="attr">data-placement</span>=<span class="string">&quot;buttom&quot;</span> <span class="attr">data-toggle</span>=<span class="string">&quot;modal&quot;</span> <span class="attr">data-target</span>=<span class="string">&quot;#myModal&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;register btn-fp&quot;</span> <span class="attr">value</span>=<span class="string">&quot;注册&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><br>弹出的注册窗口代码：</p>   <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal-title&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;text-center&quot;</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal-body&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span> <span class="attr">id</span>=<span class="string">&quot;regis&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入用户名(必填)&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;ajax&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>密码<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入密码(必填)&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>邮箱<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入邮箱(必填)&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;text-left&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary btn-lg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color: #418a72;color: white&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点击我获取验证码&quot;</span> <span class="attr">id</span>=<span class="string">&quot;valiDate&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;change()&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>验证码<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;validate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入验证码&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;text-right&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-default&quot;</span>  <span class="attr">style</span>=<span class="string">&quot;background-color: #498a5d;color: white&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;注册&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;checkForm1()&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn bg-danger&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color: #8a1843;color: white&quot;</span> <span class="attr">data-dismiss</span>=<span class="string">&quot;modal&quot;</span>&gt;</span>取消<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此处需要使用jQuery Ajax验证用户名的可用性：</p><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">$(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    $(<span class="string">&quot;#name&quot;</span>).<span class="title function_">blur</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="comment">//按下“name”按键触发</span></span><br><span class="line">        $.<span class="title function_">post</span>(<span class="string">&quot;/user/isValidName&quot;</span>, &#123;<span class="comment">//通过POST方法调用指定地址的Controller方法 or jsp页面 or servlet</span></span><br><span class="line">                <span class="attr">name</span>: $(<span class="variable language_">this</span>).<span class="title function_">val</span>(),<span class="comment">//发送的参数</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">function</span> (<span class="params">data</span>) &#123;<span class="comment">//返回后调用该方法</span></span><br><span class="line">                <span class="keyword">if</span> (data.<span class="property">res</span> == <span class="string">&quot;no&quot;</span>) &#123;</span><br><span class="line">                    $(<span class="string">&quot;#ajax&quot;</span>).<span class="title function_">html</span>(<span class="string">&quot;用户名已存在！&quot;</span>);</span><br><span class="line">                    $(<span class="variable language_">this</span>).<span class="title function_">select</span>();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    $(<span class="string">&quot;#ajax&quot;</span>).<span class="title function_">html</span>(<span class="string">&quot;用户名可用&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;json&quot;</span>);<span class="comment">//指定返回的数据类型</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></code></pre><p>后端对应的Controller:<br>    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/isValidName&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@ResponseBody</span></span><br><span class="line">    JSON <span class="title function_">isValidName</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name)</span> &#123;</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">json</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();<span class="comment">//生成json对象</span></span><br><span class="line">        <span class="keyword">if</span> ((User) userService.findUserByName(name) != <span class="literal">null</span>) &#123;<span class="comment">//调用方法和数据库进行数据交换</span></span><br><span class="line">            json.put(<span class="string">&quot;res&quot;</span>, <span class="string">&quot;no&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> json.put(<span class="string">&quot;res&quot;</span>, <span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> json;<span class="comment">//返回json数据</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>登录页面：</p><pre><code><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal-title&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;text-center&quot;</span>&gt;</span>登陆<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal-body&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span> <span class="attr">id</span>=<span class="string">&quot;login&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入用户名&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>密码<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入密码&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;text-left&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary btn-lg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color: #418a72;color: white&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点击我获取验证码&quot;</span> <span class="attr">id</span>=<span class="string">&quot;valiDate&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;change()&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>验证码<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;validate&quot;</span>  <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入验证码&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;text-right&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color: #498a5d;color: white&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登陆&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;checkForm()&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn bg-danger&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color: #8a1843;color: white&quot;</span> <span class="attr">data-dismiss</span>=<span class="string">&quot;modal&quot;</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span>取消<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre><p>对应的js控制代码：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> xmlHttp;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkForm1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> form=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;regis&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span>(form.<span class="property">name</span>.<span class="property">value</span> .<span class="title function_">trim</span>()== <span class="string">&quot;&quot;</span>) &#123;<span class="comment">//判断用户名是否为空</span></span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;用户名不能为空!&quot;</span>);</span><br><span class="line">        form.<span class="property">account</span>.<span class="title function_">focus</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(form.<span class="property">password</span>.<span class="property">value</span> .<span class="title function_">trim</span>()== <span class="string">&quot;&quot;</span>) &#123;<span class="comment">//判断密码是否为空</span></span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;密码不能为空!&quot;</span>);</span><br><span class="line">        form.<span class="property">pwd</span>.<span class="title function_">focus</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>($(<span class="string">&quot;#ajax&quot;</span>).<span class="title function_">text</span>()==<span class="string">&quot;用户名已存在！&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;该用户名不可用&quot;</span>);</span><br><span class="line">        form.<span class="property">pwd</span>.<span class="title function_">focus</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(form.<span class="property">validate</span>.<span class="property">value</span>!=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;valiDate&quot;</span>).<span class="property">value</span>)&#123;<span class="comment">//验证码是否正确</span></span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;验证码错误！请重新输入&quot;</span>)</span><br><span class="line">        form.<span class="property">validate</span>.<span class="title function_">focus</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    form.<span class="property">action</span>=<span class="string">&quot;/user/addUser&quot;</span>;</span><br><span class="line">    form.<span class="property">method</span>=<span class="string">&quot;post&quot;</span>;</span><br><span class="line">    form.<span class="title function_">submit</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getCode</span>(<span class="params">n</span>) &#123;<span class="comment">//生成验证码的数字</span></span><br><span class="line">    <span class="keyword">var</span> all=<span class="string">&quot;azxcvbnmsdfghjklqwertyuiopZXCVBNMASDFGHJKLQWERTYUIOP0123456789&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> b=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">var</span> index=<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">62</span>);<span class="comment">//从这62个字母或数字中取一个</span></span><br><span class="line">        b+=all.<span class="title function_">charAt</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">change</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;valiDate&quot;</span>).<span class="property">value</span>=<span class="title function_">getCode</span>(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkForm</span>(<span class="params"></span>) &#123;<span class="comment">//检查登陆界面的表单是否符合标准</span></span><br><span class="line">    <span class="keyword">var</span> form=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;login&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span>(form.<span class="property">name</span>.<span class="property">value</span> .<span class="title function_">trim</span>()== <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;用户名不能为空!&quot;</span>);</span><br><span class="line">        form.<span class="property">id</span>.<span class="title function_">focus</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(form.<span class="property">password</span>.<span class="property">value</span>.<span class="title function_">trim</span>() == <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;密码不能为空!&quot;</span>);</span><br><span class="line">        form.<span class="property">pwd</span>.<span class="title function_">focus</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(form.<span class="property">validate</span>.<span class="property">value</span>!=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;valiDate&quot;</span>).<span class="property">value</span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;验证码错误！请重新输入&quot;</span>)</span><br><span class="line">        form.<span class="property">validate</span>.<span class="title function_">focus</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    form.<span class="property">action</span>=<span class="string">&quot;/user/findUser&quot;</span>;</span><br><span class="line">    form.<span class="property">method</span>=<span class="string">&quot;post&quot;</span>;</span><br><span class="line">    form.<span class="title function_">submit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="文件上传和读取"><a href="#文件上传和读取" class="headerlink" title="文件上传和读取"></a>文件上传和读取</h3><p>文件上传需要使用<code>commons-io-2.6.jar</code>和<code>commons-fileupload-1.4.jar</code>两个包，然后在文件提交时，标注文件上传类型为’file’。<br>    <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/UploadServlet&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">                            或上传自定义文档：</span><br><span class="line">                        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;txt&quot;</span> <span class="attr">style</span>=<span class="string">&quot;float:left;width: 150px&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;确认&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn-sgst&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-top: auto&quot;</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;btn-sgst&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-top: auto&quot;</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;重置&quot;</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>之后在接收的servlet中，进行文件的临时存放和读取：</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">    <span class="type">DiskFileItemFactory</span> <span class="variable">sf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DiskFileItemFactory</span>();<span class="comment">//实例化磁盘被文件列表工厂</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> request.getServletContext().getRealPath(<span class="string">&quot;/upload&quot;</span>);<span class="comment">//得到上传文件的存放目录</span></span><br><span class="line">    sf.setRepository(<span class="keyword">new</span> <span class="title class_">File</span>(path));<span class="comment">//设置文件存放目录</span></span><br><span class="line">    sf.setSizeThreshold(<span class="number">1024</span> * <span class="number">1024</span>);<span class="comment">//设置文件上传小于1M放在内存中</span></span><br><span class="line">    <span class="type">ServletFileUpload</span> <span class="variable">sfu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletFileUpload</span>(sf);</span><br><span class="line">    <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String) session.getAttribute(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;FileItem&gt; lst = sfu.parseRequest(request);<span class="comment">//得到request中所有的元素</span></span><br><span class="line">        <span class="keyword">for</span> (FileItem fileItem : lst) &#123;</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fileItem.getInputStream(), <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                arrayList.add(line);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            session.setAttribute(<span class="string">&quot;content&quot;</span>, arrayList);</span><br><span class="line">            fileItem.delete();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="关键词对照统计及后续的排序："><a href="#关键词对照统计及后续的排序：" class="headerlink" title="关键词对照统计及后续的排序："></a>关键词对照统计及后续的排序：</h3><p>因为中文的习惯、各种官职、别称的存在以及Jieba分词库对中文分词仍不能做到100%准确分词的情况，所以会有分割后的同义词的存在，故应先根据同义词表生成关键词的Map表，由于Map的key值唯一，故关键词的Map表按照{“别称”,”原名”}的形式存放映射关系。<br>对照统计相对简单，Jieba分词的API可以把文段内容自动切割成{“word”,”startIndex”,”endIndex”}的形式，并且封装在SegToken对象中，直接获取其中的word数据即可，之后对照关键词Map进行统计，统计结果也相应的存放在Map表中，格式为{“原名”，”词频”}。<br>由于Map并不存在顺序一说，故只能先将其转换为List后，调用方法进行排序：<br>    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Map.Entry&lt;String, Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Map.Entry&lt;String, Integer&gt;&gt;(map.entrySet()); <span class="comment">//转换为list</span></span><br><span class="line">      Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Map.Entry&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2)</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> o2.getValue().compareTo(o1.getValue());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure><br>值得一提的是，此时的List内的单位元素，是一个个的Map的实体（疑似套娃）。</p><h3 id="合并章节时实现两级选项联动"><a href="#合并章节时实现两级选项联动" class="headerlink" title="合并章节时实现两级选项联动"></a>合并章节时实现两级选项联动</h3><p>目的是为了实现前一个选项选择完毕后，后一个选项给从前一个选项的数值到最大章节数的选项。此处考虑到并不需要过多数据交互，仅是一个简单的判断就行，所以仅使用DOM即可实现。<br>    html的布局代码如下：<br>    <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">           合并分析：</span><br><span class="line">       <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">       起始-&gt;<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;start&quot;</span> <span class="attr">name</span>=<span class="string">&quot;start&quot;</span> <span class="attr">onchange</span>=<span class="string">&quot;cChange()&quot;</span>&gt;</span>&lt;%</span><br><span class="line">       for (int p = 2; p &lt; resList.size(); p++) &#123;</span><br><span class="line">   %&gt;</span><br><span class="line">       <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&lt;%=p%&gt;&quot;</span>&gt;</span>&lt;%=p%&gt;</span><br><span class="line">       <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">       &lt;%</span><br><span class="line">           &#125;</span><br><span class="line">       %&gt;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">       -&gt;<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;to&quot;</span> <span class="attr">name</span>=<span class="string">&quot;to&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span>-&gt;结尾</span><br><span class="line">       <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;确认&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><br>此处涉及的逻辑有，前一个选项选择完毕后，后一个选择先清空所有选项，再重新增加符合要求的选项。因为相对于一般的组件内容改动，此处的’select’标签可调用的方法不同较多，因此花了很多时间在上面，以前使用的子节点和父母节点的方法貌似在这里无法生效。因此，查了很多地方才发现，其实方法很简单：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;selectid&quot;</span>).<span class="property">options</span>.<span class="property">length</span> = <span class="number">0</span>;<span class="comment">//方法一</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">formName</span>.<span class="property">selectName</span>.<span class="property">options</span>.<span class="property">length</span> = <span class="number">0</span>;<span class="comment">//方法二</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;selectid&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;&quot;</span>;<span class="comment">//方法三</span></span><br></pre></td></tr></table></figure><br>我这里选择了这三种之外的一种方法：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cChange</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> t = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> tt = t.<span class="property">options</span>[t.<span class="property">selectedIndex</span>].<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">var</span> opp = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;to&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span> (opp.<span class="property">options</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        opp.<span class="title function_">removeChild</span>(opp.<span class="property">options</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> max = &lt;%=resList.<span class="title function_">size</span>()%&gt;;</span><br><span class="line">    <span class="keyword">var</span> i = tt;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= max; i++) &#123;</span><br><span class="line">        opp.<span class="title function_">add</span>(<span class="keyword">new</span> <span class="title class_">Option</span>(i, i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h3 id="数据的图形化展示"><a href="#数据的图形化展示" class="headerlink" title="数据的图形化展示"></a>数据的图形化展示</h3><p>此处@王小雨同学，不愧是做了一年前端的，直接指向EChart，官方示例很容易懂，连各个组件都能定制化下载，节约了不少空间（不过即便如此，调用起来也因为其js的代码量过大而出现卡顿的情况。ps：绝对不是因为我电脑性能不够23333333。）<br>简单的直接上手即可处理完毕，此处随便贴一个柱形图的调用代码：<br>先添加一个空白的div:<br>    <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100%;height:1500px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>//此处的div大小决定了生成图表的最大值，调整这个的大小远比调整grid的大小来的实用</span><br></pre></td></tr></table></figure><br>调用的js：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">    &lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> myChart = echarts.<span class="title function_">init</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;main&#x27;</span>));<span class="comment">//此处选择要使用的div</span></span><br><span class="line">    <span class="keyword">var</span> option = &#123;</span><br><span class="line">        <span class="attr">title</span>: &#123;</span><br><span class="line">            <span class="attr">text</span>: <span class="string">&#x27;全文分析结果&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">grid</span>: &#123;<span class="comment">//改标签可进行图表的大小调整，但真正来讲，还得看依附的div的大小</span></span><br><span class="line">            <span class="attr">left</span>: <span class="string">&#x27;3%&#x27;</span>,</span><br><span class="line">            <span class="attr">right</span>: <span class="string">&#x27;4%&#x27;</span>,</span><br><span class="line">            <span class="attr">bottom</span>: <span class="string">&#x27;3%&#x27;</span>,</span><br><span class="line">            <span class="attr">containLabel</span>: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">tooltip</span>: &#123;</span><br><span class="line">            <span class="attr">trigger</span>: <span class="string">&#x27;axis&#x27;</span>,</span><br><span class="line">            <span class="attr">axisPointer</span>: &#123;</span><br><span class="line">                <span class="attr">type</span>: <span class="string">&#x27;shadow&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">xAxis</span>: &#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;value&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">yAxis</span>: &#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;category&#x27;</span>,</span><br><span class="line">            <span class="attr">inverse</span>:<span class="literal">true</span>,<span class="comment">//这句可将数据排序反转，主要为了解决竖向显示时小的数据在前边的问题</span></span><br><span class="line">            <span class="attr">axisLabel</span>: &#123;</span><br><span class="line">                <span class="attr">interval</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">data</span>: [&lt;%<span class="comment">//在哪个轴显示自变量，就在哪个轴里调用数据名</span></span><br><span class="line">        int m=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(key.<span class="title function_">equals</span>(<span class="string">&quot;noKey&quot;</span>)) m=<span class="number">100</span>;</span><br><span class="line">        <span class="keyword">else</span> m=list.<span class="title function_">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;m&amp;&amp;i&lt;list.<span class="title function_">size</span>();i++)&#123;</span><br><span class="line">            <span class="title class_">Map</span>.<span class="property">Entry</span>&lt;<span class="title class_">String</span> ,<span class="title class_">Integer</span>&gt; mapping=list.<span class="title function_">get</span>(i);</span><br><span class="line">        %&gt;<span class="string">&quot;&lt;%=mapping.getKey()%&gt;&quot;</span>,</span><br><span class="line">                &lt;%</span><br><span class="line">                &#125;</span><br><span class="line">                %&gt;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">series</span>: [&#123;<span class="comment">//此处导入数据</span></span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;词频&#x27;</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">            <span class="attr">data</span>: [&lt;%</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;m&amp;&amp;i&lt;list.<span class="title function_">size</span>();i++)&#123;</span><br><span class="line">            <span class="title class_">Map</span>.<span class="property">Entry</span>&lt;<span class="title class_">String</span> ,<span class="title class_">Integer</span>&gt; mapping=list.<span class="title function_">get</span>(i);</span><br><span class="line">        %&gt;<span class="string">&quot;&lt;%=mapping.getValue()%&gt;&quot;</span>,</span><br><span class="line">                &lt;%</span><br><span class="line">                &#125;</span><br><span class="line">                %&gt;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">itemStyle</span>: &#123;</span><br><span class="line">                <span class="attr">normal</span>: &#123;</span><br><span class="line">                    <span class="attr">color</span>: <span class="keyword">function</span> (<span class="params">params</span>) &#123;</span><br><span class="line">                        <span class="keyword">var</span> colorList = [<span class="string">&#x27;#c23531&#x27;</span>, <span class="string">&#x27;#2f4554&#x27;</span>, <span class="string">&#x27;#61a0a8&#x27;</span>, <span class="string">&#x27;#d48265&#x27;</span>, <span class="string">&#x27;#91c7ae&#x27;</span>, <span class="string">&#x27;#749f83&#x27;</span>, <span class="string">&#x27;#ca8622&#x27;</span>, <span class="string">&#x27;#bda29a&#x27;</span>, <span class="string">&#x27;#6e7074&#x27;</span>, <span class="string">&#x27;#546570&#x27;</span>, <span class="string">&#x27;#c4ccd3&#x27;</span>];</span><br><span class="line">                        <span class="keyword">var</span> index;</span><br><span class="line">                        <span class="comment">//给大于颜色数量的柱体添加循环颜色的判断</span></span><br><span class="line">                        <span class="keyword">if</span> (params.<span class="property">dataIndex</span> &gt;= colorList.<span class="property">length</span>) &#123;</span><br><span class="line">                            index = params.<span class="property">dataIndex</span> % colorList.<span class="property">length</span>;</span><br><span class="line">                            <span class="keyword">return</span> colorList[index];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> colorList[params.<span class="property">dataIndex</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">label</span>: &#123;</span><br><span class="line">                <span class="attr">show</span>: <span class="literal">true</span>, <span class="comment">//开启显示</span></span><br><span class="line">                <span class="attr">position</span>: <span class="string">&#x27;right&#x27;</span>, <span class="comment">//在上方显示</span></span><br><span class="line">                <span class="attr">textStyle</span>: &#123; <span class="comment">//数值样式</span></span><br><span class="line">                    <span class="attr">color</span>: <span class="string">&#x27;black&#x27;</span>,</span><br><span class="line">                    <span class="attr">fontSize</span>: <span class="number">13</span>,</span><br><span class="line">                    <span class="attr">fontWeight</span>: <span class="number">200</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;;</span><br><span class="line">    myChart.<span class="title function_">setOption</span>(option);</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">onresize</span> = myChart.<span class="property">resize</span>;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><br>因为自己的图表需要根据后台传来的数据生成，因此嵌入了不少Java代码，但整体上还是能看到各个必要的组件的调用格式的，必要部分已经做了注释。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以下为无关废话：<br>作为自己真正意义上的第一次完全独立完成一个较大且较为完备的项目，至少目前达到了1：能用，2：能看，3：代码不那么乱的程度，从整体的开发流程来看，前期因为了解的少，以至于花了很多时间在看各种文档和论文上，最后真正实施起来，其实花的时间很少，也就两周不到2333333，中间还熬了不少夜。值得一提的是，像登陆注册系统和合并章节分词统计结果这种功能，我开始并没有想做，因为不能说你让我做我就做，我说，那我必须要先试一下……</p><blockquote><p>（真实内心os）你看，我都用了Spring MVC框架了，不得来个数据库看看嘛，我都用数据库了，不得来个Mybatis省一下力气嘛，而且看起来还更整洁好看。</p></blockquote><p>然后就跟老师讲觉得自己做的好像还不够的样子（我也不知道哪来的精力这么讲）。</p><blockquote><p>老师：你做个每章节最高词频的统计表出来，然后再做个合并章节统计的功能出来是不是更好点？<br>我：嗯？嗯。（自己说的胡话，怎么也要吞下去）</p></blockquote><p>总的来说，自己还是熬了两夜做出来了老师要做的这个（顺便把自己还没填完的自定义上传文本的坑搞定了），成就感满满。<br>话说我还是很喜欢《三国演义》的，这种古人写的战争爽文，百看不厌好嘛。虽然自己项目做完第一时间做的是丢进去一篇《金瓶梅》测试了下自定义上传文本的效果。（主要是脑海中无限回想郭德纲那句：老爷子爱看书啊，书房里满满的三架子，各种版本的《金瓶梅》。）听说我们学校还有个教授是专门研究《金瓶梅》里的风土人情的？果然ghs才是第一生产力。<br>   &#96;&#96;&#96;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;毕业设计《三国演义》在线设计与分析系统&quot;&gt;&lt;a href=&quot;#毕业设计《三国演义》在线设计与分析系统&quot; class=&quot;headerlink&quot; title=&quot;毕业设计《三国演义》在线设计与分析系统&quot;&gt;&lt;/a&gt;毕业设计《三国演义》在线设计与分析系统&lt;/h2&gt;&lt;bloc</summary>
      
    
    
    
    
    <category term="JavaWeb" scheme="https://boneink.github.io/tags/JavaWeb/"/>
    
    <category term="jQuery" scheme="https://boneink.github.io/tags/jQuery/"/>
    
    <category term="Spring MVC" scheme="https://boneink.github.io/tags/Spring-MVC/"/>
    
    <category term="Mybatis" scheme="https://boneink.github.io/tags/Mybatis/"/>
    
    <category term="Jieba" scheme="https://boneink.github.io/tags/Jieba/"/>
    
    <category term="EChart" scheme="https://boneink.github.io/tags/EChart/"/>
    
    <category term="Sql" scheme="https://boneink.github.io/tags/Sql/"/>
    
    <category term="Bootstrap" scheme="https://boneink.github.io/tags/Bootstrap/"/>
    
    <category term="tomcat" scheme="https://boneink.github.io/tags/tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Jquery ajax 笔记</title>
    <link href="https://boneink.github.io/2020/05/11/Jquery%20Ajax%20%E7%AC%94%E8%AE%B0/"/>
    <id>https://boneink.github.io/2020/05/11/Jquery%20Ajax%20%E7%AC%94%E8%AE%B0/</id>
    <published>2020-05-11T04:00:00.000Z</published>
    <updated>2020-05-11T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="jQuery-Ajax-笔记"><a href="#jQuery-Ajax-笔记" class="headerlink" title="jQuery Ajax 笔记"></a>jQuery Ajax 笔记</h2><p>实现ajax，目前有两种方法：</p><ol><li>使用JavaScript扩展对象XMLHttpRequest实现Ajax</li><li>使用JjQuery实现ajax</li></ol><p>此处学习总结jQuery ajax方法。<br>常用格式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">    <span class="attr">type</span>:<span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&#x27;sentence.jsp&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">sentence</span>:sentence</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">dataType</span>:<span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">    <span class="attr">async</span>:<span class="literal">false</span>,</span><br><span class="line">    <span class="attr">success</span>:<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">error</span>:<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&#x27;false&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>关键词语法：</p><table><thead><tr><th align="left">名称</th><th align="left">值&#x2F;描述</th></tr></thead><tbody><tr><td align="left">async</td><td align="left">布尔值，表示请求是否异步处理。默认是 true。</td></tr><tr><td align="left">beforeSend(<em>xhr</em>)</td><td align="left">发送请求前运行的函数。</td></tr><tr><td align="left">cache</td><td align="left">布尔值，表示浏览器是否缓存被请求页面。默认是 true。</td></tr><tr><td align="left">complete(<em>xhr,status</em>)</td><td align="left">请求完成时运行的函数（在请求成功或失败之后均调用，即在 success 和 error 函数之后）。</td></tr><tr><td align="left">contentType</td><td align="left">发送数据到服务器时所使用的内容类型。默认是：”application&#x2F;x-www-form-urlencoded”。</td></tr><tr><td align="left">context</td><td align="left">为所有 AJAX 相关的回调函数规定 “this” 值。</td></tr><tr><td align="left">data</td><td align="left">规定要发送到服务器的数据。</td></tr><tr><td align="left">dataFilter(<em>data</em>,<em>type</em>)</td><td align="left">用于处理 XMLHttpRequest 原始响应数据的函数。</td></tr><tr><td align="left">dataType</td><td align="left">预期的服务器响应的数据类型。</td></tr><tr><td align="left">error(<em>xhr,status,error</em>)</td><td align="left">如果请求失败要运行的函数。</td></tr><tr><td align="left">global</td><td align="left">布尔值，规定是否为请求触发全局 AJAX 事件处理程序。默认是 true。</td></tr><tr><td align="left">ifModified</td><td align="left">布尔值，规定是否仅在最后一次请求以来响应发生改变时才请求成功。默认是 false。</td></tr><tr><td align="left">jsonp</td><td align="left">在一个 jsonp 中重写回调函数的字符串。</td></tr><tr><td align="left">jsonpCallback</td><td align="left">在一个 jsonp 中规定回调函数的名称。</td></tr><tr><td align="left">password</td><td align="left">规定在 HTTP 访问认证请求中使用的密码。</td></tr><tr><td align="left">processData</td><td align="left">布尔值，规定通过请求发送的数据是否转换为查询字符串。默认是 true。</td></tr><tr><td align="left">scriptCharset</td><td align="left">规定请求的字符集。</td></tr><tr><td align="left">success(<em>result,status,xhr</em>)</td><td align="left">当请求成功时运行的函数。</td></tr><tr><td align="left">timeout</td><td align="left">设置本地的请求超时时间（以毫秒计）。</td></tr><tr><td align="left">traditional</td><td align="left">布尔值，规定是否使用参数序列化的传统样式。</td></tr><tr><td align="left">type</td><td align="left">规定请求的类型（GET 或 POST）。</td></tr><tr><td align="left">url</td><td align="left">规定发送请求的 URL。默认是当前页面。</td></tr><tr><td align="left">username</td><td align="left">规定在 HTTP 访问认证请求中使用的用户名。</td></tr><tr><td align="left">xhr</td><td align="left">用于创建 XMLHttpRequest 对象的函数。</td></tr></tbody></table><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><ol><li>若url为jsp文件，通过java返回数据，则应用语句<code>request.setAttribute();</code>。</li><li>在js中可用<code>$&#123;&#125;</code>或嵌入java<code>&lt;%=%&gt;</code>取出指定名称的返回数据。 </li><li>若指定了返回数据的类型，则返回数据的类型需要与指定类型相同，否则会报错。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;jQuery-Ajax-笔记&quot;&gt;&lt;a href=&quot;#jQuery-Ajax-笔记&quot; class=&quot;headerlink&quot; title=&quot;jQuery Ajax 笔记&quot;&gt;&lt;/a&gt;jQuery Ajax 笔记&lt;/h2&gt;&lt;p&gt;实现ajax，目前有两种方法：&lt;/p&gt;
&lt;o</summary>
      
    
    
    
    
    <category term="JavaWeb" scheme="https://boneink.github.io/tags/JavaWeb/"/>
    
    <category term="jQuery" scheme="https://boneink.github.io/tags/jQuery/"/>
    
    <category term="Ajax" scheme="https://boneink.github.io/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb上传文件</title>
    <link href="https://boneink.github.io/2020/05/11/JavaWeb%E7%AC%94%E8%AE%B0/"/>
    <id>https://boneink.github.io/2020/05/11/JavaWeb%E7%AC%94%E8%AE%B0/</id>
    <published>2020-05-11T04:00:00.000Z</published>
    <updated>2020-05-11T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaWeb上传文件"><a href="#JavaWeb上传文件" class="headerlink" title="JavaWeb上传文件"></a>JavaWeb上传文件</h2><p>前端：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>导入文本分词：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;UploadServlet&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span><span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    &lt;%--名称：<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;txt_name&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span>--%&gt;</span><br><span class="line">    上传文件：<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;txt&quot;</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>/&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;重置&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>设置Servlet：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.fileupload.FileItem;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.fileupload.disk.DiskFileItemFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.fileupload.servlet.ServletFileUpload;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.fileupload.FileUploadException;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.doPost(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        DiskFileItemFactory sf= <span class="keyword">new</span> <span class="title class_">DiskFileItemFactory</span>();<span class="comment">//实例化磁盘被文件列表工厂</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> request.getRealPath(<span class="string">&quot;/upload&quot;</span>);<span class="comment">//得到上传文件的存放目录</span></span><br><span class="line">        sf.setRepository(<span class="keyword">new</span> <span class="title class_">File</span>(path));<span class="comment">//设置文件存放目录</span></span><br><span class="line">        sf.setSizeThreshold(<span class="number">1024</span>*<span class="number">1024</span>);<span class="comment">//设置文件上传小于1M放在内存中</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rename</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;<span class="comment">//文件新生成的文件名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;<span class="comment">//文件原名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;<span class="comment">//普通field字段</span></span><br><span class="line">        <span class="comment">//从工厂得到servletupload文件上传类</span></span><br><span class="line">        <span class="type">ServletFileUpload</span> <span class="variable">sfu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletFileUpload</span>(sf);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;FileItem&gt; lst = sfu.parseRequest(request);<span class="comment">//得到request中所有的元素</span></span><br><span class="line">            <span class="keyword">for</span> (FileItem fileItem : lst) &#123;</span><br><span class="line">                <span class="keyword">if</span>(fileItem.isFormField())&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="string">&quot;name&quot;</span>.equals(fileItem.getFieldName()))&#123;</span><br><span class="line">                        name = fileItem.getString(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//获得文件名称</span></span><br><span class="line">                    fileName = fileItem.getName();</span><br><span class="line">                    fileName = fileName.substring(fileName.lastIndexOf(<span class="string">&quot;\\&quot;</span>)+<span class="number">1</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">houzhui</span> <span class="operator">=</span> fileName.substring(fileName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">                    rename = UUID.randomUUID()+houzhui;</span><br><span class="line">                    fileItem.write(<span class="keyword">new</span> <span class="title class_">File</span>(path, rename));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        response.sendRedirect(<span class="string">&quot;file.jsp&quot;</span>);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：注意导入<code>commons-io-2.6.jar</code>和<code>commons-fileupload-1.4.jar</code>，以区分tomcat中同名的api。</p><p>在<code>web.xml</code>中添加servlet:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>UploadServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>UploadServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>UploadServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/UploadServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时会出现中文文件名名乱码，在<code>doPost()</code>方法中添加如下即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JavaWeb上传文件&quot;&gt;&lt;a href=&quot;#JavaWeb上传文件&quot; class=&quot;headerlink&quot; title=&quot;JavaWeb上传文件&quot;&gt;&lt;/a&gt;JavaWeb上传文件&lt;/h2&gt;&lt;p&gt;前端：&lt;/p&gt;
&lt;figure class=&quot;highlight h</summary>
      
    
    
    
    
    <category term="JavaWeb" scheme="https://boneink.github.io/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>Python 学习笔记</title>
    <link href="https://boneink.github.io/2020/03/27/Python%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://boneink.github.io/2020/03/27/Python%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-03-27T04:00:00.000Z</published>
    <updated>2020-03-27T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Python-学习笔记"><a href="#Python-学习笔记" class="headerlink" title="Python 学习笔记"></a>Python 学习笔记</h3><blockquote><p>因毕业设计需要，学习下入门级的python基本知识。 </p></blockquote><h4 id="需要注意的数据类型"><a href="#需要注意的数据类型" class="headerlink" title="需要注意的数据类型"></a>需要注意的数据类型</h4><ul><li><p>Dic :<br>  Python包含以下函数:</p><table><thead><tr><th align="left">序号</th><th>函数及描述</th></tr></thead><tbody><tr><td align="left">1</td><td><a href="https://www.runoob.com/python/att-dictionary-cmp.html">cmp(dict1, dict2)</a><br/>比较两个字典元素。</td></tr><tr><td align="left">2</td><td><a href="https://www.runoob.com/python/att-dictionary-len.html"> len(dict)</a> <br/>计算字典元素个数，即键的总数。</td></tr><tr><td align="left">3</td><td><a href="https://www.runoob.com/python/att-dictionary-str.html"> str(dict)</a> <br/>输出字典可打印的字符串表示。</td></tr><tr><td align="left">4</td><td><a href="https://www.runoob.com/python/att-dictionary-type.html"> type(variable)</a> <br/>返回输入的变量类型，如果变量是字典就返回字典类型。</td></tr></tbody></table><p>  Python包含以下方法:</p><table><thead><tr><th align="left">序号</th><th align="left">函数及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-clear.html">dict.clear()</a> 删除字典内所有元素</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-copy.html">dict.copy()</a> 返回一个字典的浅复制</td></tr><tr><td align="left">3</td><td align="left">[dict.fromkeys(seq<a href="https://www.runoob.com/python/att-dictionary-fromkeys.html">, val])</a> 创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-get.html">dict.get(key, default&#x3D;None)</a> 返回指定键的值，如果值不在字典中返回default值</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-has_key.html">dict.has_key(key)</a> 如果键在字典dict里返回true，否则返回false</td></tr><tr><td align="left">6</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-items.html">dict.items()</a> 以列表返回可遍历的(键, 值) 元组数组</td></tr><tr><td align="left">7</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-keys.html">dict.keys()</a> 以列表返回一个字典所有的键</td></tr><tr><td align="left">8</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-setdefault.html">dict.setdefault(key, default&#x3D;None)</a> 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</td></tr><tr><td align="left">9</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-update.html">dict.update(dict2)</a> 把字典dict2的键&#x2F;值对更新到dict里</td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-values.html">dict.values()</a> 以列表返回字典中的所有值</td></tr><tr><td align="left">11</td><td align="left">[pop(key<a href="https://www.runoob.com/python/python-att-dictionary-pop.html">,default])</a> 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</td></tr><tr><td align="left">12</td><td align="left"><a href="https://www.runoob.com/python/python-att-dictionary-popitem.html">popitem()</a> 返回并删除字典中的最后一对键和值。</td></tr></tbody></table></li><li><p>List :</p><p>Python包含以下函数:</p><table><thead><tr><th align="left">序号</th><th align="left">函数</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-len.html">len(list)</a> 列表元素个数</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-max.html">max(list)</a> 返回列表元素最大值</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-min.html">min(list)</a> 返回列表元素最小值</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-list.html">list(seq)</a> 将元组转换为列表</td></tr></tbody></table><p>Python包含以下方法:</p><table><thead><tr><th align="left">序号</th><th align="left">方法</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-append.html">list.append(obj)</a> 在列表末尾添加新的对象</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-count.html">list.count(obj)</a> 统计某个元素在列表中出现的次数</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-extend.html">list.extend(seq)</a> 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-index.html">list.index(obj)</a> 从列表中找出某个值第一个匹配项的索引位置</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-insert.html">list.insert(index, obj)</a> 将对象插入列表</td></tr><tr><td align="left">6</td><td align="left">[list.pop(<a href="https://www.runoob.com/python3/python3-att-list-pop.html">index&#x3D;-1])</a> 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td></tr><tr><td align="left">7</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-remove.html">list.remove(obj)</a> 移除列表中某个值的第一个匹配项</td></tr><tr><td align="left">8</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-reverse.html">list.reverse()</a> 反向列表中元素</td></tr><tr><td align="left">9</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-sort.html">list.sort( key&#x3D;None, reverse&#x3D;False)</a> 对原列表进行排序</td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-clear.html">list.clear()</a> 清空列表</td></tr><tr><td align="left">11</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-copy.html">list.copy()</a> 复制列表</td></tr></tbody></table></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Python-学习笔记&quot;&gt;&lt;a href=&quot;#Python-学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Python 学习笔记&quot;&gt;&lt;/a&gt;Python 学习笔记&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;因毕业设计需要，学习下入门级的python</summary>
      
    
    
    
    
    <category term="编程语言入门" scheme="https://boneink.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"/>
    
    <category term="python" scheme="https://boneink.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>诸子的那些瞬间</title>
    <link href="https://boneink.github.io/2020/03/05/%E8%AF%B8%E5%AD%90%E7%9A%84%E9%82%A3%E4%BA%9B%E7%9E%AC%E9%97%B4/"/>
    <id>https://boneink.github.io/2020/03/05/%E8%AF%B8%E5%AD%90%E7%9A%84%E9%82%A3%E4%BA%9B%E7%9E%AC%E9%97%B4/</id>
    <published>2020-03-05T15:22:48.000Z</published>
    <updated>2020-03-05T15:22:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="诸子的那些瞬间"><a href="#诸子的那些瞬间" class="headerlink" title="诸子的那些瞬间"></a>诸子的那些瞬间</h2><p>鲍鹏山 著</p><hr><blockquote><p>导读<br>推开历史的窗户，中国的一个时代——春秋战国时代，天佑中华，诸子并出，百花齐放，百家争鸣，从而使我们民族的思想与智慧灿若星河、光芒万丈；而且，他们同时被誉为人类伟大的精神导师。为了巡视这一中华民族的精神高地，我们约请鲍鹏山先生为我们描述诸子的风采。鲍鹏山先生举一反三、举三反九，在“轴心时代”的世界历史大背景下，为我们描绘了老子、孔子和庄子三大师的魅力瞬间，独到的把握与精彩的叙述，使我们的阅读收获如行山阴道上。</p></blockquote><h4 id="引子：-“轴心时代”"><a href="#引子：-“轴心时代”" class="headerlink" title="引子： “轴心时代”"></a>引子： “轴心时代”</h4><p>德国，1883年，卡尔·马克思去世。<br>同年，也是德国，一位也叫卡尔的著名哲学家诞生。他就是卡尔·西奥多·雅斯贝尔斯（Karl Theodor Jaspers，1883年2月23日至1969年2月26日）。<br>1949年，新中国成立那年，他出版了《历史的起源与目标》一书，在此书中，他站在世界文化的旷野上，对旧中国的一个时代和这个时代的人物给予了极高的评价。<br>这个时代是东周的春秋战国时代。<br>雅斯贝尔斯把这个时代称之为人类文明的“轴心时代”（公元前800至公元前200年之间，尤其是公元前600至前300年间。）在这个时代，在地球上北纬30度上下,就是北纬25度至35度区间里，人类的文明精神出现了重大突破，出现了一些伟大的精神导师——古希腊有苏格拉底、柏拉图、亚里士多德，以色列有犹太教的先知们，古印度有释迦牟尼，中国有孔子、老子……<br>这种突破，是对原始文化的超越和突破，雅斯贝尔斯称之为人类“终极关怀的觉醒”。人类开始用理智的方法、道德的方式来面对这个世界，宗教开始出现。今天西方、印度、中国、伊斯兰不同的文化形态，就是由于他们各自不同的超越和突破类型。<br>如何理解雅斯贝尔斯所说的“终极关怀的觉醒”？<br>我的理解是：<br>第一，人类试图从整体上把握世界，而不是零敲碎打，个别地孤立地认识世界。同时，人类开始严肃地思考人类和宇宙的关系，司马迁所说的“究天人之际”——认识论出现。<br>第二，人类开始有了自觉，开始认识自我，认识人我关系——伦理学展开。<br>第三，人类开始认识到人是有道德使命的，即，人不仅是一个道德的存在，从而区别于一般动物；而且，人还负有建设道德世界的责任——世界观觉醒。<br>第四，人类有了明确的时间意识，开始关注人类的历史，意识到人类是一个文化的存在并且有着文化的使命和宿命，司马迁所说的“通古今之变”——历史观诞生。<br>其实，在中国，在雅斯贝尔斯所谓的轴心时代过去不到100年，汉武帝时代的一位太史令，一个大学者，一个更大学者——司马迁的父亲司马谈，就对中国的轴心时代作了深刻的总结。他的一篇专题论文《论六家要旨》，总结了轴心时代的六个重要流派的主要思想：阴阳家、儒家、墨家、名家、法家、道德家。大约再过200年，东汉的一个大学者、史学家班固，在他的《汉书·艺文志》中，在六家之外，又加了四家：纵横家、农家、杂家、小说家。于是有了“九流十家”之说。<br>其实，“九流十家”仍然没有囊括尽那个时代中国人的信仰、思想与知识，比如，兵家，医家……<br>他们是这样一些人：老子、孔子、墨子、孙子、孟子、庄子、商鞅、荀子、韩非子……<br>他们鼓吹着这样一些概念：道、德、仁、义、礼、智、信、勇、法、术、势、王道、仁政、兼爱、尚贤、大同、小康……<br>每一个概念的背后都蕴含着深刻的思想。这些思想是对整个人类文明和人类道德使命的思考。这些思考变成了文明的成果积淀下来，这些积淀最后就成了人类生存的价值观和价值基础。并且，形成了独特的民族特色。<br>“弑君三十六，亡国五十二。”——这是孔子描述的春秋时代。<br>“今夫天下之人牧，未有不嗜杀人者也。”“且王者之不作，未有疏于此时者也；民之憔悴于虐政，未有甚于此时者也。”——这是孟子对战国时代的评价。<br>春秋战国，是一个血与火的时代，是一个兴衰存亡的时代。<br>但却也是中国人精神和人格蓬蓬勃勃的时代。<br>孟子还曾这样说他的时代：“圣王不作，诸侯放恣，处士横议。”<br>圣王之权没有了，诸侯自以为王。<br>圣王之义没有了，诸子自以为是。<br>所以，这时代，两类人最活跃：诸侯和诸子。<br>诸侯争霸，诸子争鸣。<br>诸侯争夺的，是子女玉帛，土地城池， “争地以战，杀人盈野；争城以战，杀人盈城”。——孟子破口大骂：率土地而食人肉，善战者服上刑！<br>诸子争鸣的，是仁义礼法，天道人性。判天地之美，析万物之理，察古人之全。惜乎贤圣不明，道德不一，不见天地之纯，古人之大体。——庄子仰天浩叹：道术已为天下裂！<br>争霸的结果，是，天下版图尽入于秦。<br>争鸣的结果，是，天下学术终归于法。<br>结果是悲剧，过程却被历史一再回味。  </p><h4 id="1-紫气东来"><a href="#1-紫气东来" class="headerlink" title="1.紫气东来"></a>1.紫气东来</h4><p>司马谈毕竟大汉气度，他纵论六家，指点圣贤，各有褒贬，大气磅礴。<br>但是，有着黄老思想的他，对以老子为代表的道家思想给予了全面的肯定。<br>他这样说老子的道家：<br>道家无为，又曰无不为，其实易行，其辞难知。其术以虚无为本，以因循为用。无成埶，无常形，故能究万物之情。不为物先，不为物后，故能为万物主。有法无法，因时为业；有度无度，因物与合。故曰“圣人不朽，时变是守”。<br>他眼中的圣人，不是孔子，而是老子。难怪他的儿子司马迁不仅把老子写成孔子之师，还借孔子之口，称服老子为“龙”。<br>司马迁在《史记·老子韩非列传》中这样记述：<br>老子修道德，其学以自隐无名为务。居周久之，见周之衰，乃遂去。<br>以自隐无名为务，这句话有意思。因为，人须已显行迹已有名声，才有隐藏行迹埋没名声这样一层烦恼，否则，历史上漫漫而来又漫漶而去的芸芸众生何其多耶，谁又需要一门专门的学问来泯灭行迹名声。盖老子当是当代大名人，后来孔子不远数百里求教洛邑，也可印证。<br>作为周朝的档案馆馆长，见周之衰，便黯然离去。<br>离开了周，老子去哪里呢？<br>据说是出关去西域了。出的关据说就是函谷关。<br>函谷关当初大概在今天的河南灵宝县，后来关口移到了今天的河南新安县。这里两山对峙，中间一条小路，因为路在山谷中，既深又险要，好像在函子里一样，所以取名为函谷关。<br>至关，关令尹喜曰：“子将隐矣，强为我著书。”<br>我要写的历史上老子的瞬间，就在此刻发生。此时大约在2500多年前，公元前500年左右。<br>既然老子要无名自隐，自然也不会有什么著作昭示众生。如果没有此时此地此人，没有这个瞬间，《道德经》一书就没有了。<br>所以我觉得我们可以把此一瞬间，不仅看作老子的瞬间，更要看成是中国哲学的破茧而出的瞬间。石破天惊逗秋雨。天雨粟，鬼夜哭！<br>大概也是觉得这个瞬间的非同寻常，司马贞索隐引刘向《列仙传》，给这个瞬间一个玄之又玄的序幕：<br>老子西游，关令尹喜望见有紫气浮关，而老子果乘青牛而过也。<br>据说这位关令尹喜也是周之大夫，也是一个隐德行仁的高人。他预先望见有紫气东来，知道将有真人经过，便留意观察东来行人，果然迎得老子。尹喜对老子说，你要从人间隐退了。在你远行之前，为我们留下你的思想吧。<br>司马迁接着叙道：<br>于是老子乃著书上下篇，言道德之意五千余言而去，莫知所终。<br>老子的生平，对我们而言，是无始无终的：我们不知道他从哪里来，也不知道他到了哪里去。我们不知他的生，也不知他的死。他自己说“出生入死”，他好像是来自宇宙中某一个星球的高度发达的物种，在我们这个星球的东方落脚，然后，又飞升而去。据说，甘肃临洮的“超然台”，就是他的飞升之所。<br>后来道教的仙人，都是以“飞升”的方式离开这个星球。难道道士们就是一群来自星星的你？<br>老子，他或许还在那个星星上远眺地球。会有一声叹息来自天庭吗？他还记得他留在这个地球上的五千言吗？<br>它们已经成为全人类的智慧渊薮。  </p><h4 id="2-东鲁杏坛"><a href="#2-东鲁杏坛" class="headerlink" title="2.东鲁杏坛"></a>2.东鲁杏坛</h4><p>据说孔子也曾经有这样的去意。他曾经感叹：道不行，乘桴浮于海。但最终没有成行，他只是离开了鲁国，周游列国，被当时人讽刺为“避人之士”。老了，还是回到鲁国，整理六经。孔子没有老子的决绝。他也曾经对着一位卫国的隐士叹息自己：“果哉！末之难矣。”——他真果决啊！我做不到啊！<br>其实，在老子被尹喜强迫留下五千言之前，孔子也曾用他的方式纠缠过老子，让他留下教诲。<br>《史记·老子韩非列传》有这样一则动人的故事：<br>孔子适周，将问礼于老子。老子曰：“……吾闻之，良贾深藏若虚，君子盛德，容貌若愚。去子之骄气与多欲，态色与淫志，是皆无益于子身。”<br>这是老子和孔子两个人的瞬间，也是两种思想、两种学派、两种思维范式互相碰撞的瞬间。阴性的老子和阳性的孔子相撞击，如同天空的雷电，瞬间照亮黑暗的历史天幕。<br>此刻的老子，估计应该在六十岁左右吧，孔子，三十四岁。面对这样一个血气方刚的后生，老子不动声色地点出两个字：藏和愚。<br>其实，愚就是藏。把智慧藏起来。把才华藏起来。把志向藏起来。把理想藏起来。藏不是没有，不是放弃，是一种含蓄而坚定的保持。“愚”，不是智慧的缺乏，而是智慧的“收藏”，不是智慧的不足，而是智慧的收敛，不是智慧的麻木，而是智慧的蛰伏。<br>我们其实可以想象得到：三十而立之后的孔子，是何等意气风发，斗志昂扬，是何等志向远大，理想崇高，是何等意志坚定，自信自负……<br>这些都是一个年轻人的优点，没有这些，注定不会有所成就。<br>但是，如果仅仅这样，而缺少适度的弹性，适度的退守，适度的淡泊，也不会成为大才。<br>此时的孔子，学问有了，志向有了，眼界胸襟都有了。但是，还缺乏一种东西：弹性的性格。<br>孔子见老子，是孔子人生的一个瞬间。这个瞬间，如同滚烫的生铁突然淬火，获得了更多的特质。<br>此后的孔子，阳刚依旧，阔大依旧，但多了一分从容淡定、轻松自在。<br>《庄子·渔父》：<br>孔子游乎缁帷之林，休坐乎杏坛之上。弟子读书，孔子絃歌鼓琴，奏曲未半。<br>曲阜孔庙里，即有一个杏坛赫然矗立。但细揣庄子之意，他笔下的“杏坛”，不过是孔子带着弟子从茂密浓郁的森林中走出，恰好碰到的一个水边高台而已，此水即是渔父打渔之地，谋生之所而隐居之处，芦苇丰茂，绝无可能在鲁国都之内。也就是说，“杏坛”，本来就只是庄子随口诌出的一个词，绝无可能是孔子专门讲学之所，则今天孔庙里的杏坛，就只能是后人望文生物而造出来的。顾炎武说：“《庄子》书凡述孔子，皆是寓言，渔父不必有其人，杏坛不必有其地。即有之，亦在水上苇间、依陂旁渚之地，不在鲁国之中也明矣。”（《日知录·卷三十一》）<br>但是，一个道家人物随口诌出的词，为什么却被坐实，一个虚构的寓言，如何竟然成为历史？<br>其实原因非常简单：这个寓言，不是生活的真实，但却有着本质上的真实；不是物理上的真实，却是精神上的真实——它确实是孔子日常教学生涯的高度概括。<br>孔子的私学，与弟子切磋琢磨的日常生活，实现了人类生活有可能达到的现实与精神、物理与心灵的圆融。这种圆融，已经超越了物理之真与伦理之善，而达到极致的境界：美。真与善的纯粹之境，就是美。<br>庄子，毕竟是手眼通天的极致高人，他感受到了孔子生活方式的诗意，他直觉到了孔子日常生活中蕴含着人类生活的大美。他看到了，他情不自禁地喊出：美啊！请停留一下！<br>最后，他用自己的文字，让这个美永恒停留：眼前春水，身后杏花，白云在天，清风在袖，落花依草，弟子围坐——这虚构的一时胜境，从此成为一个民族永恒的灵境，孔子和他的弟子们，永在此境，弹琴，歌唱，笑语盈盈。——这其实就是天堂的模样。<br>我们来看看这一瞬间：孔子，在水陂边，杏树下，安详地坐下，展开他的五弦琴，轻声弦歌。弟子们，安静地围拢——琴声响起，歌声响起，书声琅琅。这个混乱嘈杂充满杀伐怨恨之声的时代仿佛一下子阒寂无声，而明媚的阳光和明丽的杏花、明滟的水面，一下子照亮了时代的黑暗。<br>——这是孔子生命的一个瞬间，但是，它成了一个民族的永恒时光：就在这一瞬间，这个民族重新获得了从容与安详，获得了光明与方向。<br>我在两千多年后向那个黑暗的时代投去目光，我看到了在黑暗的心脏，有这样一片温暖的光亮。我看到这个光圈里面，一个慈祥的老人，和围坐在他身边的年轻人。是的，只要我们心中永远有这样一幅画面，我们就不会缺少温暖，我们的心灵就有皈依。而且，我们会循着这个光亮，围拢过去，一圈又一圈，无限延展……<br>我常常想一个问题：十五岁的从事“鄙事”以养活自己的少年，何以会立下“志于学”的志向？在他那个阶层的人无论传统还是现实都以出仕从政为人生正途的时代，“志于学”这三个字是何等石破天惊，预示着一个圣人的降临，预示着一个民族的苏醒？是什么样的宇宙能量电击了他那有些畸形状如反宇的头颅？他那四周高中间低的奇特头型，是否就是这次电击的印记？<br>我还常常想一个问题，三十岁的孔子，从社会的最底层已经进入鲁国的上层甚至可以进入太庙，在仕途一派光明的时候，突然放弃这一切，转而创立私学，开启人类教育的新纪元，把文明的星星之火点燃？他领悟到了什么样的历史使命？<br>老子走了，孔子来了。<br>老子因失望而离去，孔子为拯救而到来。<br>老子是史前史的后记，充满叹息和诅咒。《道德经》作为历史的总结，智慧高超，但冷静到冷酷。<br>孔子是新纪元的序言，充满期待和勉励。《论语》作为新历史的开篇，仁德蔼然，热心到热切。<br>老子留给我们巨大黝黑的背影，孔子展露给我们宽广明亮的前额。<br>天不生仲尼，万古如长夜。<br>朱熹《朱子语类》卷九十三记下了这句话，并在后面有一句说明：“唐子西尝于一邮亭梁间见此语。”唐子西，唐庚(1069～1120)，字子西，眉州(今四川眉山)人，《唐子西文录》记载：“蜀道馆舍壁间题一联云：‘天不生仲尼，万古如长夜’，不知何人诗也。”<br>我很奇怪，对孔子的精神境界体悟得最为深刻描叙得最为到位也最为诗意的，总是这些“不知何人”的人：说孔子是“天下之木铎”的，是无名氏；说孔子是“丧家狗”的，是无名氏；说孔子是“知其不可而为之者”的，也是无名氏。<br>他们都感受到了孔子的真精神。<br>我们不都是无名氏？我们的内心，不也感受到了孔子？不也听到了他的声音，感觉到了他的心跳，体贴到了他的温暖？  </p><h4 id="3-庄周梦蝶"><a href="#3-庄周梦蝶" class="headerlink" title="3.庄周梦蝶"></a>3.庄周梦蝶</h4><p>庄子在一个黑夜里，在他的土屋中想象并描写了孔子的杏坛。他肯定意识到了，这是历史的瞬间，是人类文明的瞬间。<br>其实，他也有他光芒万丈的瞬间。<br>《史记》说庄子“与梁惠王、齐宣王同时。其学无所不窥，然其要本归於老子之言。”老庄并称一如孔孟连及。庄子固然尊敬孔子，但他最为向慕的，还是老子。<br>《孔子世家》里，还记载了老子送给孔子的临别赠言：<br>为人子者毋以有己，为人臣者毋以有己。<br>其实，我一直想把这两句话中的“子”和“臣”两个字去掉，从而两句成一句——“为人者毋以有己”。<br>这不是我自作聪明，删改前贤嘉言。庄子早就这样改了，他的句子比我的更简洁，只有三个字——吾丧我。<br>吾——即自我的本体，本来的自我。<br>我——附寄于“吾”的自以为是的观念、知识、经验、是非、好恶等等“成见”“成心”。<br>“我”总是遮蔽着“吾”，不仅使“吾”不能与世界赤诚相见，无法互相洞开；反而使得“吾”认“我”为“吾”，“我”把“吾”李代桃僵了。<br>使“吾”遮蔽，让“我”嚣张的，莫过于功名利禄。<br>讲到这里，我们来看看属于庄子的瞬间——<br>庄子钓于濮水，楚王使大夫二人往先焉，曰：“愿以境内累矣！”<br>庄子持竿不顾，曰：“吾闻楚有神龟，死已三千岁矣，王巾笥而藏之庙堂之上。此龟者，宁其死为留骨而贵乎？宁其生而曳尾于涂中乎？”<br>二大夫曰：“宁生而曳尾涂中。”<br>庄子曰：“往矣，吾将曳尾于涂中。”<br>这确实是典型的庄子的瞬间。对于体制来说，老子是身处其中而离开，庄子是身处其外而不入。这两者似同而实异：身处其中而离开者，是出于失望；身处其外而不入者，是出于无望。一个是由有入无，一个是本来即无。盖庄子，较之老子，对体制的道德属性更其绝望，他是避世之士，而老子，其实还只是避人之士——与孔子其实差不多。老子出关，孔子去鲁；老子远去西域而以华夏化胡，孔子欲居九夷而用君子除陋，其实，两人都还是有一番作为之心。鲁迅看得明白：<br>故自史迁以来，均谓周之要本，归于老子之言。然老子尚欲言有无，别修短，知白黑，而措意于天下；周则欲并有无修短白黑而一之，以大归于“混沌”，其“不谴是非”“外死生”“无终始”，胥此意也。中国出世之说，至此乃始圆备。（《汉文学史纲要·老庄》）<br>需要说明的是，中国传统儒道文化之“出世”，并非印度佛教之“出世”。中国儒道之出世，乃是弃绝体制；印度佛教之出世，乃是跳出轮回。儒道之出世，并非出伦理，只是出体制；不是出人生，恰恰相反，是要一个更好的人生。《道德经》之小国寡民，陶渊明之《桃花源记》，都是为了更好的人生而设计，都是为了更好的人生而眺望。我们看到，无论是老子的“小国寡民”，还是陶渊明的“桃花源”，都是无国无君而有人伦父子。儒道之出世，不过是拒绝公共生活影响私人生活，不使公共责任影响个人逍遥，不让职事之鞅掌限制个人之自由，更不愿体制之污浊亵渎个人之名节。个人逍遥本来只是一种审美境界，但是，由于体制本身的道德属性往往负面，背离体制就显得正面，而那些对着体制背转身去的人，也往往确实是背转体制的那一分肮脏与非人性，为此他们还要承受巨大的物质上的损失。于是，他们就获得了道德上与审美上的双重意义——道德意义是在肮脏的世界保持一分干净；审美意义是个人自由具有无与伦比的价值。<br>说到“逍遥”，我们就不能不说庄子了。翻开庄子，第一篇就是《逍遥游》。<br>北冥有鱼，其名曰鲲。鲲之大，不知其几千里也。化而为鸟，其名为鹏。鹏之背，不知其几千里也；怒而飞，其翼若垂天之云。是鸟也，海运则将徙于南冥。（《逍遥游》）<br>庄子的价值，在于为人类开拓出一个经验之外的世界，并且告诫我们，使我们不自由的，恰恰是我们的经验和知识。<br>逍遥游，就是无牵无挂的自由，就是绝对自由。但是，庄子用的是这样的词：无待。<br>何为待？——待者，恃也，凭借，依赖。<br>何为无待？——就是无恃，无所凭借。<br>人生最常见的待什么？待知识。待经验。待常识。<br>但是，庄子偏偏告诉我们，不能依赖知识、经验、常识等等，甚至，你读他的文章，他都暗示你，不要带着成见、经验、知识进来。<br>试想，带着经验和常识，我们如何能读这样的文字？经验、常识与理性，如何能容忍和接受这样的文字？<br>庄子的出现，拓展了我们的世界和视界。<br>孔子讲日常伦理，他要我们踏实而真诚地生活。<br>庄子大言，讲经验之外的世界，他在教我们超凡绝俗地生活。<br>但庄子最独特的贡献，还是他教会我们如何去死。<br>庄子《大宗师》有言：“死生，命也。”<br>死亡是一个现实的事件，但是，死后的世界却是一个非现实的世界。所以，孔子这样的关注现实的思想家往往拒绝谈论这样的话题。<br>而《庄子》一书却满是生死神怪。<br>庄子说他到楚国去，途中见到一个骷髅，他同情骷髅，骷髅却告诉他：“人一旦死了，在上没有国君的统治，在下没有官吏的管辖；也没有四季的操劳，从容安逸天长地久，即使南面为王的快乐，也不可能超过。”并且坚决拒绝再活过来。（《庄子·至乐》）<br>实际上，这段对话里，骷髅才是庄子，而那个“庄子”，则是庄子在表演“我们”——“骷髅”庄子在告诉“我们”，死了，比活着好。<br>这当然是对生活很失望的意思。你看他借列子之口发出的感慨：<br>列子行，食于道从(道旁)，见百岁髑髅，攓蓬而指之曰：“唯予与汝知而未尝死、未尝生也。若果养乎？予果欢乎？”<br>陶渊明说：“生实艰难，死如之何！”也是这个意思。<br>总之，我们几千年来没怎么活好过，所以，也不怕死。相反，“以生为附赘县疣，以死为决肒溃痈。”（《庄子·大宗师》）<br>庄子妻死，庄子箕踞鼓盆而歌。为什么歌？是祝贺她终于解脱了，好比是囚徒的刑满释放。<br>子桑户、孟子反、子琴张三人……相与为友。莫然有间而子桑户死，未葬。孔子闻之，使子贡往侍事焉。或编曲，或鼓琴，相和而歌曰：“嗟来桑户乎！嗟来桑户乎！而已反其真，而我犹为人猗！”（《庄子·大宗师》）<br>你看，他们是羡慕死去的人，痛哭自己还得在人世受煎熬。<br>我们有这样两个成语，一个叫“视死如归”，一个叫“人生如梦”，这是庄子给我们创造的——<br>予恶乎知说生之非惑邪！予恶乎知恶死之非弱丧而不知归者邪！……予恶乎知夫死者不悔其始之蕲生乎！……梦饮酒者，旦而哭泣；梦哭泣者，旦而田猎。方其梦也，不知其梦也。梦之中又占其梦焉，觉而后知其梦也。且有大觉而后知此其大梦也。（《庄子·齐物论》）<br>呵呵，庄子说，人只有经过一场大觉才能知道他自身乃是一场大梦。<br>他岂只是为我们创造了两个成语？他为我们建立了一种生死观，让我们含笑面对死亡，让我们在死神面前，保持潇洒的风度和英雄的气概。<br>人生如梦，是一种认识。<br>视死如归，是一种态度。<br>有这样的认识，我们很深刻。<br>有这样的态度，我们很潇洒。<br>它们——<br>一、显示了我们的洞彻人生的智慧；<br>二、体现了我们的笑对死亡的风度。<br>法国思想家蒙田有一篇文章，题目就叫《哲学就是学会死》——据说，这是西塞罗引述柏拉图的话。<br>哲学就是学会死。多好的话啊。<br>那么，哲人呢？<br>哲人就是给我们一个最为美丽的死亡姿势，让死亡也充满魅力的人。<br>庄子将死，弟子们讨论如何安葬庄子，他们的计划里，要用很多东西作为陪葬。<br>有意思的是，他们讨论这些时，就在庄子身边，也不避开庄子。<br>于是，庄子加入了讨论，也表达了他的意见。<br>庄子说：“我把天地当作棺槨，把日月当作连璧，把星辰当作珠玑，万物都可以成为我的陪葬。我陪葬的东西难道还不完备吗？哪里用得着再加上这些东西呢。”<br>弟子们说：“我们担忧乌鸦和老鹰会啄食先生的遗体。”<br>庄子说：“弃尸地面就是让乌鸦和老鹰吃，深埋地下就是让蚂蚁吃。你们为什么要抢夺乌鸦老鹰的吃食交给蚂蚁呢？你们怎么如此偏心？”（《列御寇》）<br>庄子一辈子嘲弄世界，此刻，他嘲弄自己的死亡。<br>他一辈子幽默，死到临头，还向死幽默。<br>而这幽默里，又包含着对众生的广博的爱和大平等。<br>《庄子》中，庄子两次借孔子之口感叹：死生亦大矣。那好，我们就比较一下孔子的死。<br>孔子病，子贡请见。孔子方负杖逍遥于门，曰：“赐，汝来何其晚也？”孔子因叹，歌曰：“太山坏乎！梁柱摧乎！哲人萎乎！”因以涕下。谓子贡曰：“天下无道久矣，莫能宗予。夏人殡于东阶，周人于西阶，殷人两柱间。昨暮予梦坐奠两柱之间，予始殷人也。”后七日卒。（《史记·孔子世家》）<br>孔子的死，是悲剧。<br>庄子的死，是喜剧。<br>孔子的死，让我们哭。<br>庄子的死，让我们笑。<br>孔子把自己的死看得很大。<br>庄子把自己的死看得很小。<br>孔子知道自己的分量，尤其知道自己肩上承担的责任的分量。<br>庄子却从更广远的视野，看到了一个人的渺小，哪怕这个人是一个旷世的大哲人。<br>在无穷无尽的时间里，人命何等危浅。<br>在无边无际的空间里，人生何等渺小。<br>孔子看到了，一人的生死，牵动着时代和文化。<br>庄子看到了，一人的生死，无损于宇宙和世界。<br>唉，说到这里，当然要说说庄周梦蝶——这是庄子一生中最为神奇的一个瞬间——这个美丽的故事，感动了所有的中国人，它里面包含着对人生的了悟与感伤，它是哲学，也是诗，它把我们带到世界的深处，带到我们生命的深处——<br>昔者庄周梦为胡蝶，栩栩然胡蝶也，自喻适志与，不知周也。俄然觉，则蘧蘧然周也。不知周之梦为胡蝶与？胡蝶之梦为周与？周与胡蝶则必有分矣，此之谓物化。<br>原来，我们衷心仰慕的大哲人，庄子，也就是这个世界某一角落，一个蝴蝶的一个不经意的梦。<br>这个蝴蝶在山谷间，飞来飞去，飞累了，落到一树花枝上，睡着了，做了一个梦。<br>于是，庄子来到了人间。<br>现在，大概是一阵风来，花枝颤抖，蝴蝶醒了，庄子在人间消失了。<br>一切都在一瞬间。我们还在诧异中——<br>刚才，是蝴蝶梦着庄周；还是，此刻，是庄周梦着蝴蝶？<br>突然，我们惊觉：此刻的我们，如此执着、孜孜矻矻的我们，我们的形体与角色，是真实的还是另外一个什么东西的一场梦？当我们醒来，我们大觉之时，会发现我们是什么东西？或者，不是什么东西？  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;诸子的那些瞬间&quot;&gt;&lt;a href=&quot;#诸子的那些瞬间&quot; class=&quot;headerlink&quot; title=&quot;诸子的那些瞬间&quot;&gt;&lt;/a&gt;诸子的那些瞬间&lt;/h2&gt;&lt;p&gt;鲍鹏山 著&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;导读&lt;br&gt;推开历史的窗户，中国的一个</summary>
      
    
    
    
    
    <category term="杂文" scheme="https://boneink.github.io/tags/%E6%9D%82%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>云计算实验8</title>
    <link href="https://boneink.github.io/2019/05/26/%E4%BA%91%E8%AE%A1%E7%AE%97%20%E5%AE%9E%E9%AA%8C8/"/>
    <id>https://boneink.github.io/2019/05/26/%E4%BA%91%E8%AE%A1%E7%AE%97%20%E5%AE%9E%E9%AA%8C8/</id>
    <published>2019-05-26T04:00:00.000Z</published>
    <updated>2019-05-26T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LAB-8"><a href="#LAB-8" class="headerlink" title="LAB 8"></a>LAB 8</h2><hr><h4 id="Name"><a href="#Name" class="headerlink" title="Name:"></a>Name:</h4><p>  Introduction to Cloud Computing– Cloudlet</p><h3 id="Target"><a href="#Target" class="headerlink" title="Target:"></a>Target:</h3><ul><li>Understanding the concept of Cloudlet Model </li><li>Testing the cloudlet demo in your docker environment </li><li>Wring your own report on experiencing the demo</li></ul><ol><li>安装基础镜像<br> google 官方推荐使用 ubuntu 14.04 来进行编译： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu:14.04 </span><br></pre></td></tr></table></figure> 然后使用这个镜像启动一个容器： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v ~/data:/home/data ubuntu:14.04 /bin/bash </span><br></pre></td></tr></table></figure> 启动容器之后执行下面这个命令来进入交互环境: <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it d9bcf2da1d4b /bin/bash </span><br></pre></td></tr></table></figure></li><li>安装编译工具<br> 添加64位系统对32位的支持：<br> 检查是否已经支持 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dpkg --print-architecture # 若支持，输出 amd64 </span><br><span class="line">dpkg --print-foreign-architectures # 若支持，输出 i386 </span><br></pre></td></tr></table></figure> 手动开启支持 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg --add-architecture i386 apt-get update apt-get upgrade </span><br></pre></td></tr></table></figure> 安装32位支持库<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install lib32z1 lib32ncurses5 lib32bz2-1.0 </span><br></pre></td></tr></table></figure><br> 添加编译Android源码需要的依赖 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apt-get install gcc-multilib g++-multilib build-essential </span><br><span class="line">apt-get install git-core gnupg bison flex gperf pngcrush bc zip curl lzop </span><br><span class="line">apt-get install schedtool libxml2 libxml2-utils xsltproc squashfs-tools </span><br><span class="line">apt-get install libesd0-dev libsdl1.2-dev libwxgtk2.8-dev libswitch-perl </span><br><span class="line">apt-get install libssl1.0.0 libssl-dev lib32readline-gplv2-dev libncurses5-dev </span><br></pre></td></tr></table></figure> 安装 jdk 在宿主机上操作，从 oracle 官网下载 jdk1.6， 放到 ~&#x2F;data 目录下，因为我们已经把 data 目录挂载到容器了，接 下来在容器里面操作 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+x jdk-6u45-linux-x64.bin ./jdk-6u45-linux-x64.bin mkdir -p /usr/lib/jvm mv jdk1.6.0_45 /usr/lib/jvm </span><br></pre></td></tr></table></figure></li><li>不使用 root 用户进行编译<br> 默认情况下，容器是root用户进行登录的，这种情况下编译输出目录out及其子目录是 root 用户权限的。这样我 们要在宿主机上修改这个目录的话，就比较麻烦了。我们可以在 docker 里面新创建一个用户，一般来说第一个 非 root 用户的 uid 及gid 都是1000， 我们在宿主机上的 uid 和 gid 也是1000。我们可以用这个命令来查看用户的 uid 信息： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">ubuntu@boneink~/data/android_source$ </span><span class="language-bash"><span class="built_in">id</span> deep</span> </span><br><span class="line">uid=1000(deep) gid=1000(deep) 组=1000(deep),7(lp),27(sudo),100(users),109(netdev),113( </span><br><span class="line">deep@boneink:~/data/android_source$ </span><br></pre></td></tr></table></figure> 我们在容器里面执行以下命令来创建新用户 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd -d /home/build -m build </span><br><span class="line">passwd build </span><br></pre></td></tr></table></figure> 然后查看一下新建用户的 uid <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id build </span><br></pre></td></tr></table></figure> 发现 build 用户的uid和gid的确也是 1000。linux 的文件权限其实是指定给 uid,gid 的，也就是说只要我们容器里 面的 uid 和gid 与宿主机的相同，那我们在容器里面创建的文件在宿主机也是可以随意编辑的。 以指定用户进入容器: 当前的容器还是以 root 用户登录的，我们先退出来，然后执行以下命令 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it -u 1000 479a114fe8a7 /bin/bash </span><br></pre></td></tr></table></figure> 我们在 build 用户目录新建一个目录用来挂载 android 源码。 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd mkdir android_source </span><br></pre></td></tr></table></figure> 然后再设置 <code>JAVA_HOME</code>, <code>PATH</code> 就行了。 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim .bashrc </span><br></pre></td></tr></table></figure> 加上两行配置 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/lib/jvm/jdk1.6.0_45 </span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH </span><br></pre></td></tr></table></figure> 至此所需要的编译环境就已经配置完成了。<br> 提交容器保存为镜像: <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -m &quot;aosp build env&quot; d9bcf2da1d4b aosp_build:V1.0</span><br></pre></td></tr></table></figure> 使用镜像编译Android系统源码: 在宿主机上，创建源码目录 <code>/home/deep/Android/source</code> 目录，并放入Android系统源码。 然后执行以下命令，创建新容器<br> 进入 android 源码目录，按照 android 的标准编译步骤进行编译. <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /home/builder/android_source/aosp_android4.4 source build/envsetup.sh make -j8 </span><br></pre></td></tr></table></figure></li><li>部署demo服务器 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /home/deep/Android/source:/home/builder/android_source aosp_build:V1</span><br></pre></td></tr></table></figure> 按照指南将qcow2映像导入正在运行的OpenStack 。 启动该实例。FaceSwap服务器将在启动时自动启动。 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server/start_demo.sh </span><br></pre></td></tr></table></figure> 实例完全启动后，将FaceSwap客户端连接到它以供使用。</li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>Elijah.cs.cmu.edu. (2019). Elijah Home. [online] Available at: <a href="http://elijah.cs.cmu.edu/">http://elijah.cs.cmu.edu/</a> [Accessed 25 May 2019].<br>GitHub. (2019). cmusatyalab&#x2F;faceswap. [online] Available at: <a href="https://github.com/cmusatyalab/faceswap">https://github.com/cmusatyalab/faceswap</a> [Accessed 25 May 2019].<br>Cmusatyalab.github.io. (2019). FaceSwap Documentaon. [online] Available at: <a href="https://cmusatyalab.github.io/faceswap/">https://cmusatyalab.github.io/faceswap/</a> [Accessed 25 May 2019].</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;LAB-8&quot;&gt;&lt;a href=&quot;#LAB-8&quot; class=&quot;headerlink&quot; title=&quot;LAB 8&quot;&gt;&lt;/a&gt;LAB 8&lt;/h2&gt;&lt;hr&gt;
&lt;h4 id=&quot;Name&quot;&gt;&lt;a href=&quot;#Name&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    
    <category term="云计算" scheme="https://boneink.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="实验作业" scheme="https://boneink.github.io/tags/%E5%AE%9E%E9%AA%8C%E4%BD%9C%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>云计算期末</title>
    <link href="https://boneink.github.io/2019/05/21/%E4%BA%91%E8%AE%A1%E7%AE%97%20%E6%9C%9F%E6%9C%AB%E4%BD%9C%E4%B8%9A/"/>
    <id>https://boneink.github.io/2019/05/21/%E4%BA%91%E8%AE%A1%E7%AE%97%20%E6%9C%9F%E6%9C%AB%E4%BD%9C%E4%B8%9A/</id>
    <published>2019-05-21T04:00:00.000Z</published>
    <updated>2019-05-21T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="项目名称"><a href="#项目名称" class="headerlink" title="项目名称"></a>项目名称</h3><p>  基于Socket.io通信的《你画我猜》docker镜像制作</p><h3 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h3><ol><li>原有项目已实现： <ul><li>画笔 </li><li>关键词 </li><li>计时</li></ul></li><li>本次实验实现 <ul><li>添加聊天功能 </li><li>添加弹幕 </li><li>UI等细节优化 </li><li>对应docker镜像的制作和上传</li></ul></li></ol><h3 id="项目实现"><a href="#项目实现" class="headerlink" title="项目实现"></a>项目实现</h3><ol><li>聊天功能： <ul><li>通过在页面内添加消息框的div及input标签用于信息显示及发送，然后在负责客户端的io.js中添加信息传 输代码： <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">socket.<span class="title function_">on</span>(<span class="string">&#x27;server msg&#x27;</span>, <span class="keyword">function</span> (<span class="params">data</span>) &#123;      </span><br><span class="line"><span class="keyword">var</span> ele = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>);      </span><br><span class="line">ele.<span class="property">innerHTML</span> = data;    </span><br><span class="line">msg.<span class="title function_">appendChild</span>(ele);    </span><br><span class="line">msg.<span class="property">scrollTop</span> = msg.<span class="property">scrollHeight</span>; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>在负责客户端的service.js中添加信息传输代码，关键部分如下： <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">io.<span class="property">sockets</span>.<span class="title function_">on</span>(<span class="string">&#x27;connection&#x27;</span>, <span class="keyword">function</span> (<span class="params">socket</span>) &#123;      </span><br><span class="line">socket.<span class="title function_">on</span>(<span class="string">&#x27;login&#x27;</span>, <span class="keyword">function</span> (<span class="params">name</span>) &#123;  </span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">on</span>(<span class="string">&#x27;client msg&#x27;</span>, <span class="keyword">function</span> (<span class="params">msg</span>) &#123;      </span><br><span class="line"><span class="keyword">if</span> (!<span class="title function_">doCmd</span>(msg, <span class="variable language_">this</span>)) &#123;          </span><br><span class="line">msg = escapeHTML(msg);          </span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Game</span>.<span class="property">player</span> &amp;&amp; <span class="title class_">Game</span>.<span class="property">player</span>.<span class="property">word</span>.<span class="property">word</span> === msg) &#123;              <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">prev</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">prev</span>.<span class="property">player</span> === <span class="title class_">Game</span>.<span class="property">player</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">prev</span>.<span class="property">word</span>;                 </span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">emit</span>(<span class="string">&#x27;server msg&#x27;</span>, <span class="string">&quot;您已经正确回答过了！&quot;</span>);                  <span class="keyword">return</span>;              </span><br><span class="line">&#125;              </span><br><span class="line">tops.<span class="title function_">set</span>(<span class="variable language_">this</span>.<span class="property">id</span>.<span class="title function_">substring</span>(<span class="number">2</span>), <span class="variable language_">this</span>.<span class="property">name</span>, tops.<span class="title function_">get</span>(<span class="variable language_">this</span>.<span class="property">id</span>.<span class="property">substring</span>             </span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">emit</span>(<span class="string">&#x27;server msg&#x27;</span>, <span class="string">&quot;真棒！回答正确！&quot;</span>);             </span><br><span class="line"><span class="variable language_">this</span>.<span class="property">broadcast</span>.<span class="title function_">emit</span>(<span class="string">&#x27;server msg&#x27;</span>, <span class="string">&quot;恭喜！&quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; 回答正确！             </span></span><br><span class="line"><span class="string">var j = JSON.stringify(tops);             </span></span><br><span class="line"><span class="string">       this.broadcast.emit(&#x27;tops&#x27;, j);             </span></span><br><span class="line"><span class="string">       this.emit(&#x27;tops&#x27;, j);              </span></span><br><span class="line"><span class="string">       this.prev = &#123;                  </span></span><br><span class="line"><span class="string">       player: Game.player,                  </span></span><br><span class="line"><span class="string">       word: msg              </span></span><br><span class="line"><span class="string">       &#125;;              </span></span><br><span class="line"><span class="string">       return;          </span></span><br><span class="line"><span class="string">       &#125;          </span></span><br><span class="line"><span class="string">       var date = new Date().format(&#x27;yyyy-MM-dd hh:mm:ss&#x27;);          </span></span><br><span class="line"><span class="string">       this.emit(&#x27;server msg&#x27;, date + &#x27;&lt;br&gt;&#x27; + this.name + &#x27; 说: &#x27; + msg);          </span></span><br><span class="line"><span class="string">       this.broadcast.emit(&#x27;server msg&#x27;, date + &#x27;&lt;br&gt;&#x27; + this.name + &#x27; 说: &#x27; +      </span></span><br><span class="line"><span class="string">       &#125;  </span></span><br><span class="line"><span class="string">       &#125;);  </span></span><br></pre></td></tr></table></figure></li><li>在客户端的js.js部分通过判断发言者身份来进行发言权限的管理，主要代码如下： <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;     </span><br><span class="line"><span class="title class_">Ctl</span>.<span class="title function_">init</span>();     </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resize</span>(<span class="params"></span>) &#123;         </span><br><span class="line">canvas.<span class="property">width</span> = canvas.<span class="property">parentElement</span>.<span class="property">clientWidth</span>;         </span><br><span class="line">canvas.<span class="property">paths</span> = canvas.<span class="property">pts</span> = [];         </span><br><span class="line">socket.<span class="title function_">emit</span>(<span class="string">&#x27;repaint&#x27;</span>);     </span><br><span class="line">&#125;     </span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>,resize);     </span><br><span class="line"><span class="title function_">resize</span>();     </span><br><span class="line">input.<span class="property">onkeydown</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;         </span><br><span class="line"><span class="keyword">if</span>(e.<span class="property">keyCode</span> === <span class="number">13</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">value</span>!=<span class="string">&#x27;&#x27;</span>)&#123; </span><br><span class="line"><span class="keyword">if</span>(canvas.<span class="property">isMe</span>)&#123;                 </span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;绘图者不能够发送消息！&#x27;</span>);                 </span><br><span class="line"><span class="keyword">return</span>;             </span><br><span class="line">&#125;             </span><br><span class="line">socket.<span class="title function_">emit</span>(<span class="string">&#x27;client msg&#x27;</span>,<span class="variable language_">this</span>.<span class="property">value</span>);             </span><br><span class="line">socket.<span class="title function_">emit</span>(<span class="string">&quot;barrage&quot;</span>, <span class="variable language_">this</span>.<span class="property">value</span>);             </span><br><span class="line"><span class="variable language_">this</span>.<span class="property">value</span> = <span class="string">&#x27;&#x27;</span>;         </span><br><span class="line">&#125;     </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#btns&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span> (<span class="params">e</span>) &#123;         </span><br><span class="line"><span class="keyword">if</span>(e.<span class="property">target</span>.<span class="property">classList</span>.<span class="title function_">contains</span>(<span class="string">&#x27;btn-active-able&#x27;</span>))&#123;             </span><br><span class="line"><span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">prevBtn</span>)&#123;                 </span><br><span class="line"><span class="variable language_">this</span>.<span class="property">prevBtn</span>.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;active&#x27;</span>)             </span><br><span class="line">&#125;             </span><br><span class="line">e.<span class="property">target</span>.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;active&#x27;</span>)             </span><br><span class="line"><span class="variable language_">this</span>.<span class="property">prevBtn</span> = e.<span class="property">target</span>;         </span><br><span class="line">&#125;     </span><br><span class="line">&#125;,</span><br><span class="line"><span class="literal">true</span>); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ul></li><li>添加弹幕<br> 本项目使用<code>Jquery.barrager.js</code>插件实现弹幕功能 <ul><li>主页添加弹幕区域： <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;barrage-body&quot;</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;online_count&quot;</span> <span class="attr">class</span>=<span class="string">&quot;online_count&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br></pre></td></tr></table></figure></li><li>在jquery.barrager.js中进行弹幕样式的相关设置，主要代码如下： <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.fn.<span class="property">barrager</span> = <span class="keyword">function</span> (<span class="params">barrage</span>) &#123;     </span><br><span class="line">barrage = $.<span class="title function_">extend</span>(&#123;         </span><br><span class="line"><span class="attr">close</span>: <span class="literal">true</span>,         </span><br><span class="line"><span class="attr">bottom</span>: <span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">1000</span>+<span class="number">50</span>,         </span><br><span class="line"><span class="attr">max</span>: <span class="number">10</span>,         </span><br><span class="line"><span class="attr">speed</span>: <span class="number">8</span>,         </span><br><span class="line"><span class="attr">color</span>: <span class="string">&#x27;#fff&#x27;</span>,         </span><br><span class="line"><span class="attr">old_ie_color</span>: <span class="string">&#x27;#000000&#x27;</span>         </span><br><span class="line">&#125;, barrage || &#123;&#125;);  &#125; </span><br></pre></td></tr></table></figure></li><li>在负责客户端的io.js进行数据传输设置，主要代码如下： <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">socket.<span class="title function_">on</span>(<span class="string">&#x27;barrage&#x27;</span>, <span class="keyword">function</span> (<span class="params">msg</span>) &#123;     </span><br><span class="line"><span class="keyword">var</span> item = &#123;         </span><br><span class="line"><span class="string">&#x27;img&#x27;</span>: <span class="string">&#x27;2.jpg&#x27;</span>,         </span><br><span class="line"><span class="string">&#x27;info&#x27;</span>: msg,         </span><br><span class="line"><span class="string">&#x27;close&#x27;</span>: <span class="literal">false</span>,         </span><br><span class="line"><span class="string">&#x27;speed&#x27;</span>: <span class="number">16</span>         </span><br><span class="line">&#125;;         </span><br><span class="line">$(<span class="string">&#x27;.barrage-body&#x27;</span>).<span class="title function_">barrager</span>(item); </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure></li><li>在负责服务端的service.js中进行数据传输设置，主要代码如下： <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">io.<span class="title function_">on</span>(<span class="string">&#x27;connection&#x27;</span>, <span class="keyword">function</span> (<span class="params">socket</span>) &#123;     <span class="comment">// 接收弹幕消息     </span></span><br><span class="line">socket.<span class="title function_">on</span>(<span class="string">&#x27;barrage&#x27;</span>, <span class="keyword">function</span> (<span class="params">msg</span>) &#123;         </span><br><span class="line"><span class="comment">// console.log(&#x27;message:&#x27; + msg);         </span></span><br><span class="line"><span class="comment">// 过滤xssvar          </span></span><br><span class="line">msg = <span class="title function_">xss</span>(msg);         </span><br><span class="line"><span class="keyword">if</span> (!<span class="title function_">doCmd</span>(msg, <span class="variable language_">this</span>)) &#123;             </span><br><span class="line">msg = escapeHTML(msg);             </span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Game</span>.<span class="property">player</span> &amp;&amp; <span class="title class_">Game</span>.<span class="property">player</span>.<span class="property">word</span>.<span class="property">word</span> === msg) &#123;                 <span class="keyword">return</span>;             </span><br><span class="line">&#125;             </span><br><span class="line">io.<span class="title function_">emit</span>(<span class="string">&#x27;barrage&#x27;</span>, msg);          </span><br><span class="line">&#125;      </span><br><span class="line">&#125;);  </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure></li></ul></li><li>UI等细节优化<br> 本部分代码逻辑较为简单，主要为UI布局及背景、音效添加等，此处不再叙。 </li><li>docker制作： <ul><li>下载 node 镜像 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull node </span><br></pre></td></tr></table></figure></li><li>添加 Dockerfile <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM node:latest #  将Dockerfile当前目录下所有文件拷贝至容器内项目目录并安装项目依赖 </span><br><span class="line">ADD . /app/ WORKDIR /app RUN npm install </span><br><span class="line"># 容器对外暴露的端口号，要和node项目配置的端口号一致 </span><br><span class="line">EXPOSE 4000 </span><br><span class="line"># 容器启动时执行的命令 </span><br><span class="line">CMD [ &quot;node&quot;, &quot;server/server.js&quot; ] </span><br></pre></td></tr></table></figure></li><li>构建dcoker镜像 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t draw_something . </span><br></pre></td></tr></table></figure></li><li>启动容器 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name drawsometing -p 80:4000 draw_someting </span><br></pre></td></tr></table></figure></li><li>测试：访问主机相应端口号 </li><li>上传docker镜像 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker tag 07 boneink/paint-someting </span><br><span class="line">docker push boneink/paint-someting</span><br></pre></td></tr></table></figure></li><li>Docker镜像项目地址 <a href="https://hub.docker.com/r/boneink/paint-someng">https://hub.docker.com/r/boneink/paint-someng</a><br>  或者通过命令获取镜像：  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull boneink/paint-someting </span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>Socket.IO. (2019). Socket.IO — Docs. [online] Available at: <a href="https://socket.io/docs/">https://socket.io/docs/</a> [Accessed 21 May 2019].<br>Yaseng.org. (2019). Jquery.barrager.js 专业的网页弹幕插件. [online] Available at: <a href="https://yaseng.org/jquery.barrager.js/">https://yaseng.org/jquery.barrager.js/</a> [Accessed 21 May 2019].<br>Docker Documentaon. (2019). Docker Documentaon. [online] Available at: <a href="https://docs.docker.com/">https://docs.docker.com/</a> [Accessed 21 May 2019].</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;项目名称&quot;&gt;&lt;a href=&quot;#项目名称&quot; class=&quot;headerlink&quot; title=&quot;项目名称&quot;&gt;&lt;/a&gt;项目名称&lt;/h3&gt;&lt;p&gt;  基于Socket.io通信的《你画我猜》docker镜像制作&lt;/p&gt;
&lt;h3 id=&quot;项目介绍&quot;&gt;&lt;a href=&quot;#项</summary>
      
    
    
    
    
    <category term="作业" scheme="https://boneink.github.io/tags/%E4%BD%9C%E4%B8%9A/"/>
    
    <category term="云计算" scheme="https://boneink.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>云计算作业5</title>
    <link href="https://boneink.github.io/2019/05/20/%E4%BA%91%E8%AE%A1%E7%AE%97%20%E4%BD%9C%E4%B8%9A5/"/>
    <id>https://boneink.github.io/2019/05/20/%E4%BA%91%E8%AE%A1%E7%AE%97%20%E4%BD%9C%E4%B8%9A5/</id>
    <published>2019-05-20T04:00:00.000Z</published>
    <updated>2019-05-20T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Homework-5"><a href="#Homework-5" class="headerlink" title="Homework 5"></a>Homework 5</h2><hr><h3 id="Assignment"><a href="#Assignment" class="headerlink" title="Assignment"></a>Assignment</h3><h4 id="Storage-for-Data-Intensive-Services"><a href="#Storage-for-Data-Intensive-Services" class="headerlink" title="Storage for Data Intensive Services"></a>Storage for Data Intensive Services</h4><ol><li><p>HDFS is implemented as a user-level ﬁle system vs an in-kernel ﬁle-system. (a) What is the advantage of this in the context of Hadoop?</p><blockquote><p>HDFS (Hadoop Distributed File System) is a unique design that provides storage for extremely large ﬁles with streaming data access paern and it runs on commodity hardware. Here are some advantages:</p><ul><li><strong>Extremely large ﬁles</strong>: HDFS is sutable for data in range of petabytes(1000 TB).</li><li><strong>Streaming Data Access Paern</strong>: HDFS is designed on principle of write-once and read-many-mes. Once data is wrien large porons of dataset can be processed any number mes.</li><li><strong>Commodity hardware</strong>: Hardware that is inexpensive and easily available in the market. This is one of feature which specially disnguishes HDFS from other ﬁle system.</li></ul></blockquote></li><li><p>The output of a Mapper is wrien into the local ﬁlesystem instead of the global ﬁlesystem. Why? Your answer should explain both why wring into the global ﬁle system would be undesirable as well as why it would be of minimal beneﬁt.</p><blockquote><ol><li>Wring into the local ﬁlesystem reduces network traﬃc usage as the reducer may run on the same machine as the output so copying not required.</li><li>wring to hdfs is not like wring to local disk. It’s a more involved process with namenode assuring that at least dfs.replication.min copies are wrien to hdfs. And namenode will also run a background thread to make addional copies for under replicated blocks.Suppose, the user kills the job in between or jobs just fail. There will be lots of intermediate ﬁles sing on hdfs for no reason which you will have to delete manually. And if this process happens too many mes, your cluster’s perform and will degrade. Hdfs is opmized for appending and not frequent deleng .Also, during map phase , if the job fails, it performs a cleanup before exing. If it were hdfs, the deleon process would require namenode to send a block deleon message to appropriate datanodes, which will cause invalidaon of that block and it’s removal from blocksMap . So much operaon involved just for a failed cleanup and for no gain.</li></ol></blockquote></li><li><p>Why does Hadoop sort records en route to a Reducer? How would it aﬀect things if these records were processed by the Reducer in the order in which they were received from the various Mappers?</p><blockquote><p>Within a given paron, the intermediate key&#x2F;value pairs are processed in increasing key order. This ordering guarantee makes it easy to generate a sorted output ﬁle per paron, which is useful when the output ﬁle format needs to support eﬃcient random access lookups by key, or users of the output ﬁnd it convenient to have the data sorted. Without distribung by key, joining data in such a way would require painfully complex logic involving some kind of intermediary data storage &#x2F; caching.</p></blockquote></li><li><p>How is the failure of a Mapper or Reduce managed?</p><blockquote><ol><li>In case of a parcular task failure, Hadoop iniates another computaonal resource in order to perform failed map or reduce tasks.</li><li>By default, if any task fails four mes (or whatever you conﬁgure in those properes), the whole job would be considered as failed. In short shuffle and sort being a part of reducer, it would only iniate aempt to rerun reducer task. Map tasks would not be re-run as they are considered as completed.When it comes to failure of shuffle and sort process, it is basically a failure in the parcular node where reducer task has failed and it would be set to run afresh in another resource (btw, reducer phase begin with shuﬄe and sort process).</li></ol></blockquote></li><li><p>In a typical Map-Reduce graph algorithm, what data structure is used to represent the graph? Why?</p><blockquote><p>Map-Reduce graph algorithm represent the graph by valur-key ：</p><ol><li>Could quickly ﬁnd the data within the database.</li><li>Because oponal values are not represented by placeholders or input parameters, as in most RDBs, key-value databases oen use far less memory to store the same database, which can lead to large performance gains in certain workloads.</li><li>Supporng high concurrency</li></ol></blockquote></li><li><p>In a typical Map-Reduce graph algorithm, how many Map-Reduce phases are typically necessary before the graph can be traversed? Why?</p><blockquote><p>A MapReduce framework (or system) is usually composed of three operaons (or steps):<br><strong>Map</strong>: each worker node applies the map funcon to the local data, and writes the<br>output to a temporary storage. A master node ensures that only one copy of redundant input data is processed.<br><strong>Shuﬄe</strong>: worker nodes redistribute data based on the output keys (produced by the map funcon), such that all data belonging to one key is located on the same worker node.<br><strong>Reduce</strong>: worker nodes now process each group of output data, per key, in parallel.</p></blockquote></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Homework-5&quot;&gt;&lt;a href=&quot;#Homework-5&quot; class=&quot;headerlink&quot; title=&quot;Homework 5&quot;&gt;&lt;/a&gt;Homework 5&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;Assignment&quot;&gt;&lt;a href=&quot;#Assign</summary>
      
    
    
    
    
    <category term="作业" scheme="https://boneink.github.io/tags/%E4%BD%9C%E4%B8%9A/"/>
    
    <category term="云计算" scheme="https://boneink.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
</feed>
