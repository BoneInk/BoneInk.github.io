<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>临渊羡鱼</title>
  
  
  <link href="https://boneink.github.io/atom.xml" rel="self"/>
  
  <link href="https://boneink.github.io/"/>
  <updated>2022-08-23T04:00:00.000Z</updated>
  <id>https://boneink.github.io/</id>
  
  <author>
    <name>BoneInk</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WhiteRabbitTracke项目运行和问题</title>
    <link href="https://boneink.github.io/2022/08/23/WhiteRabbitTracker%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C%E5%92%8C%E9%97%AE%E9%A2%98/"/>
    <id>https://boneink.github.io/2022/08/23/WhiteRabbitTracker%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C%E5%92%8C%E9%97%AE%E9%A2%98/</id>
    <published>2022-08-23T04:00:00.000Z</published>
    <updated>2022-08-23T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WhiteRabbitTracke项目运行和问题"><a href="#WhiteRabbitTracke项目运行和问题" class="headerlink" title="WhiteRabbitTracke项目运行和问题"></a>WhiteRabbitTracke项目运行和问题</h2><hr><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><ul><li><p>虚拟机镜像选择：</p><p>编译阶段使用Windows 10 x86 1709及之后的镜像。</p><p>运行阶段使用Windows 7 x86 sp1。</p></li><li><p>拉取项目：</p><p>采用git指令直接拉取包含子项目在内的所有内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recursive https://github.com/AndreaNaspi/WhiteRabbitTracker.githttps://github.com/AndreaNaspi/WhiteRabbitTracker.git</span><br></pre></td></tr></table></figure><p>由于网络原因，可能无法拉取，因此可以手动下载解压：</p><p>主项目：<a href="https://github.com/AndreaNaspi/WhiteRabbitTracker">GitHub - AndreaNaspi&#x2F;WhiteRabbitTracker: WhiteRabbitTracker: Analyzing malware evasions with information flow tracking</a></p><p>子项目：<a href="https://github.com/zyantific/zydis/tree/564f0b843ca28b7b9b29dabfc2da1ae6abc9fee9">GitHub - zyantific&#x2F;zydis at 564f0b843ca28b7b9b29dabfc2da1ae6abc9fee9</a></p><p>zydis的子项目：<a href="https://github.com/zyantific/zycore-c/tree/0c372cdefe799e99812c008a0b74537bfa5fe077">GitHub - zyantific&#x2F;zycore-c at 0c372cdefe799e99812c008a0b74537bfa5fe077</a></p><p>之后将zydis放置于<code>WhiteRabbitTracker/deps/</code>下，将zycore放置于<code>WhiteRabbitTracker/deps/zydis/dependencies/</code>下即可。</p></li><li><p>配置相关环境：</p><p>虽然zydis号称几乎不需要任何额外的库，但是在编译时一些基础的工具时必要的。</p><p>安装以下工具：<code>Cmake</code>,<code>Visual Studio x86 2019</code>(2017也可以，对应的SDK和WDK最好要与之对应)，visual studio 2019对应的<code>SDK</code>和<code>WDK</code>（也可以不对应，但是SDK和WDK版本一定要一致，且一定要对应Windows 10 1709之后的版本，同时SDK安装时后会提示安装对应的Visual Studio扩展，一定要记得安装，否则VS无法检测到对应的WDK），额外安装<code>WDK 8.1</code>。</p><p>下载<code>Intel Pin v3.15</code>压缩文件，在C盘根目录创建<code>pin315</code>目录，将压缩文件内文件解压到改目录下，在环境配置中添加该目录。</p></li><li><p>编译项目：</p><p>首先要对<code>zydis</code>进行编译，用VS打开<code>zydis/msvc/</code>下的<code>Zydis.sln</code>，导入解决方案，检查所有项目的配置页的VS库版本号和WDK号是否正确或者满足，无误后，运行模式选择<code>Debug MT DLL</code>，(MT代表静态链接，会将所需的链接库都一次编译进来，否则后续可能会提示缺少必要组件，同时，最好选择用管理员权限打开VS，防止某些文件无法访问，DLL后缀代表生成DLL文件)，同时选择<code>Win32</code>，之后运行，默认会先编译Zydis和Zycore，生成必要的组件后，运行第一个示例。</p><p>完成后，会在<code>deps/zydis/msvc/bin/DebugX86</code>下找到<code>WhiteRabbitTracker</code>需要的<code>Zydis.dll</code>, <code>Zycore.dll</code>, <code>Zydis.lib</code> 和 <code>Zycore.li</code>，这代表编译没有问题。</p><p>同样的，用VS2019打开<code>WhiteRabbitTracker/solution.sln</code>,会提示升级库，WDK选择8.1。</p><p>如果编译提示找不到某些库，那就是WDK之类的地址没有对，修改根目录下的<code>Locals.props</code>，由于使用的是32位系统，因此不存在<code>Program Files (x86)</code>文件夹，仅有<code>Program Files</code>文件夹，所以需要修改<code>WinHPath</code>标签对应的地址。</p><p>编译成功后，在<code>pin</code>的目录下，可以找到<code>WhiteRabbitTracker.dll</code>文件。通过以下指令即可实现对软件的反逃逸。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Pin315\pin.exe -t WhiteRabbitTracker32.dll [options] -- &lt;file.exe&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="运行尝试："><a href="#运行尝试：" class="headerlink" title="运行尝试："></a>运行尝试：</h4><p>最好在Windows 7 sp1 x86下运行，将前一个虚拟机中<code>pin315</code>目录复制到新的虚拟机中即可使用。</p><p>同样的，使用指令对<code>pafish.exe</code>进行反逃逸，对比直接运行<code>patfish.exe</code>的结果，成功使之将虚拟机识别为真实环境。</p><p>    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;WhiteRabbitTracke项目运行和问题&quot;&gt;&lt;a href=&quot;#WhiteRabbitTracke项目运行和问题&quot; class=&quot;headerlink&quot; title=&quot;WhiteRabbitTracke项目运行和问题&quot;&gt;&lt;/a&gt;WhiteRabbitTra</summary>
      
    
    
    
    
    <category term="软件逃逸" scheme="https://boneink.github.io/tags/%E8%BD%AF%E4%BB%B6%E9%80%83%E9%80%B8/"/>
    
    <category term="IntelPin" scheme="https://boneink.github.io/tags/IntelPin/"/>
    
    <category term="恶意软件检测" scheme="https://boneink.github.io/tags/%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>挖矿样本特征总结</title>
    <link href="https://boneink.github.io/2022/06/27/%E6%8C%96%E7%9F%BF%E6%A0%B7%E6%9C%AC%E7%89%B9%E5%BE%81%E6%80%BB%E7%BB%93/"/>
    <id>https://boneink.github.io/2022/06/27/%E6%8C%96%E7%9F%BF%E6%A0%B7%E6%9C%AC%E7%89%B9%E5%BE%81%E6%80%BB%E7%BB%93/</id>
    <published>2022-06-27T04:00:00.000Z</published>
    <updated>2022-06-27T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、挖矿病毒的套路-https-zhuanlan-zhihu-com-p-164557943"><a href="#一、挖矿病毒的套路-https-zhuanlan-zhihu-com-p-164557943" class="headerlink" title="一、挖矿病毒的套路: https://zhuanlan.zhihu.com/p/164557943"></a>一、挖矿病毒的套路: <a href="https://zhuanlan.zhihu.com/p/164557943">https://zhuanlan.zhihu.com/p/164557943</a></h3><ol><li><p>DTStealer(又名“永恒之蓝下载器木马”)</p><ul><li><p>病毒运行后，除了执行挖矿行为，占用终端资源以外，还会窃取终端信息并回传服务器，并利用钓鱼邮件、SMBexec、WMIexec、常见漏洞等方式，在内、外网肆意传播。</p><p>该病毒内网传播方式较多，在部署火绒查杀后，还有被其他已经中毒终端攻击攻击的可能，出现火绒“文件实时监控”的查杀记录。</p></li><li><p>感染症状<br>如您的终端出现以下症状，极有可能感染了此病毒。<br>（1）出现以下名称的任务计划:<br>l Drivers<br>l WebServers<br>l DnsScan<br>l Bluetooths<br>l Credentials<br>l Rtsa·<br>l 00-00-00-00-00-00或??-??-??-??-??-??(MAC地址)<br>l Bluetea<br>l Blackball<br>（2）以下位置可能会生成的病毒文件:<br>l C:\Windows\temp\svchost.exe<br>l %AppData%\Microsoft\cred.ps1<br>l %AppData%\flashplayer.tmp<br>l %AppData%\Microsoft\Windows\StartMenu\Programs\Startup\FlashPlayer.lnk<br>（3）U盘内出现以下文件：<br>l blue3.bin<br>l blue6.bin<br>l (D-K)blue3.lnk<br>l (D-K)blue6.lnk<br>（4）火绒出现”隐藏执行PowerShell”、“利用PowerShell执行可疑脚本”等系统加固拦截<br><img src="https://pic2.zhimg.com/v2-8ac149f62555c15478d4565a9863bc75_b.jpg" alt="image"><br>（5)可能会出现的网址访问拦截:<br>l <a href="http://beahh.com/">http://beahh.com</a><br>l <a href="http://ackng.com/">http://ackng.com</a><br>l <a href="http://zer2.com/">http://zer2.com</a></p></li></ul></li><li><p>WannaMine</p><ul><li>该挖矿病毒于2017年底被发现，也是企业内较为常见的挖矿病毒、病毒运行后会扫描企业网络内是否启用了445端口的终端，并通过”永恒之蓝”漏洞在内网横向传播，感染更多终端进行挖矿。</li><li>感染症状<br>如果火绒“文件实时监控”拦截查杀以下目录内的“永恒之蓝”传播组件，则有可能感染了此病毒。<br>l C:\Windows\SpeechsTracing<br>l C:\Windows\NetworkDistribution<br>火绒”文件实时监控”查杀此挖矿程序：<br>l C:\Windows\SysWOW64\dllhostex.exe</li></ul></li><li><p>隐匿者(MyKings)</p><ul><li><p>隐匿者(MyKings)是由多个子僵尸网络构成的多重僵尸网络，除挖矿外，该僵尸网络还包含DDoS、Proxy、RAT等恶意功能。自2017年以来，该僵尸网络至今处于持续更新、传播的状态。</p><p>该病毒会感染MBR，在系统引导时进行加载，加载时机多早于正常的软件启动，成功加载后除了执行恶意行为外，还会对自身进行保护。</p></li><li><p>感染症状</p><p>终端被感染后，会出现以下特征：</p><p>（1）安全软件部署后，无法正常运行</p><p>l Sql Server日志内，出现大量”sa”账户登陆失败日志。</p><p>l Sql Server的作业内，出现异常定时作业。</p><p>（2）出现以下任务计划</p><p>l My</p><p>l Mysa</p><p>l ok</p><p>（3）出现以下文件：</p><p>l C:\Windows\debug\lsmo.exe</p><p>l C:\Windows\debug\lsmos.exe</p><p>l C:\Windows\debug\ok.dat</p><p>l C:\Windows\System32\ok.exe</p><p>l C:\Windows\temp\conhost.exe</p><p>l C:\Windows\System\msinfo.exe</p></li></ul></li><li><p>匿影挖矿</p><ul><li><p>匿影挖矿于2019年2月被发现，该病毒会利用大量网络上的公共资源(例如免费图床)存放病毒模块。在企业内，会利用”永恒之蓝”在内网横向传播，感染更多终端进行挖矿。病毒运行后，会利用驱动阻碍安全软件正常运行，并对自身进行保护。</p><p>该挖矿会利用驱动妨碍安全软件正常运行。</p></li><li><p>终端被感染后，出现以下文件：</p><p>l C:\Windows\Temp\retboolDriver.sys</p><p>l C:\Windows\Temp\FlrefoxDriver.sys</p><p>l C:\ProgramData\dll*</p><p>l C:\ProgramData\kuaizipUpdateChecker.dll</p><p>l C:\ProgramData\MS_17_010_Scan.exe</p><p>l C:\ProgramData\Microsoft\Chromme.exe</p><p>l C:\ProgramData\Flrefox.exe</p></li></ul></li><li><p>紫狐</p><ul><li><p>紫狐病毒最初发现于2018年，多年来一直保持活跃，除了挖矿外，该病毒还有流量暗刷、DDoS、盗号、恶意推广等恶意行为。并会通过软件捆绑、Ghost镜像、永恒之蓝、Sql暴破、服务漏洞等方式进行传播。</p><p>该病毒会通过驱动对自身进行保护。</p></li><li><p>感染症状</p><p>被感染终端，会出现以下文件：</p><p>l C:\Windows\System32\Ms********App.dll(*为任意字符)</p></li></ul></li></ol><h3 id="二、Avast-Q4-x2F-21-Threat-report：https-decoded-avast-io-threatresearch-avast-q4-21-threat-report"><a href="#二、Avast-Q4-x2F-21-Threat-report：https-decoded-avast-io-threatresearch-avast-q4-21-threat-report" class="headerlink" title="二、Avast Q4&#x2F;21 Threat report：https://decoded.avast.io/threatresearch/avast-q4-21-threat-report/"></a>二、Avast Q4&#x2F;21 Threat report：<a href="https://decoded.avast.io/threatresearch/avast-q4-21-threat-report/">https://decoded.avast.io/threatresearch/avast-q4-21-threat-report/</a></h3><p>CoinHelper是流行的硬币矿工之一，在 21 年第四季度仍然非常活跃，主要<code>Russia</code>针对<code>Ukraine</code>. 当恶意软件在受害者的系统上执行时，<code>CoinHelper</code>通过网络下载臭名昭著的 XMRig 矿工<code>Tor</code>并开始挖矿。除了硬币挖掘，CoinHelper 还收集有关受害者的各种信息，以识别他们的地理位置、他们安装的 AV 解决方案以及他们正在使用的硬件。</p><p>该恶意软件以捆绑的形式与许多流行的应用程序、破解软件（例如<code>MS Office</code>，游戏和游戏作弊程序（例如<code>Minecraft</code>and <code>Cyberpunk 2077</code>），甚至是干净的安装程序（例如<code>Google Chrome</code>or <code>AV products</code>）以及隐藏在 中<code>Windows 11 ISO image</code>，等等）一起传播。通过种子下载捆绑的应用程序也支持传播范围，进一步滥用了下载软件的非官方方式。</p><p>尽管我们观察到多种加密货币（包括以太坊或比特币）被配置为开采，但有一种特殊类型脱颖而出—— <code>Monero</code>. 尽管门罗币被设计为匿名的，但由于地址使用错误和矿池运作机制，我们能够更深入地了解恶意软件作者的门罗币挖矿操作，并发现总的货币收益CoinHelper<code>339,694.86 USD</code>截至 2021 年 11 月 29 日。</p><h3 id="三、关于CoinHelper（https-decoded-avast-io-janrubin-toss-a-coin-to-your-helper-）"><a href="#三、关于CoinHelper（https-decoded-avast-io-janrubin-toss-a-coin-to-your-helper-）" class="headerlink" title="三、关于CoinHelper（https://decoded.avast.io/janrubin/toss-a-coin-to-your-helper/）:"></a>三、关于CoinHelper（<a href="https://decoded.avast.io/janrubin/toss-a-coin-to-your-helper/%EF%BC%89">https://decoded.avast.io/janrubin/toss-a-coin-to-your-helper/）</a>:</h3><p>CoinHelper 大多与 WinRAR 和游戏秘籍等破解软件安装程序捆绑在一起。</p><p>其传播方式之一为通过MyKing的僵尸网络的剪切板窃取进行传播（<a href="https://decoded.avast.io/janrubin/the-king-is-dead-long-live-mykings/%EF%BC%89%E3%80%82">https://decoded.avast.io/janrubin/the-king-is-dead-long-live-mykings/）。</a></p><p>通过剪切板窃取，误导用户在下载软件时，使用被绑定了CoinHelper的软件，从而无意中执行该程序。</p><p>感染流程：</p><p><img src="https://decoded.avast.io/wp-content/uploads/sites/2/2021/11/image-29.png" alt="image"></p><ol><li><p>修复损坏的存档、执行第二阶段和确保持久性：</p><p>下载获得一个名称和图标均正常的exe文件（为一个已经编译的Autolt二进制文件）。</p><p>提取后，可以获得三个组件：</p><ul><li><code>asacpiex.dll</code>（一个损坏（修改）的 7zip 存档，带有恶意软件的第二阶段）</li><li><code>CL_Debug_Log.txt</code>（干净的 7zip 独立可执行文件）</li><li><code>glue\ChromeSetup.exe</code></li></ul><p>第一阶段还包含一个非常简单但有效的附加功能：攻击者收集有关受害者的信息，重点关注受害者的操作系统、安装的 RAM 数量、CPU 和显卡信息，以及系统上存在的安全解决方案。所有收集到的信息都被格式化并连接成一个字符串。</p><p>然后，该字符串通过 GET 请求以用户代理的形式发送到硬编码的 URL 地址。在我们的示例中，硬编码的 URL 看起来像<code>https://2no[.]co/1wbYc7</code>.</p></li><li><p>修复asacpiex.dll后，将其保存为CR_Debug_Log.txt到Temp文件夹中。</p><p>为了解压档案，恶意软件使用密码JDQJndnqwdnqw2139dn21n3b312idDQDB。这是这些 AutoIt dropper 最常用的密码。但是，它不是唯一的，到目前为止，我们还计算了两个额外的密码：</p><p>dkwqdqw9324328NDQDN@@!)(#($%&amp;^!ND21<br>jDWQJkdqkwdqo2m@mdwmsxPAS,sq%<br>解包显示两个附加文件：</p><p>32.exe<br>64.exe</p><p>根据操作系统的体系结构以及 AES 指令集是否可用，这些文件之一将被复制到<br><code>C:\Users\&lt;username&gt;\AppData\Roaming\Microsoft\Windows\Helper.exe</code><br>并执行（通过计划任务）。</p><p>这两个文件都再次编译了 AutoIt 脚本，具有通过 Tor 网络以硬币矿工的形式向受害者分发更多有效负载的功能。</p><p>尽管<code>Helper.exe</code>它是迄今为止最常见的恶意软件名称，但它并不是唯一的可能性。我们在野外看到的其他选项例如：</p><ul><li><code>fuck.exe</code></li><li><code>Helperr.exe</code></li><li><code>svchost.exe</code></li><li><code>System.exe</code></li><li><code>system32.exe</code></li><li><code>WAPDWA;DJ.exe</code></li><li><code>WorkerB.exe</code></li></ul><p>关于hepler.exe：主要目标是通过 Tor 网络将 XMRig 硬币矿工投放到受害者的系统上。</p><p><code>Helper.exe</code>还拥有许多其他功能，例如在受害者的 PC 上执行多个系统检查、将自身注入<code>%WINDIR%\System32\attrib.exe</code>系统二进制文件、检查系统的“空闲”以加强挖掘等等。</p><p>通过tor网络将coinminer下载到受感染系统的准备：</p><p>首先，该恶意软件包含两个额外的十六进制文件。第一个再次是一个干净的 7zip 二进制文件（但不同于<code>CL_Debug_Log.txt</code>），第二个是一个 7zip 存档，其中包含一个干净的 Tor 二进制文件和所属库：</p><ul><li><p><code>libcrypto-1_1-x64.dll</code></p></li><li><p><code>libevent-2-1-7.dll</code></p></li><li><p><code>libevent_core-2-1-7.dll</code></p></li><li><p><code>libevent_extra-2-1-7.dll</code></p><ul><li><code>libgcc_s_seh-1.dll</code></li></ul></li><li><p><code>libssl-1_1-x64.dll</code></p></li><li><p><code>libssp-0.dll</code></p><ul><li><code>libwinpthread-1.dll</code></li></ul></li><li><p><code>tor.exe</code></p></li><li><p><code>zlib1.dll</code></p></li></ul><p>tor解压密码：DxSqsNKKOxqPrM4Y3xeK<br>Tor 执行后，它会监听<code>9303</code>localhost ( <code>127.0.0.1</code>) 上的端口并等待请求。为防止此时出现混淆，请注意默认情况下此执行是隐藏的，因为<code>tor.exe</code>不应将其误认为是 Tor 浏览器。<code>tor.exe</code>是一个提供 Tor 路由的进程（没有 GUI）。在常见的 Tor 浏览器安装中，通常可以在<code>\&lt;Tor browser root folder&gt;\Browser\TorBrowser\Tor\tor.exe</code>.<br>该脚本还包含 C&amp;C 服务器的一些 Base64 编码的 Tor 地址，并尝试哪个是活着的。这是通过通过精心制作的请求（以十六进制形式）初始化 SOCKS4 通信来完成的：所需的服务器地址<br> <code>04 01 00 50 00 00 00 FF 00 $host 00</code><br> 该恶意脚本仅仅在收到一个包含了0x5A字节的标准协议响应后才会进一步与服务器进行通信。</p><p>恶意软件能从服务器上下载四个文件：</p><ul><li><code>public/upd.txt</code></li><li><code>public/64/64.txt</code>（或者<code>public/32/32.txt</code>如果使用脚本的“32 位变体”）</li><li><code>public/vc/amd.txt</code></li><li><code>public/vc/nvidia.txt</code></li></ul><p>文件<code>64.txt</code>( <code>32.txt</code>)、<code>amd.txt</code>和<code>nvidia.txt</code>都是 <strong>XMRig coinminers（编码和压缩），用于 CPU 或相应的 GPU 卡</strong>。</p><p>该<code>upd.txt</code>文件是一个纯文本文件，其中包含由<code>_</code>和<code>!</code>符号界定的版本号，例如<code>_!1!_</code>. 恶意软件会询问服务器当前版本多少，如果版本较新，则所有 coinminers都会更新。</p><p>矿工从 C&amp;C 下载为十六进制字符串，以常量字符串结尾<code>_!END!_</code>。移除结束存根并解码字符串后，我们得到一个 7zip 存档。我们可以使用<code>DxSqsNKKOxqPrM4Y3xeK</code>密码来解压它。</p><p>解压后，我们可以得到这些文件：</p><ul><li><code>SysBackup.txt</code>– 适用于 CPU 矿工（32 位和 64 位）</li><li><code>SysBackupA.txt</code>– 当还检测到 AMD GPU 时</li><li><code>SysBackupN.txt</code>– 当还检测到 NVIDIA GPU 时</li></ul><p>这些文件再次以十六进制形式出现，这次以<code>0x</code>前缀开头，没有结束存根。</p><hr><p><strong>挖矿</strong></p><p>挖矿（和 7zip 解包）是通过进程注入执行的。CPU 挖矿是通过注入新创建和挂起的 <code>%WINDIR%\System32\attrib.exe</code>.</p><p>所有其他组件的执行，例如 GPU 挖掘或从 Tor 下载的 coinminer 有效载荷的解包，都是通过注入自身来完成的，这意味着使用一个新的暂停实例<code>Helper.exe</code>进行注入。当支持 GPU 挖矿时，CPU 和 GPU 并行执行。</p><p>根据我们的研究，我们只看到 XMRig 被部署为最终的挖矿有效载荷。该恶意软件使用通用参数执行它，其中一种方法值得一提——为挖矿服务器“设置密码”的参数<code>-p</code>。在标准情况下，密码并不重要，因此恶意软件作者通常使用“ <code>x</code>”作为密码。然而，在这种情况下，恶意软件会生成受害者的 GUID 并将其附加到通常的“ <code>x</code>”中。</p><p><strong>持久性</strong></p><p>与第一阶段类似，在第二阶段开始时，会检查并在必要时创建特定的互斥锁：</p><ul><li><code>QPRZ1bWvXh</code></li><li><code>QPRZ1bWvXh2</code></li></ul><p>正如我们所看到的，与第一阶段（）相比，只有互斥锁中间的数字发生了变化<code>QPRZ3bWvXh</code>。第二个互斥体附加了一个常量<code>2</code>。我们也看到<code>QPRZ2bWvXh</code>了使用，再次更改中间数字。</p><p>为了尽可能长时间地隐藏，恶意软件使用原生 AutoIt <code>ProcessExists</code>功能检查多个进程，以检查任何正在运行的系统监控和分析工具：</p><ul><li><code>aida64.exe</code></li><li><code>AnVir.exe</code></li><li><code>anvir64.exe</code></li><li><code>GPU-Z.exe</code></li><li><code>HWiNFO32.exe</code></li><li><code>HWiNFO64.exe</code></li><li><code>i7RealTempGT.exe</code></li><li><code>OpenHardwareMonitor.exe</code></li><li><code>pchunter64.exe</code></li><li><code>perfmon.exe</code></li><li><code>ProcessHacker.exe</code></li><li><code>ProcessLasso.exe</code></li><li><code>procexp.exe</code></li><li><code>procexp64.exe</code></li><li><code>RealTemp.exe</code></li><li><code>RealTempGT.exe</code></li><li><code>speedfan.exe</code></li><li><code>SystemExplorer.exe</code></li><li><code>taskmgr.exe</code></li><li><code>VirusTotalUpload2.exe</code></li></ul><p>当发现该工具时，恶意软件会暂时禁用挖掘。有关运行硬币矿工的信息存储在两个文件中：</p><ul><li><code>mn.pid</code></li><li><code>gmn.pid</code></li></ul><p>该恶意软件还监控受害者目前是否实际使用他们的 PC。如果用户空闲了一段时间，在我们的特殊情况下为 3 分钟，当前的挖矿将终止，并执行一个新的挖矿过程并设置为在所有线程上利用 100% 的 CPU。此信息 (PID) 存储在名为<code>mn.ld</code>. 主动使用 PC 时，挖矿设置为可用性能的 50%。另一方面，GPU 挖掘<strong>仅</strong>在用户没有主动使用他们的 PC 时（2 分钟）执行。</p><p>该恶意软件还列出了系统上存在的所有控制台窗口，并找出那些可见性设置为隐藏的控制台窗口。如果找到这样的窗口并且它不属于 CoinHelper，则恶意软件会</p><p>程。</p><p><strong>数据收集和反病毒检查</strong></p><p>与之前的 AutoIt 阶段类似，它<code>Helper.exe</code>也会收集有关受感染系统的信息。</p><p>如果检测到任何在列表中的卡并且视频适配器名称与“ <code>Advanced Micro Devices, Inc.</code>”或“ <code>NVIDIA</code>”匹配，则恶意软件使用 XMRig 来利用 GPU 进行挖矿。</p></li><li><p>除了我们开始调查的 Yandex 磁盘存储之外，我们可以确认，传播 CoinHelper 的另一种重要方法是通过放置在专注于破解软件的互联网论坛上的恶意种子。</p></li></ol><h3 id="四、DirtyMoe-Introduction-and-General-Overview-of-Modularized-Malware：https-decoded-avast-io-martinchlumecky-dirtymoe-1"><a href="#四、DirtyMoe-Introduction-and-General-Overview-of-Modularized-Malware：https-decoded-avast-io-martinchlumecky-dirtymoe-1" class="headerlink" title="四、DirtyMoe: Introduction and General Overview of Modularized Malware：https://decoded.avast.io/martinchlumecky/dirtymoe-1/"></a>四、DirtyMoe: Introduction and General Overview of Modularized Malware：<a href="https://decoded.avast.io/martinchlumecky/dirtymoe-1/">https://decoded.avast.io/martinchlumecky/dirtymoe-1/</a></h3><ol><li><p>DirtyMoe整体介绍：</p><p>DirtyMoe 恶意软件使用了一个简单的想法，即如何同时<strong>模块化、不可检测和不可跟踪</strong>。该恶意软件的目标主要集中在 Cryptojacking 和 DDoS 攻击。DirtyMoe 通过 EternalBlue 和至少三个其他漏洞在系统级权限下作为 Windows 服务运行。特定功能由恶意软件作者远程控制，他们可以在几个小时内将数千个 DirtyMoe 实例重新配置为所需的功能。DirtyMoe 只是下载一个加密的有效载荷，对应于所需的功能，并将有效载荷注入自身。</p></li><li><p>感染方式：</p><p>攻击者通过端口扫描和漏洞开放数据库，发现并瞄准大量弱计算机。PurpleFox 是 DirtyMoe 常用的漏洞利用工具包。之后通过如EnternalBlue漏洞或 SMB 密码暴力破解 Windows 等获取管理员权限。</p><p>用 DirtyMoe 感染受害者机器的另一种方法是钓鱼电子邮件，其中包含可以通过 Internet Explorer 攻击目标的 URL。</p><p>此外，通过受感染的正常文件来部署也是方式之一。</p><p>当其中一个漏洞利用成功并获得系统权限时，DirtyMoe 可以安装在受害者的机器上。我们观察到 DirtyMoe 利用 Windows MSI Installer 来部署恶意软件。MSI Installer 提供了一种在多个平台和 Windows 版本上安装适当软件的简单方法。每个版本都需要安装文件和注册表项的不同位置。恶意软件作者可以轻松地为目标系统和平台设置 DirtyMoe 配置。</p><p>MSI Installer 通过 MSI 安装程序将受害者环境准备到适当的状态。他们专注于禁用反间谍软件和文件保护功能。此外，MSI 软件包使用一项系统功能，该功能有助于覆盖系统文件以进行恶意软件部署。</p><p>MSI Installer 通过修改注册表，修改系统文件从而避免自身被检测。</p><p>DirtyMoe 服务在 maware 部署期间在系统中注册。在开始时，该服务提取并加载 DirtyMoe 驱动程序以保护自己。加载驱动程序时，该服务会从文件系统和注册表中清除有关该驱动程序的所有证据。</p><p>DirtyMoe 恶意软件由两个进程组成，即<em>DirtyMoe Core</em>和<em>DirtyMoe Executioner</em>，由 DirtyMoe 服务创建，如果进程被创建和配置，则会自行终止。DirtyMoe 服务通过多个随时间终止的进程和线程创建<em>核心</em>和<em>执行器进程。</em>因此，取证和跟踪方法更加困难。</p></li><li><p>安装：</p><p><em>DirtyMoe Core</em>负责将恶意代码注入执行它的<em>DirtyMoe Executioner</em>。注入的代码，称为 MOE 对象或模块，是从 C&amp;C 服务器下载的。MOE 对象是<em>DirtyMoe Core</em>解密并注入<em>DirtyMoe Executioner</em>的加密 PE 文件。</p><p>此外，确定<em>DirtyMoe Core</em>介绍行为的初始有效负载由 MSI 安装程序部署为<code>sysupdate.log</code>文件。因此，<em>DirtyMoe Core</em>可以通过有效负载注入来更新或更改自己的功能。</p></li><li><p>控制和行动：</p><p><em>DirtyMoe Core</em>和<em>DirtyMoe Executioner</em>为恶意软件作者提供了一个接口，他们可以远程模块化 DirtyMoe 并通过 MOE 对象更改用途和配置。<em>DirtyMoe Core</em>与命令和控制 (C&amp;C) 服务器通信以获取攻击者命令。因此，整个复杂的层次结构高度模块化，配置和控制非常灵活。</p><p>C&amp;C 通信的阴险之处在于 DirtyMoe 没有使用固定的 IP 地址，而是实施了一种独特的机制来混淆最终的 C&amp;C 服务器地址。因此，不可能阻止受害者机器上的 C&amp;C 服务器，因为每次 C&amp;C 通信的服务器地址都不同。此外，该机制基于无法轻易阻止的 DNS 请求，因为它会影响日常通信。</p><blockquote><p>关于 DirtyMoe 模块化，如果恶意软件作者不需要进行有针对性的攻击，加密挖掘似乎是一种持续使用受害者机器的活动。因此，加密采矿是和平时期的一项活动。然而，绿盟科技威胁情报中心发现了分布式拒绝服务（DDoS）攻击[<a href="https://decoded.avast.io/martinchlumecky/dirtymoe-1/#ref">1]</a>。一般来说，DirtyMoe 可以将任意恶意软件部署到受感染的系统中，例如信息窃取器、勒索软件、木马等。</p></blockquote></li><li><p>自我保护机制：</p><p> DirtyMoe 驱动程序提供了广泛的功能；请参阅以下候选名单：</p><ul><li>Minifilter：对目录枚举的影响（隐藏、插入、修改）</li><li>注册表隐藏：可以隐藏已定义的注册表项</li><li>服务隐藏：修补<code>service.exe</code>结构以隐藏所需的服务</li><li>驱动隐藏：可以在系统中隐藏自己</li></ul><p>DirtyMoe 代码包含许多可以被大多数 AV 捕获的恶意模式。恶意软件作者使用 <strong>VMprotect 来混淆 DirtyMoe 服务 DLL 文件</strong>。下载的 DirtyMoe 对象使用硬编码密钥使用对称密码进行加密。我们已经看到了几个 MOE 对象，<strong>它们本质上包含相同的 PE 文件，只是 PE 标头不同</strong>。尽管如此，即使是这些轻微的修改也足以让使用的密码产生完全不同的 MOE 对象。因此，<strong>静态检测不能应用于 MOE 加密对象</strong>。此外，DirtyMoe 不会将解密后的 MOE 对象（PE 文件）转储到文件系统中，而是<strong>直接将 MOE 对象注入内存</strong>。</p><p> DirtyMoe 工作人员是通过多个进程和线程启动的。工作人员最初运行为<code>svchost.exe</code>，但 DirtyMoe 驱动程序将工作人员的进程名称更改为<code>fontdrvhost.exe</code>。DirtyMoe 有两个相互保护的工作进程（<em>Core</em>和<em>Executioner</em>）。因此，如果第一个工作人员被杀死，第二个工作人员将启动第一个工作人员的新实例，反之亦然。</p><p><strong>反检测</strong>补充：DirtyMoe: Deployment：<a href="https://decoded.avast.io/martinchlumecky/dirtymoe-4/">https://decoded.avast.io/martinchlumecky/dirtymoe-4/</a></p><p><strong>DisableAntiSpyware</strong><br><code>HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Windows Defender\DisableAntiSpyware = 1</code><br>Microsoft Defender Antivirus 可以通过将<code>DisableAntiSpyware</code>注册表项设置为 1 来禁用。因此，如果系统没有第三方防病毒产品，则系统没有针对恶意软件的保护，包括间谍软件。</p><p><strong>SFCDisable</strong><br><code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\SFCDisable = 4</code><br>Windows 文件保护 (WFP) 可防止非系统应用程序替换可能导致操作系统完整性和稳定性问题的关键 Windows 系统文件。WFP 通常在所有版本的 Windows中默认启用。</p><p>自然地，DirtyMoe 希望避免 WFP 检测到对系统文件进行任何操作的情况。因此，该<code>SFCDisable</code>值设置为4，启用 WFP，但 GUI 不会弹出每个 WFP 操作。效果是 WFP 已启用，因此不会调用系统警报，但会为用户隐藏 WFP 警告。<strong>这仅适用于 Windows XP。</strong></p><p><strong>SFCScan</strong><br><code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\SFCScan = 0</code><br>系统文件检查器 (SFC) 提供扫描受系统保护的文件的能力。SFC 验证文件版本，如果它检测到任何文件操作，SFC 将文件更新为正确的版本。这种注册表操作有助于禁用 SFC 保护滥用的 Windows 服务。此设置仅影响文件扫描，但 WFP 仍可处于活动状态。</p><p><strong>SvcHostSplitThresholdInKB</strong><br><code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SvcHostSplitThresholdInKB = 0xFFFFFFFF</code><br>关键的注册表操作控制系统启动和设备配置的某些方面。</p><p>在大多数情况下，Windows 服务从 Windows 通过通用主机进程 (svchost.exe) 执行的动态链接库运行。托管进程可以在一个进程中加载更多服务 (DLL) 作为线程。这是 Windows XP 时代的历史遗留物，当时系统内存曾经是一种稀缺商品。该系统使用了一些托管所有 Windows 服务的服务主机进程，由 DLL 文件表示，因为进程的创建和维护在系统内存方面是昂贵的。</p><p>如今，没有理由将服务分组在几个进程中，由此产生的积极影响是提高了系统的稳定性和安全性，以及更容易进行错误分析。服务现在通常不再共享进程；提供系统功能的小程序有一个独占的内存位置。并且如果 svchost.exe 进程崩溃，它不再拖着整个服务链。</p><p>Windows 10 带有一个阈值 ( <code>SvcHostSplitThresholdInKB</code>)，用于确定何时应将服务创建为常规进程。默认值为 380,000，因此如果系统内存小于 3.5 GB，则使用分组服务模型。也就是说，增大阈值可以减少宿主进程的数量，从而判断服务进程是否被拆分。</p><p>我们以 Windows 10 为例，如果该值设置为 1，则主机进程数约为。70. 等于最大值 ( <code>0xFFFFFFFF</code>) 的阈值导致主机进程数仅为 26。</p><p>最大值<code>SvcHostSplitThresholdInKB</code>可以隐藏有关运行进程的详细信息。因此，恶意软件作者将阈值设置为最大值以隐藏线程中的恶意服务活动。结果，恶意服务在其线程之一中的一个主机进程中运行。因此，跟踪和取证分析变得更加困难，因为 svchost 进程托管了许多其他服务，并且很难将系统活动分配给恶意软件服务。</p></li></ol><h3 id="五、Crackonosh-A-New-Malware-Distributed-in-Cracked-Software：https-decoded-avast-io-danielbenes-crackonosh-a-new-malware-distributed-in-cracked-software"><a href="#五、Crackonosh-A-New-Malware-Distributed-in-Cracked-Software：https-decoded-avast-io-danielbenes-crackonosh-a-new-malware-distributed-in-cracked-software" class="headerlink" title="五、Crackonosh: A New Malware Distributed in Cracked Software：https://decoded.avast.io/danielbenes/crackonosh-a-new-malware-distributed-in-cracked-software/"></a>五、Crackonosh: A New Malware Distributed in Cracked Software：<a href="https://decoded.avast.io/danielbenes/crackonosh-a-new-malware-distributed-in-cracked-software/">https://decoded.avast.io/danielbenes/crackonosh-a-new-malware-distributed-in-cracked-software/</a></h3><p>下图描述了整个 Crackonosh 安装过程。</p><p><a href="https://decoded.avast.io/wp-content/uploads/sites/2/2021/06/Installation-process.png"><img src="https://decoded.avast.io/wp-content/uploads/sites/2/2021/06/Installation-process.png" alt="img"></a>安装示意图</p><ol><li>首先，受害者运行破解软件的安装程序。</li><li>安装程序运行<code>maintenance.vbs</code></li><li><code>Maintenance.vbs</code>然后使用开始安装<code>serviceinstaller.msi</code></li><li><code>Serviceinstaller.msi</code>注册并运行<code>serviceinstaller.exe</code>，主要的恶意软件可执行文件。</li><li><code>Serviceintaller.exe</code> 运行<code>StartupCheckLibrary.DLL</code>。</li><li><code>StartupCheckLibrary.DLL</code>下载并运行<code>wksprtcli.dll</code>。</li><li><code>Wksprtcli.dll</code> 提取更新并<code>winlogui.exe</code> 删除它包含的内容，解密并放置在文件夹中。</li></ol><p>规避和禁用安全软件所采取的具体措施包括：</p><ul><li>在安全模式下删除防病毒软件</li><li>停止 Windows 更新(它会删除以下注册表项以停止 Windows Defender 并关闭自动更新。)</li><li>用绿色勾选系统托盘图标替换 Windows 安全</li><li>使用的库不使用将<code>DllMain</code>库作为主可执行文件 (by <code>rundll32.exe</code>) 运行时使用的常用库，而是从其他一些导出函数开始。</li><li>Serviceinstaller 测试它是否在安全模式下运行</li></ul><p>为了防止分析，它会采取以下操作来测试以确定它是否在 VM 中运行：</p><ul><li>检查注册表项：<ul><li><code>SOFTWARE\VMware, Inc</code></li><li><code>SOFTWARE\Microsoft\Virtual Machine\Guest\Parameters</code></li><li><code>SOFTWARE\Oracle\VirtualBox Guest Additions</code></li></ul></li><li>测试计算机时间是否在某个合理的时间间隔内，例如在恶意软件创建之后和 2023 年之前 ( <code>wksprtcli.dll</code>)</li></ul><p>此外，如前所述，它会延迟运行以更好地隐藏自己。我们发现特定安装程序使用硬编码的日期和时间来延迟，如下所示。</p><table><thead><tr><th><strong>SHA of installer</strong></th><th><strong>Installer doesn’t run before</strong></th></tr></thead><tbody><tr><td>9EC3DE9BB9462821B5D034D43A9A5DE0715FF741E0C171ADFD7697134B936FA3</td><td>2018-06-10 13:08:20</td></tr><tr><td>8C52E5CC07710BF7F8B51B075D9F25CD2ECE58FD11D2944C6AB9BF62B7FBFA05</td><td>2018-06-19 14:06:37</td></tr><tr><td>93A3B50069C463B1158A9BB3A8E3EDF9767E8F412C1140903B9FE674D81E32F0</td><td>2018-07-04 17:33:20</td></tr><tr><td>6A3C8A3CA0376E295A2A9005DFBA0EB55D37D5B7BF8FCF108F4FFF7778F47584</td><td>2018-07-10 15:35:57</td></tr><tr><td>4B01A9C1C7F0AF74AA1DA11F8BB3FC8ECC3719C2C6F4AD820B31108923AC7B71</td><td>2018-07-25 13:56:35</td></tr><tr><td>65F39206FE7B706DED5D7A2DB74E900D4FAE539421C3167233139B5B5E125B8A</td><td>2018-08-03 15:50:40</td></tr><tr><td>C6817D6AFECDB89485887C0EE2B7AC84E4180323284E53994EF70B89C77768E1</td><td>2018-08-14 12:36:30</td></tr><tr><td>7F836B445D979870172FA108A47BA953B0C02D2076CAC22A5953EB05A683EDD4</td><td>2018-09-13 12:29:50</td></tr><tr><td>D8C092DE1BF9B355E9799105B146BAAB8C77C4449EAD2BDC4A5875769BB3FB8A</td><td>2018-10-01 13:52:22</td></tr><tr><td>E497EE189E16CAEF7C881C1C311D994AE75695C5087D09051BE59B0F0051A6CF</td><td>2018-10-19 14:15:35</td></tr><tr><td>D7A9BF98ACA2913699B234219FF8FDAA0F635E5DD3754B23D03D5C3441D94BFB</td><td>2018-11-07 12:47:30</td></tr></tbody></table><p>它还采取了特定的行动来隐藏自己，以免使用可能会泄露其存在的工具的可能的高级用户。</p><p>它使用类似 Windows 的名称和描述，例如 <code>winlogui.exe</code>Windows 登录 GUI 应用程序。</p><p>它还检查正在运行的进程并将其与下面的阻止列表进行比较。如果它找到具有指定名称的进程<code>winrmsrv.exe</code>并<code>winlogui.exe</code>终止自身并等待PC的下一次启动。</p><ul><li><ul><li>Blocklist:<ul><li>dumpcap.exe</li><li>fiddler.exe </li><li>frst.exe </li><li>frst64.exe </li><li>fse2.exe </li><li>mbar.exe </li><li>messageanalyzer.exe </li><li>netmon.exe </li><li>networkminer.exe </li><li>ollydbg.exe </li><li>procdump.exe </li><li>procdump64.exe </li><li>procexp.exe </li><li>procexp64.exe </li><li>procmon.exe </li><li>procmon64.exe </li><li>rawshark.exe </li><li>rootkitremover.exe </li><li>sdscan.exe </li><li>sdwelcome.exe </li><li>splunk.exe </li><li>splunkd.exe </li><li>spyhunter4.exe </li><li>taskmgr.exe</li><li>tshark.exe </li><li>windbg.exe </li><li>wireshark-gtk.exe </li><li>wireshark.exe </li><li>x32dbg.exe </li><li>x64dbg.exe </li><li>X96dbg.exe</li></ul></li></ul></li></ul><h3 id="六、HackBoss-A-cryptocurrency-stealing-malware-distributed-through-Telegram：https-decoded-avast-io-romanalinkeova-hackboss-a-cryptocurrency-stealing-malware-distributed-through-telegram"><a href="#六、HackBoss-A-cryptocurrency-stealing-malware-distributed-through-Telegram：https-decoded-avast-io-romanalinkeova-hackboss-a-cryptocurrency-stealing-malware-distributed-through-telegram" class="headerlink" title="六、HackBoss: A cryptocurrency-stealing malware distributed through Telegram：https://decoded.avast.io/romanalinkeova/hackboss-a-cryptocurrency-stealing-malware-distributed-through-telegram/"></a>六、HackBoss: A cryptocurrency-stealing malware distributed through Telegram：<a href="https://decoded.avast.io/romanalinkeova/hackboss-a-cryptocurrency-stealing-malware-distributed-through-telegram/">https://decoded.avast.io/romanalinkeova/hackboss-a-cryptocurrency-stealing-malware-distributed-through-telegram/</a></h3><p>在窃取加密货币的恶意软件属于三个主要类别之一： </p><ul><li><code>Password stealers</code>：专注于窃取加密货币钱包或带有密码的文件的恶意软件。</li><li><code>Coinminers</code>：使用受害者机器的计算能力来挖掘加密货币的恶意软件。</li><li><code>Keyloggers</code>：记录击键以记录密码或助记词的恶意软件。</li></ul><p>这三类与加密货币相关的恶意软件加起来是过去一年中常见的第三大恶意软件类型。</p><p><img src="https://decoded.avast.io/wp-content/uploads/sites/2/2021/04/image-16.png" alt="img"><em>自 2020 年 3 月至 2021 年 3 月以来最常见的恶意软件类型</em></p><p>HackBoss 是一个简单的窃取加密货币的恶意软件，但它的金钱收益非常可观。这种恶意软件最有趣的方面是它传递给受害者的方式。HackBoss 的作者拥有一个 Telegram 频道，他们将其用作传播恶意软件的主要来源.</p><p>Hack Boss 频道上宣传虚假破解或黑客应用程序的帖子通常包含一个指向加密或匿名文件存储的链接，可以从中下载应用程序。该帖子还包含对应用程序假定功能的虚假描述以及应用程序 UI 的屏幕截图。它有时还包含一个指向 YouTube 频道的链接<code>https://www.youtube.com/channel/UC1IEdha7riKwVCfPk</code>（该频道在发布时已被删除）<code>Bank God</code> ，并带有促销视频。</p><p>Hack Boss 频道上宣传虚假破解或黑客应用程序的帖子通常包含一个指向加密或匿名文件存储的链接，可以从中下载应用程序。该帖子还包含对应用程序假定功能的虚假描述以及应用程序 UI 的屏幕截图。它有时还包含一个指向 YouTube 频道的链接<code>https://www.youtube.com/channel/UC1IEdha7riKwVCfPk</code>（该频道在发布时已被删除）<code>Bank God</code> ，并带有促销视频。</p><h3 id="七、SkidMap病毒利用Redis未授权访问漏洞攻击，数千台云主机沦为矿机（Linux）：https-mp-weixin-qq-com-s-biz-MzI5ODk3OTM1Ng-amp-mid-2247498404-amp-idx-2-amp-sn-bb356408fb8abc6e8d5a3411a42daa7a-amp-scene-19-wechat-redirect"><a href="#七、SkidMap病毒利用Redis未授权访问漏洞攻击，数千台云主机沦为矿机（Linux）：https-mp-weixin-qq-com-s-biz-MzI5ODk3OTM1Ng-amp-mid-2247498404-amp-idx-2-amp-sn-bb356408fb8abc6e8d5a3411a42daa7a-amp-scene-19-wechat-redirect" class="headerlink" title="七、SkidMap病毒利用Redis未授权访问漏洞攻击，数千台云主机沦为矿机（Linux）：https://mp.weixin.qq.com/s?__biz=MzI5ODk3OTM1Ng==&amp;mid=2247498404&amp;idx=2&amp;sn=bb356408fb8abc6e8d5a3411a42daa7a&amp;scene=19#wechat_redirect"></a>七、SkidMap病毒利用Redis未授权访问漏洞攻击，数千台云主机沦为矿机（Linux）：<a href="https://mp.weixin.qq.com/s?__biz=MzI5ODk3OTM1Ng==&amp;mid=2247498404&amp;idx=2&amp;sn=bb356408fb8abc6e8d5a3411a42daa7a&amp;scene=19#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzI5ODk3OTM1Ng==&amp;mid=2247498404&amp;idx=2&amp;sn=bb356408fb8abc6e8d5a3411a42daa7a&amp;scene=19#wechat_redirect</a></h3><ul><li>利用redis未授权访问漏洞入侵云主机；</li><li>下载门罗币、莱特币、比特币挖矿木马，通过挖矿牟利；</li><li>添加SSH公钥，以持久化远控失陷主机；</li><li>下载功能更加复杂的恶意软件包：接受远程指令，清除系统审计日志，安装服务，关闭SELinux降低系统安全性，通过安装Linux内核模块隐藏恶意行为。</li></ul><p>SkidMap病毒在2019年9月左右被发现，主要目标为感染肉鸡挖矿，该病毒的明显特征为通过加载Linux恶意内核模块来隐藏其恶意行为，增加了运维人员排查威胁的难度。</p><p>此次SkidMap病毒感染后会下载XMRig（门罗币挖矿木马）、cpuminer（莱特币和比特币挖矿木马），同时写入SSH后门公钥以方便远程登录，然后下载恶意程序包gold8.tar.gz，通过3DES解压后释放多个模块，完成挖矿木马启动、替换pam_unix.so文件留置登陆后门、上传日志到远程服务器，安装远控程序rctl的功能，还会安装Linux内核模块对恶意行为进行隐藏。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWWAXmCiceVcSLGmpT1yiabDzr7RZpFMhPrhk6Jspzj7HrYGXyX9sd8XVcK1k7vjV9lATGgrzibcKrqvw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><center>SkidMap病毒最新变种的恶意行为</center><h3 id="八、Sysrv-hello僵尸网络集木马、后门、蠕虫于一身，攻击Linux、Windows主机挖矿：https-mp-weixin-qq-com-s-biz-MzI5ODk3OTM1Ng-amp-mid-2247497474-amp-idx-1-amp-sn-87eb580380ee3ff5efd389da419f82c9-amp-scene-19-wechat-redirect"><a href="#八、Sysrv-hello僵尸网络集木马、后门、蠕虫于一身，攻击Linux、Windows主机挖矿：https-mp-weixin-qq-com-s-biz-MzI5ODk3OTM1Ng-amp-mid-2247497474-amp-idx-1-amp-sn-87eb580380ee3ff5efd389da419f82c9-amp-scene-19-wechat-redirect" class="headerlink" title="八、Sysrv-hello僵尸网络集木马、后门、蠕虫于一身，攻击Linux、Windows主机挖矿：https://mp.weixin.qq.com/s?__biz=MzI5ODk3OTM1Ng==&amp;mid=2247497474&amp;idx=1&amp;sn=87eb580380ee3ff5efd389da419f82c9&amp;scene=19#wechat_redirect"></a>八、Sysrv-hello僵尸网络集木马、后门、蠕虫于一身，攻击Linux、Windows主机挖矿：<a href="https://mp.weixin.qq.com/s?__biz=MzI5ODk3OTM1Ng==&amp;mid=2247497474&amp;idx=1&amp;sn=87eb580380ee3ff5efd389da419f82c9&amp;scene=19#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzI5ODk3OTM1Ng==&amp;mid=2247497474&amp;idx=1&amp;sn=87eb580380ee3ff5efd389da419f82c9&amp;scene=19#wechat_redirect</a></h3><p>该木马不仅攻击Linux系统，同时发现针对Windows平台的恶意载荷，攻击Windows系统成功后会植入powershell恶意脚本，脚本会进一步拉取Windows平台的相同模块到tmp目录执行。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYNEiasBtqHv28bRC3MkrxibbnSHEhJuHwQAeibPCibia9Iy2ziaF5d54icrnwg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>Linux系统下sysrv模块通过使用52013端口作为互斥量，端口开启状态判定为已感染环境直接退出，否则打开本地该端口进行占用。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYV8s9ib6NewG6XaLqLNNvO81uFTBCoTteIksff5gnbbkCoTjuu59fssg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYDexNqyxSGjrQCsj9V8wC2OS6EyFDtldt5RDIsqzUkHJmOmSXh7bZdg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>sysrv通过检测进程，判断network01进程（矿机进程）是否正常运行，如果未正常运行，就在tmp目录进一步释放出文件内嵌的elf文件，并命名为network01将其执行。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYlJjo4gvwviaIic78sFnS3PUdibSNu9ax8bcd1edyBU1JMUTPJjwnvhGfw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYicnYbPzf4tfL3RibSMCcHqPJaTfnp5mUIcPiaCs3Ry3hoX0EZycdD1AQw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYg2eSEYmpwQmxt7sO0qmQvDX6wEtsSlJafOC50RMzLRIDxJEib5XJsrw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>network01模块为门罗币矿机程序，该团伙通过清理可能的竞品挖矿进程或其他占CPU资料较多的进程实现独占CPU资源挖矿。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYibI5wb4WAPI0RoV0flaAVENJCjbkK9svXXNAqWqVP5cLBMameQrLoXw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>sysrv确认挖矿行为正常运行后，会开始进行蠕虫式的攻击传播：进行随机IP的端口扫描与漏洞利用，会尝试对mysql，Tomcat服务进行爆破攻击，尝试对Weblogic服务使用CVE-2020-14882漏洞（该漏洞公告由Oracle官方于2020年10月21日公开）进行远程代码执行攻击，这一横向扩散行为使该团伙控制的肉鸡规模迅速增大。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYrlm1UUrMpua7c2uqIUOc31pmBIjagN1gefmgYCpgnPKXRH2ATcoSYQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYKzbGSl4jicDxKzkt9CNYhKniaGhuxMdUz1xRw4xEqFZN190SicXeNwwPw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>hello_src_exp爆破，漏洞利用组合攻击</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYnEjXuw46MJfOpdlPb3QQXf7vRByRyUCDgcmVo9MDrsF0dcngxAN3NQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>攻击mysql服务使用的弱口令爆破字典</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYlf0XjYQzofW8lhJUkwmvUL6TNKqicUbx5Ichej0ictiasKpibANIpnmvGg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>攻击Tomcat服务使用的爆破口令</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYiannQk0ybp2bC8sRaMuV28RGazCX0PaFDHI9MTtCLI4TywfykEnhb5Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>对Weblogic组件利用CVE-2020-14882 远程代码执行漏洞攻击，该安全漏洞为2020年10月Oracle官方公告修复，属于相对比较新的漏洞攻击武器。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYO9MicAygYgvoIuOMFRicePv2oiblSukMgXsqfoZ55LvRNzdUXMRGEBBfg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYZkqS78hCgOHDLDIzmbAUADicMHbORVOnDvG1SSpj3Jj3kdeJkoZdZGg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="九、Putting-an-end-to-Retadup-A-malicious-worm-that-infected-hundreds-of-thousands：https-decoded-avast-io-janvojtesek-putting-an-end-to-retadup-a-malicious-worm-that-infected-hundreds-of-thousands-（据文章介绍，服务器已被清查）"><a href="#九、Putting-an-end-to-Retadup-A-malicious-worm-that-infected-hundreds-of-thousands：https-decoded-avast-io-janvojtesek-putting-an-end-to-retadup-a-malicious-worm-that-infected-hundreds-of-thousands-（据文章介绍，服务器已被清查）" class="headerlink" title="九、Putting an end to Retadup: A malicious worm that infected hundreds of thousands：https://decoded.avast.io/janvojtesek/putting-an-end-to-retadup-a-malicious-worm-that-infected-hundreds-of-thousands/（据文章介绍，服务器已被清查）"></a>九、Putting an end to Retadup: A malicious worm that infected hundreds of thousands：<a href="https://decoded.avast.io/janvojtesek/putting-an-end-to-retadup-a-malicious-worm-that-infected-hundreds-of-thousands/%EF%BC%88%E6%8D%AE%E6%96%87%E7%AB%A0%E4%BB%8B%E7%BB%8D%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B7%B2%E8%A2%AB%E6%B8%85%E6%9F%A5%EF%BC%89">https://decoded.avast.io/janvojtesek/putting-an-end-to-retadup-a-malicious-worm-that-infected-hundreds-of-thousands/（据文章介绍，服务器已被清查）</a></h3><p>Retadup 是一种恶意蠕虫，影响整个拉丁美洲的 Windows 计算机。它的目标是在受害者的计算机上实现持久性，将自身传播得更广泛，并在受感染的计算机上安装额外的恶意软件有效负载。在绝大多数情况下，安装的有效负载是代表恶意软件作者挖掘加密货币的恶意软件。但是，在某些情况下，我们还观察到 Retadup 分发了 Stop 勒索软件和 Arkei 密码窃取程序。</p><p>核心是用 AutoIt 或 AutoHotkey 编写的。在这两种情况下，它都包含两个文件：干净的脚本语言解释器和恶意脚本本身。这与当今大多数 AutoIt 恶意软件不同，后者通常仅由一个包含解释器和恶意脚本的恶意可执行文件组成。在 Retadup 的 AutoHotkey 变种中，恶意脚本作为源代码分发，而在 AutoIt 变种中，脚本首先被编译然后分发。</p><p>首先，程序检查是否存在另一个Retadup实例在运行，以保证任何时间仅有一个实例运行。之后会进行一些基本检查确保自己没有被分析，否则便静默退出。最后进入一个无线循环，定期轮询C&amp;C服务器以获取命令，若收到来自C&amp;C的命令，则执行收到的命令的处理程序，在联系C&amp;C 的同时，它还会定期执行其他尝试来传播自己并恢复其持久性机制。</p><p>几乎所有的 Retadup 样本都会首先检查它们运行的文件系统路径。如果解释器路径或脚本路径与预期不同，则脚本不会执行任何恶意操作。大多数示例还实现了一种延迟执行的方法。在执行开始时，它们要么执行一次长睡眠，要么执行一系列多次短睡眠。最后，一些变体还检查名称为<code>vmtoolsd.exe</code> 或 <code>procmon.exe</code>的进程是否正在运行、名称为<code>C:\CWSandbox\</code>或<code>C:\cuckoo\``SbieDll.dll``api_log.dll</code>的目录是否存在以及名称为 或 的模块是否已加载到当前进程中。</p><p><strong>Retadup 通过在其中创建注册表值<code>HKCU\Software\Microsoft\Windows\CurrentVersion\Run</code>和&#x2F;或创建计划任务来实现持久性</strong>。计划任务是使用<code>schtasks.exe</code>实体程序创建的，并设置为每分钟执行一次。Retadup 的 AutoIt 变体通常使用硬编码的注册表值.名称，而 AutoHotkey 变体倾向于使用注册表值和随机生成名称的计划任务。</p><p>Retadup主要通过将恶意快捷方式文件放到驱动器中实现传播。首先，它会遍历除了C盘外的所有驱动器根目录下的文件夹，并在每个文件夹下创建一个快捷方式，该快捷方式与源文件名相同，仅附加一个如<code>copy fpl.lnk</code>的字符后缀，它模拟真实的文件夹从而诱导用户执行。Retadup还将干净的AutoIt&#x2F;AutoHotkey 解释器和恶意脚本复制到系统隐藏目录，该目录位于相对于所选中的<code>LNK</code>文件的硬编码路径中。</p><p>每个 Retadup 样本都配置了一组C&amp;C 域名和端口，样本通过向他们发出 HTTP GET 请求来单独联系他们，样本会在发出的请求的URL的路径中对受害者的一些信息进行编码。虽然编码信息的确切内容和形式在不同的 Retadup 变体中有所不同，但所有 Retadup 变体都会在路径的开头对受害者的 ID 进行编码。</p><p>C&amp;C 服务器从接收到的 GET 请求的路径中解析信息，并返回一个包含要执行的命令的类似混淆的 HTTP 响应。</p><p>对于执行下载的命令，其执行附加 PE 有效负载的方式通常使用多层间接。首先获取 AutoIt 脚本，而不是直接下载和执行 PE 有效负载。AutoIt 脚本中嵌入了一个能够加载嵌入式 PE 文件的 shellcode。shellcode 被复制到通过<code>VirtualAlloc</code>. AutoIt 功能<code>DllCallAddress</code> 然后用于将控制权转移到 shellcode，shellcode 又将控制权加载并传递给最终的 PE 有效负载。这种间接的目的大概是为了避免将 PE 有效负载放到磁盘上，这会增加检测的机会。但上述工作流程并不是专门使用的。在其他一些情况下，我们还观察到 AutoIt 脚本直接下载 PE 文件，删除其区域标识符并直接从磁盘运行它。</p><p>由于内核以 AutoHotkey 源代码或 AutoIt 字节码（易于反编译）的形式分发，因此作者试图对其进行混淆以使分析更加困难。</p><p><strong>挖矿有效载荷</strong></p><p>矿工有效载荷以 32 位 PE 文件的形式出现，并且通常与各种打包程序&#x2F;加密程序打包在一起。以解压样本<code>9c46a0e48ea9b104f982e5ed04735b0078938866e3822712b5a5374895296d08</code>为例：它解密内存中的 XMRig PE 文件，并通过进程挖空将其注入到新创建的进程中。它还动态构建一个 XMRig 配置文件，将其放到磁盘上并将其传递给新创建的进程。该恶意软件在检测到<code>taskmgr.exe</code>运行时停止挖掘，因此用户更难检测到其增加的 CPU 使用率。注入 XMRig 的进程也充当看门狗。如果注入的工作进程因任何原因终止，则看门狗进程会生成一个新的工作进程来替换它。</p><p>从我们的角度来看，这个矿工最有趣的方面是注入方法。在足够高的水平上，注入只是常规的过程空心化。然而，虽然进程空心化通常是通过调用更高级别的函数来实现的，例如<code>WriteProcessMemory</code>or <code>NtMapViewOfSection</code>，但矿工选择了一种更隐蔽的方式直接使用系统调用。这比常规的进程空心化更难实现，但它可能允许作者绕过一些安全解决方案的用户态钩子。</p><p>大多数常规的流程空心实现直接使用从<code>ntdll</code>导出的未记录函数（例如<code>NtUnmapViewOfSection</code>）来实现流程注入。但是，许多终端安全解决方案能够通过挂钩众所周知的函数来检测这种注入方法。因此，某些恶意软件（例如Formbook）会将<code>ntdll</code>的第二个副本加载到其内存中，并调用从该副本导出的函数（这也称为“拉各斯岛”方法）。这背后的想法是，新副本<code>ntdll</code> （通常直接从磁盘读取）可能不包含原始副本所包含的钩子，因此安全软件可能看不到恶意软件调用了哪些函数。</p><p>(ntdll.dll是重要的Windows NT内核级文件。描述了windows本地NTAPI的接口。当Windows启动时，ntdll.dll就驻留在内存中特定的<a href="https://baike.baidu.com/item/%E5%86%99%E4%BF%9D%E6%8A%A4">写保护</a>区域，使别的程序无法占用这个内存区域。)</p><p>该矿机使用了上述“拉各斯岛”使用新的未挂钩<code>ntdll</code>副本的方法，但它也更进了一步。与进程空心相关的函数不会通过<code>ntdll</code>. 相反，矿工解析这些函数的主体并提取它们相应的系统调用号（在 Windows 上，系统调用号可以在版本之间更改，因此它们不能简单地在示例中硬编码）。一旦恶意软件获得了必要的系统调用号，它就会直接使用<code>sysenter</code> 指令调用系统调用。</p><p>这是可能的，因为大多数使用的<code>ntdll</code>函数只是系统调用的简单包装器。这样做的结果是恶意软件不调用任何导出的函数，因此常规的用户空间钩子可能不会拦截这些“函数”的使用。</p><p>由于矿工是32位PE文件，上述方法在32位系统上运行良好。但是WOW64呢？当然，矿工不能只从 32 位代码调用 64 位系统调用。相反，它使用了所谓的<a href="http://rce.co/knockin-on-heavens-gate-dynamic-processor-mode-switching/">天堂之门</a>技术来突破WOW64仿真层。一旦恶意软件通过天堂之门并执行 64 位代码，它就可以直接调用 64 位系统调用，然后返回到 32 位代码。Heaven’s Gate 技术的使用还允许矿工从 WoW64 子系统中注入 64 位版本的 XMRig。</p><p>（WoW64子系统是一个轻量级的compatibility layer, 在所有版本的windows上都拥有同样的接口. 它的主要目的是用来创建32-bit环境, 为了让32位的应用程序可以不经过任何修改就运行在64-bit的系统上, 它提供了必须的接口.</p><p>WOW64 是在用户模式下实现的，作为 ntdll.dll 和内核之间的层。WOW64 及其支持的一些 DLL 仅仅是可以加载到 32 位进程中的 64 位的 DLL。对于所有其他情况，进程保持为纯进程。32 位的进程无法加载 64 位的 DLL，反之亦然。）</p><p>矿工本身不使用任何特殊的混淆（作者可能假设他们使用的加密器就足够了）。但是，创建 XMRig 配置文件的代码包含使用硬编码密钥使用 Vigenère 密码加密的字符串。这似乎是一项基本的努力，使重新利用矿工变得更加困难。否则，其他恶意软件作者修补接收挖矿收入的地址并将矿工用于他们自己的邪恶目的将是微不足道的。</p><h3 id="十、F-Scrack-mimikatz-–-A-bundle-of-tools：https-decoded-avast-io-ondrejmokos-f-scrack-mimikatz-a-bundle-of-tools"><a href="#十、F-Scrack-mimikatz-–-A-bundle-of-tools：https-decoded-avast-io-ondrejmokos-f-scrack-mimikatz-a-bundle-of-tools" class="headerlink" title="十、F-Scrack-mimikatz – A bundle of tools：https://decoded.avast.io/ondrejmokos/f-scrack-mimikatz-a-bundle-of-tools/"></a>十、F-Scrack-mimikatz – A bundle of tools：<a href="https://decoded.avast.io/ondrejmokos/f-scrack-mimikatz-a-bundle-of-tools/">https://decoded.avast.io/ondrejmokos/f-scrack-mimikatz-a-bundle-of-tools/</a></h3><p>最近，在分析试图绕过各种 applocking 技术的样本时，我们重新审视了旧的各种工具包，其唯一目的是为运营商赚钱。尽管该活动似乎长期不活跃，但它表明创建能够赚钱的恶意软件几乎不需要编写原始代码，所需要的只是使用公开可用的代码片段将现有工具捆绑在一起。</p><p>该链以包含两个文件的自解压存档开始 -<code>Xagent.exe</code>和<code>depszip</code>. Depszip 是一个 ZIP 存档，其中包含各种辅助文件。Xagent.exe 是使用 PyInstaller 创建的二进制文件，并设置为在解压缩 SFX 存档后自动运行。调用了原始 Python 脚本<code>F-Scrack-mimikatz.py</code>并表明该代码源自<a href="https://github.com/qianniaoge/F-Scrack">F-Scrack</a>工具。</p><p>运行Mimikatz（用于从内存中提取铭文密码、哈希、PIN码等）：存档 depszip 包含 x86 和 x64 版本<code>mimi32.exe</code>以及<code>mimi64.exe</code>.  Mimikatz 找到的凭据被上传到<code>u.swb[.]one/upload/win</code>并用于构建攻击列表。然后使用该攻击列表在本地计算机上运行脚本，使用工具<a href="https://github.com/Twi1ight/AD-Pentest-Script/blob/master/wmiexec.vbs">wmiexec.vbs</a>和称为<a href="https://attack.mitre.org/techniques/T1117">Squibldoo</a>的技术。这种技术可能允许绕过安全工具和应用程序白名单的检测，将<code>regsvr32.exe</code>其用作执行代码的“代理”。执行的代码托管在<code>xmr.enjoytopic[.]tk/d/regxmr222.sct</code>.</p><p>通过攻击列表和Squibldoo技术攻击连接到相同LAN的其他计算机（进行端口扫描）。</p><p>之后通国ThreadNum类利用永恒之蓝漏洞排队检查并攻击指定IP和端口。之后通过无身份验证或者使用默认用户名和弱密码尝试访问服务，并查找如贸易、VIP、比特币、门罗币等有用的数据库。将找到的数据库和凭证返回，删除其他数据库并创建要求赎金的条目。</p><p>通过一个VBScript，按照泄露的Vault7文档描述，使用Vmic.exe设置持久性，此外，他还通过注册表设置持久性。它创造了两个键，一个使用mshta.exe运行来自于xmr.enjoytopic[.]tk&#x2F;d&#x2F;ps3.txt的代码，一个使用 Squiblydoo运行来自xmr.enjoytopic[.]tk&#x2F;d&#x2F;regxmr999.sct的代码。</p><p>除了设置持久性之外，该脚本还在受感染的机器上下载并运行 XMRig。XMRig 二进制文件有多个版本。这些二进制文件是定制的——除了运行 XMRig，它们还创建一个计划任务，通过Squibldoo 运行在</p><ul><li><code>xmr.enjoytopic[.]tk/d/regxmr222.sct</code>,</li><li><code>down.cacheoffer[.]tk/d2/reg9.sct</code>,</li><li><code>xmr.enjoytopic[.]tk/d/regxmr999.sct</code></li></ul><p>的代码，并使用vmic.exe保持持久性。</p><p>此外，还用过一个PowerShell脚本，从png.realtimenews[.]tk&#x2F;m.png下载XMRig脚本并运行，并通过每分钟的计划任务写入和运行自身。</p><h3 id="十一、Clipsa-–-Multipurpose-password-stealer：https-decoded-avast-io-janrubin-clipsa-multipurpose-password-stealer-（内容过长，暂时放一放）"><a href="#十一、Clipsa-–-Multipurpose-password-stealer：https-decoded-avast-io-janrubin-clipsa-multipurpose-password-stealer-（内容过长，暂时放一放）" class="headerlink" title="十一、Clipsa – Multipurpose password stealer：https://decoded.avast.io/janrubin/clipsa-multipurpose-password-stealer/（内容过长，暂时放一放）"></a>十一、Clipsa – Multipurpose password stealer：<a href="https://decoded.avast.io/janrubin/clipsa-multipurpose-password-stealer/%EF%BC%88%E5%86%85%E5%AE%B9%E8%BF%87%E9%95%BF%EF%BC%8C%E6%9A%82%E6%97%B6%E6%94%BE%E4%B8%80%E6%94%BE%EF%BC%89">https://decoded.avast.io/janrubin/clipsa-multipurpose-password-stealer/（内容过长，暂时放一放）</a></h3><p>Clipsa 是一个多用途密码窃取器，用 Visual Basic 编写，专注于从不安全的 WordPress 网站窃取加密货币、暴力破解和窃取管理员凭据、替换剪贴板中的加密地址以及在受感染机器上挖掘加密货币。Clipsa 的几个版本还部署了 XMRig 硬币矿工，以从受感染的计算机中赚取更多的钱。</p><p>我们估计攻击媒介很可能是媒体播放器（<code>Ultra XVid Codec Pack.exe</code>或<code>Installer_x86-x64_89006.exe</code>）的恶意编解码器包安装程序。尝试为其媒体播放器安装这些编解码器的用户会无意中下载恶意安装程序而不是干净的安装程序。一旦用户开始安装过程，他们就会在他们的机器上部署 Clipsa，恶意软件会立即开始其恶意行为。</p><p>Clipsa 使用带有多个参数（命令行参数）的单个可执行二进制文件。这些参数区分作为单独进程同时运行的程序阶段。每个阶段专注于不同的功能，并由 Clipsa 的初始化过程开始，该过程没有任何参数。</p><p>Clipsa 将这些参数用于相位：</p><ol><li><p>无参数</p></li><li><p>–CLIPS</p></li><li><p>–CLIPSS</p></li><li><p>–WALLS</p></li><li><p>–PARSE</p></li><li><p>–BRUTE</p></li></ol><p>阶段 2-4 旨在窃取用户数据，重点关注加密钱包相关数据。第 5 阶段和第 6 阶段的重点是查找易受攻击的 WordPress 网站并窃取其管理凭据。在本分析的其余部分，我们将重点关注这些阶段中的每一个。</p><ol><li><p>无参数阶段：</p><ul><li><p>预安装</p><p>当恶意软件在受感染的机器上运行时，程序无需任何参数即可直观地启动。此阶段允许 Clipsa 在系统上安装和隐藏自身。然后它继续初始化执行恶意操作的其他阶段。</p><p>在预安装阶段，Clipsa 会创建一个消息对话框，使其看起来像是某种设置过程。但是，这个对话框（见下图）实际上只是一个伪装，所以用户认为他们下载的编解码器包正在被安装。事实是该对话框仅显示随机生成的数字（增量相加）并打印总和。Clipsa 还在增量之间添加了随机睡眠，使过程看起来很自然。</p><p><img src="https://lh5.googleusercontent.com/BniDt3p_-XAMargEsAu0knBw16faRT2Fa7dEc6E9QpNLNDq04aFJJ9_a8esJL7sxljKRxhbTbFea4KXTIw0lczlMAyKNbvAnG3BbNfQ1aUxJU1zCvUmxrdduO8kpHRPbSDf9d0MG" alt="img"></p><center>以伪装方式说明设置进度的图</center><p>在总和达到 99% 后，该过程关闭对话框。在虚构的设置过程中，恶意软件不会执行任何恶意或有用的操作。我们认为这种行为的目的是延迟实际的恶意进程，从而避免在自动沙盒工具中被检测到。</p><p>虚拟设置完成后，Clipsa 使用 Windows Management Instrumentation (WMI) 检查任务管理器是否正在运行：<br><code>Select * from Win32_Process WHERE Name = &#39;taskmgr.exe&#39;</code><br>如果正在运行，则终止程序以避免用户检测。</p></li><li><p>安装</p><p>Clipsa 然后将自身复制到<code>%APPDATA%\Roaming</code>目录中。特定文件夹和二进制文件的命名取决于 Clipsa 的版本。较新版本之一将自身复制到：<br><code>C:\Users\user\AppData\Roaming\AudioDG\condlg.exe</code></p><p><code>C:\Users\user\AppData\Roaming\AudioDG\zcondlg.exe</code></p><p>在安装过程中，还会创建其他目录和文件：<br><code>C:\Users\user\AppData\Roaming\AudioDG\log.datC:\Users\user\AppData\Roaming\AudioDG\obj\C:\Users\user\AppData\Roaming\AudioDG\udb\</code></p><p>此外，将路径<code>condlg.exe</code>添加到注册表自动运行，确保恶意软件的持久性：<br><code>HCU\Software\Microsoft\Windows\CurrentVersion\Run\11f86284</code></p><p>此外，condlg.exe还会创建一个新进程（不带参数），该进程用作释放器并启动其他恶意阶段。然而，这个过程是从隐藏文件夹 AudioDG 开始的，这正是 Clipsa 知道它已经安装在系统上的方式。</p><p>最后但同样重要的是，最初的 Clipsa 流程注定要结束。即使整个 Clipsa 安装过程成功，恶意软件也会向用户显示错误消息，让用户相信编解码器安装失败，让他们认为没有安装任何内容：</p></li><li><p>condlg.dll 文件</p><p>在安装过程中，Clipsa 会检查用户执行恶意软件的目录中是否存在其他文件。此文件通常命名为65923_VTS.vob或setup.dll. 但是，它既不是多媒体容器也不是库。该文件是由 Clipsa 解密的加密文本文件，并保存到一个新文件中：<br>C:\Users\user\AppData\Roaming\AudioDG\condlg.dll</p><p>该文件包含数千个比特币地址。正如我们稍后将看到的，此文件将用于CLIPS 阶段，在此期间，剪贴板中的加密钱包地址被替换。但是，它的存在是可选的，没有它，Clipsa 也能完全发挥作用。</p><p>请注意，原始文件的名称遵循 Clipsa 伪装成媒体播放器的编解码器包安装程序的假设。</p></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、挖矿病毒的套路-https-zhuanlan-zhihu-com-p-164557943&quot;&gt;&lt;a href=&quot;#一、挖矿病毒的套路-https-zhuanlan-zhihu-com-p-164557943&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    
    <category term="恶意软件检测" scheme="https://boneink.github.io/tags/%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8B/"/>
    
    <category term="入侵检测" scheme="https://boneink.github.io/tags/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/"/>
    
    <category term="木马检测" scheme="https://boneink.github.io/tags/%E6%9C%A8%E9%A9%AC%E6%A3%80%E6%B5%8B/"/>
    
    <category term="网络安全" scheme="https://boneink.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>java-线程池</title>
    <link href="https://boneink.github.io/2022/05/22/java-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://boneink.github.io/2022/05/22/java-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2022-05-22T04:00:00.000Z</published>
    <updated>2022-05-22T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,  </span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,  </span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,  </span></span><br><span class="line"><span class="params">                              TimeUnit unit,  </span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,  </span></span><br><span class="line"><span class="params">                              ThreadFactory threadFactory,  </span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler)</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||  </span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||  </span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||  </span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();  </span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();  </span><br><span class="line">        <span class="built_in">this</span>.acc = System.getSecurityManager() == <span class="literal">null</span> ?  </span><br><span class="line">                <span class="literal">null</span> :  </span><br><span class="line">                AccessController.getContext();  </span><br><span class="line">        <span class="built_in">this</span>.corePoolSize = corePoolSize;  </span><br><span class="line">        <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;  </span><br><span class="line">        <span class="built_in">this</span>.workQueue = workQueue;  </span><br><span class="line">        <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);  </span><br><span class="line">        <span class="built_in">this</span>.threadFactory = threadFactory;  </span><br><span class="line">        <span class="built_in">this</span>.handler = handler;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>序号</th><th>参数名称</th><th>参数解释</th><th>春运形象说明</th></tr></thead><tbody><tr><td>1</td><td>corePoolSize</td><td>表示常驻核心线程数，如果大于0，即使本地任务执行完也不会被销毁</td><td>日常固定的列车数辆（不管是不是春运，都要有固定这些车次运行）</td></tr><tr><td>2</td><td>maximumPoolSize</td><td>表示线程池能够容纳可同时执行的最大线程数</td><td>春运客流量大，临时加车，加车后，总列车次数不能超过这个最大值，否则就会出现调度不开等问题</td></tr><tr><td>3</td><td>keepAliveTime</td><td>表示线程池中线程空闲的时间，当空闲时间达到该值时，线程会被销毁，只剩下 <code>corePoolSize</code> 个线程位置</td><td>春运压力过后，临时的加车（如果空闲时间超过<code>keepAliveTime</code>）就会被撤掉，只保留日常固定的列车车次数量用于日常运营</td></tr><tr><td>4</td><td>unit</td><td><code>keepAliveTime</code> 的时间单位，最终都会转换成【纳秒】，因为CPU的执行速度杠杠滴</td><td><code>keepAliveTime</code> 的单位，春运以【天】为计算单位</td></tr><tr><td>5</td><td>workQueue</td><td>当请求的线程数大于 <code>maximumPoolSize</code> 时，线程进入该阻塞队列</td><td>春运压力异常大，即便加车后（达到<code>maximumPoolSize</code>）也不能满足要求，所有乘坐请求都会进入该阻塞队列中排队</td></tr><tr><td>6</td><td>threadFactory</td><td>顾名思义，线程工厂，用来生产一组相同任务的线程，同时也可以通过它增加前缀名，虚拟机栈分析时更清晰</td><td>比如（北京——上海）就属于该段列车所有前缀，表明列车运输职责</td></tr><tr><td>7</td><td>handler</td><td>执行拒绝策略，当 <code>workQueue</code> 达到上限，就要通过这个来处理，比如拒绝，丢弃等，这是一种限流的保护措施</td><td>当<code>workQueue</code>排队也达到队列最大上线，就要提示无票等拒绝策略了,因为我们不能加车了，当前所有车次已经满负载</td></tr></tbody></table><h1 id="线程池作用"><a href="#线程池作用" class="headerlink" title="线程池作用"></a>线程池作用</h1><p>总的来说分为相对于手动创建的优势（自动化创建和管理）、实现拓展功能（任务线程队列管理、定时执行和周期执行）以及不同服务之间解耦的优势。<br>    1. 利用线程池管理并使用线程，控制最大并发数（手动创建线程很难得到保证）<br>    2. 实现任务线程队列缓存策略和拒绝机制<br>    3. 实现某些与实践相关的功能，如定时执行，周期执行等（比如列车指定时间运行）<br>    4. 隔离线程环境，比如，交易服务和搜索服务在同一台服务器上，分别开启两个线程池，交易线程的资源消耗明显要大。因此，通过配置独立的线程池，将较慢的交易服务与搜索服务个离开，避免个服务线程互相影响</p><h1 id="默认的4种线程池"><a href="#默认的4种线程池" class="headerlink" title="默认的4种线程池"></a>默认的4种线程池</h1><ol><li><p>newSingleThreadExecutor<br> （单线程）<br> 创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p></li><li><p>newFixeThreadPool<br> （固定最大线程数）<br> 创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p></li><li><p>newCachedThreadPool<br> （使用空闲回收策略类似于keepAliveTime）<br> 创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</p></li><li><p>newScheduledThreadPool<br> 创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p></li></ol><h1 id="工作队列（workQueue）"><a href="#工作队列（workQueue）" class="headerlink" title="工作队列（workQueue）"></a>工作队列（workQueue）</h1><p>常用的workQueue有3种：</p><ol><li>SynchronousQueue<br>SynchronousQueue<strong>没有容量</strong>，是无缓冲等待队列，是一个<strong>不存储元素的阻塞队列</strong>，会直接将任务交给消费者（即丢给空闲的线程去执行），当所有线程均处于忙碌状态且线程数等于最大线程数时会触发拒绝策略，所以使用SynchronousQueue阻塞队列一般要求maximumPoolSizes为无界，避免线程拒绝执行操作。</li><li>LinkedBlockingQueue<br> LinkedBlockingQueue如果不指定大小，默认值是 <code>Integer.MAX_VALUE</code>。<br> 与ArrayBlockingQueue不同的是，LinkedBlockingQueue内部分别使用了takeLock 和 putLock 对并发进行控制，也就是说，添加和删除操作并不是互斥操作，可以同时进行，这样也就可以大大提高吞吐量。</li><li>DelayQueue<br> DelayQueue是一个延迟队列，无界，队列中每个元素都有过期时间，当从队列获取元素时，只有过期元素才会出队列，而队列头部的元素是过期最快的元素。可以用来定时任务调度or缓存。</li></ol><h1 id="线程池拒绝策略"><a href="#线程池拒绝策略" class="headerlink" title="线程池拒绝策略"></a>线程池拒绝策略</h1><ol><li>AbortPolicy：默认的拒绝策略，会 throw RejectedExecutionException 拒绝</li><li>CallerRunsPolicy：提交任务的线程自己去执行该任务</li><li>DiscardOldestPolicy：丢弃最老的任务，其实就是把最早进入工作队列的任务丢弃，然后把新任务加入到工作队列</li><li>DiscardPolicy：相当大胆的策略，直接丢弃任务，没有任何异常抛出</li></ol><h1 id="禁止使用Executors创建线程池"><a href="#禁止使用Executors创建线程池" class="headerlink" title="禁止使用Executors创建线程池"></a>禁止使用Executors创建线程池</h1><ol><li>大部分情况下，其使用的工作队列默认最大数为Integer.MAX_VALUE，过于消耗资源</li><li>其使用默认拒绝策略（直接拒绝），不符合实际需求。<br>因此推荐使用 ThreadPoolExecutor来创建，可以在创建线程池时自定义不同的工作队列。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线程池参数&quot;&gt;&lt;a href=&quot;#线程池参数&quot; class=&quot;headerlink&quot; title=&quot;线程池参数&quot;&gt;&lt;/a&gt;线程池参数&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;</summary>
      
    
    
    
    
    <category term="Java" scheme="https://boneink.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>java-多线程</title>
    <link href="https://boneink.github.io/2022/05/22/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://boneink.github.io/2022/05/22/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2022-05-22T04:00:00.000Z</published>
    <updated>2022-05-22T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多线程创建"><a href="#多线程创建" class="headerlink" title="多线程创建"></a>多线程创建</h1><ol><li>Thread：通过继承Thread的方式，可以创建一个线程，需要重写其中的run方法，启动线程时，通过调用start方法启动。形如：<br> ![[Pasted image 20231002104839.png]]</li><li>Runnable：通过实现Runnable接口的方式，可以创建一个线程，需要重写其中的run方法，启动线程时，将自定义类的实例作为一个参数，调用Thread的构造方法，得到一个线程实例，再调用start方法启动。形如：<br> ![[Pasted image 20231002104912.png]]</li><li>Callable：通过实现callable接口的方式，可以创建一个线程，需要重写其中的call方法。启动线程时，需要新建一个Callable的实例，再用FutureTask实例包装它，最终，再包装成Thread实例，调用start方法启动，并且，可以通过FutureTask的get方法来获取返回值。形如：<br> ![[Pasted image 20231002105043.png]]<br> 备注：其中，由于Runnable是通过接口实现的，可以通过implements实现多个接口，更加灵活，同时由于在使用Runnable时要创建一个该类实例再传入Thread，因此可以实现线程创建和具体业务之间的解耦，多线程的资源共享。其次，callable可以通过get方法获取返回值，同时还能对线程出现的异常进行处理。</li><li>线程池<br> 可用性排序：线程池 &gt; Callable &gt; Runnable &gt; Thread<br> 1、使用继承Thread的方式，意味着该类无法继承其他的类，这样是非常不便利的，所以实现runnable接口要优于继承Thread的方式。<br> 2、FutureTask本质上和直接实现Runnable接口是一样的，但是FutureTask可以通过get方法获取到返回值，所以要优于直接实现Runnable接口的。<br> 3、线程池要优于前面几种，在项目开发的时候是主要使用线程池来创建线程。</li></ol><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><ol><li><p>Runnable接口与Callable接口的区别</p><ul><li>同：<br> 都是接口。</li><li>异：<br> Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；<br> Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</li></ul></li><li><p>volatile和synchronized区别（参考：这个(<a href="https://mp.weixin.qq.com/s?__biz=MzAxNTc4ODYzOQ==&amp;mid=2247484340&amp;idx=1&amp;sn=422956f18e68621b7e4fbea7f50a81ec&amp;chksm=9bfffc84ac88759269192bb461a3863bb7a75c4c9cc3eb8e9f67f2a3e739d9fbe2611a9dc737&amp;scene=178&amp;cur_album_id=1519640768087457793#rd)%E5%92%8C%E8%BF%99%E4%B8%AA(https://mp.weixin.qq.com/s?__biz=MzAxNTc4ODYzOQ==&amp;mid=2247484342&amp;idx=1&amp;sn=781f86d246423d70dfe369b8274a18cd&amp;chksm=9bfffc86ac8875900e0f172c520a54b5088061b8c0f8d9f7d3bf9083825654660957532ef904&amp;scene=178&amp;cur_album_id=1519640768087457793#rd)">https://mp.weixin.qq.com/s?__biz=MzAxNTc4ODYzOQ==&amp;mid=2247484340&amp;idx=1&amp;sn=422956f18e68621b7e4fbea7f50a81ec&amp;chksm=9bfffc84ac88759269192bb461a3863bb7a75c4c9cc3eb8e9f67f2a3e739d9fbe2611a9dc737&amp;scene=178&amp;cur_album_id=1519640768087457793#rd)和这个(https://mp.weixin.qq.com/s?__biz=MzAxNTc4ODYzOQ==&amp;mid=2247484342&amp;idx=1&amp;sn=781f86d246423d70dfe369b8274a18cd&amp;chksm=9bfffc86ac8875900e0f172c520a54b5088061b8c0f8d9f7d3bf9083825654660957532ef904&amp;scene=178&amp;cur_album_id=1519640768087457793#rd)</a><br> volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。<br> 但是volatile关键字只能用于变量，而synchronized关键字可以修饰方法以及代码块。<br> synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。<br> 多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞。<br> volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。<br> volatile关键字主要用于解决变量在多个线程之间的<strong>可见性</strong>，而 synchronized关键字解决的是多个线程之间访问资源的同步性。<br> synchronized 保证三大性：<strong>原子性，有序性，可见性</strong>，<br> volatile 保证<strong>有序性，可见性，不能保证原子性</strong>。</p></li><li><p>sleep方法和wait方法有什么区别<br> sleep方法和wait方法都可以用来放弃CPU一定的时间暂停当前运行的线程，不同点在于如果线程持有某个对象的监锁，<strong>sleep方法不会释放这个对象的锁，wait方法会释放这个对象的锁</strong>，sleep必须要设定时间，而wait可以设定也可以不设定。<br> Sleep属于Thread类，wait属于Object类。</p></li><li><p>什么是多线程的上下文切换<br> 多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。</p></li><li><p>如果提交任务时，线程池队列已满，会发生什么<br> 如果使用的LinkedBlockingQueue，也就是无界队列的话，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以无限存放任务；如果使用的是有界队列比方说ArrayBlockingQueue的话，则会使用拒绝策略RejectedExecutionHandler处理满了的任务。</p></li><li><p>什么是线程局部变量ThreadLocal<br> 线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。 它是一种特殊的线程绑定机制，将变量与线程 绑定 在一起，为每一个线程维护一个独立的变量副本。Java 提供 ThreadLocal 类来支持线程局部变量，是一种实现线程安全的方式。<br> ThreadLocal 无法解决共享对象的更新问题， ThreadLocal 对象建议使用 static修饰。这个变量是针对一个线程内所有操作共有的，所以设置为静态变量，所有此类实例共享此静态变量 ，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象 ( 只要是这个线程内定义的 ) 都可以操控这个变量。</p></li><li><p>ThreadLocal造成内存泄露<br> 每个Thread 维护一个 <code>ThreadLocalMap</code> 映射表，这个映射表的 key 是 <code>ThreadLocal</code>实例本身，value 是真正需要存储的 Object。也就是说 ThreadLocal 本身并不存储值，它只是作为一个 key 来让线程从 ThreadLocalMap 获取 value。<br> ![[Pasted image 20240306191733.png]]<br> ThreadLocalMap 是使用 ThreadLocal 的弱引用作为 Key 的，弱引用的对象在 GC 时会被回收。</p><p> ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用来引用它，那么系统 GC 的时候，这个ThreadLocal势必会被回收（为什么会被回收下面讲到），然后ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value。</p><p> 如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value 永远无法回收，造成内存泄漏。<br> 因此，弱引用尚且有内存泄漏的风险，强引用更加。使用线程池的时候，自定义的线程数不规范，若使用强引用，内存泄漏的风险更高。</p></li><li><p>如何防止内存泄漏：<br> ThreadLocal在调用get,set或remove方法时，会对key进行判断若entry的key为null，则进行删除，从而释放value对象所占用的内存。</p></li><li><p>线程池中submit() 和 execute()方法有什么区别<br> 两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中, 而submit()方法可以返回持有计算结果的Future对象。</p></li><li><p>start 与 run 的区别</p><ol><li><p>start（）方法来启动线程，真正实现了多线程运行。这时无需等待 run 方法体代码执行完毕，可以直接继续执行下面的代码。</p></li><li><p>通过调用 Thread 类的 start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。</p></li><li><p>方法 run()称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，开始运行 run 函数当中的代码。 Run 方法运行结束， 此线程终止。然后 CPU 再调度其它线程。</p></li></ol></li><li><p>synchronized 和 ReentrantLock 的区别<br>同：</p><ol><li>都是用来协调多线程对共享对象、变量的访问</li><li>都是可重入锁，同一线程可以多次获得同一个锁</li><li>都保证了可见性和互斥性<br>异：<br>（由于两者ReentrantLock 是API层面，synchronized 是JVM层面，因此在精细度上不同，前者能实现的功能更加丰富，使用起来更灵活，但容错率会更低，需要在使用时手动处理一些情况，而synchronized虽然功能性上没有前者灵活，但JVM内部已给很多情况进行了处理）</li><li>ReentrantLock 显示的获得、释放锁，synchronized 隐式获得释放锁</li><li>ReentrantLock 可响应中断、可轮回，synchronized 是不可以响应中断的，为处理锁的 不可用性提供了更高的灵活性</li><li>ReentrantLock 是 API 级别的，synchronized 是 JVM 级别的</li><li>ReentrantLock 可以实现公平锁</li><li>ReentrantLock 通过 Condition 可以绑定多个条件</li><li>底层实现不一样， synchronized 是同步阻塞，使用的是悲观并发策略，lock 是同步非阻 塞，采用的是乐观并发策略</li><li>Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言 实现。</li><li>synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生； 而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象， 因此使用 Lock 时需要在 finally 块中释放锁。</li><li>Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用 synchronized 时， 等待的线程会一直等待下去，不能够响应中断。</li><li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li><li>Lock 可以提高多个线程进行读操作的效率，既就是实现读写锁等。</li></ol></li><li><p>线程的调度策略<br>线程调度器选择优先级最高的线程运行，但是，如果发生以下情况，就会终止线程的运行：<br>（1）线程体中调用了 yield 方法让出了对 cpu 的占用权利<br>（2）线程体中调用了 sleep 方法使线程进入睡眠状态<br>（3）线程由于 IO 操作受到阻塞<br>（4）另外一个更高优先级线程出现<br>（5）在支持时间片的系统中，该线程的时间片用完</p></li><li><p>如何停止一个正在运行的线程？</p><ol><li>使用退出标志（比如return），使线程正常退出，也就是当run方法完成后线程终止。</li><li>使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法。</li><li>使用interrupt方法中断线程。</li></ol></li><li><p>异常捕获</p><ol><li>不同启动方式：<ol><li>使用execute()启动时，异常会被正常抛出</li><li>在使用submit()启动时，异常会被其返回的future对象捕获，并不会抛出，在调用future.get方法时，异常会被抛出。</li></ol></li><li>父线程捕获子线程异常：<ol><li>对于execute()方式启动的，可以使用ThreadFactory的setDefaultUncaughtExceptionHandler捕获。进行全局异常处理。</li><li>对于submit()方式启动的，可以使用ThreadPoolExecutor的afterExecute方法捕获异常。</li></ol></li></ol></li><li><p>线程的阻塞、就绪和等待有什么区别</p><ol><li><p><strong>阻塞（Blocked）状态</strong>： 当线程试图获取一个同步锁而未能获取时，或者线程在等待I&#x2F;O操作完成、等待线程间的协作信号（如调用了<code>wait()</code>方法）等情况时，线程会进入阻塞状态。在阻塞状态下，线程不会执行任何代码，也不参与CPU调度，直到线程等待的条件得到满足，例如锁被释放、I&#x2F;O操作完成或接收到其他线程的通知等。</p></li><li><p><strong>就绪（Ready）状态</strong>： 就绪状态的线程已经具备了执行所需的一切条件，但CPU还没有分配给它执行时间。线程调度器会根据一定的策略（如时间片轮转、优先级调度等）从就绪队列中选择一个线程进行执行。一旦被选中，就绪状态的线程就会转为运行状态（Running）。当一个正在运行的线程执行了yield()方法或者执行完其时间片后，也可能重新回到就绪状态。</p></li><li><p><strong>等待（Waiting）状态</strong>： 等待状态和阻塞状态有些相似，但通常是线程主动放弃CPU使用权并等待其他线程的通知。线程调用<code>wait()</code>、<code>join()</code>、<code>Condition.await()</code>等方法时，会进入等待状态，并且不会被CPU调度，直到其他线程发出相应信号（如调用<code>notify()</code>或<code>notifyAll()</code>方法）。等待状态的线程会释放持有的所有监视器锁（Monitor Lock）。</p></li></ol><p>总结起来，线程状态的变化反映了线程在执行过程中的不同阶段，其中阻塞状态通常是因为线程等待某个外部条件解除，而就绪状态则表示线程随时可以运行，只是还没被调度；等待状态同样是线程暂停执行，但它往往是线程间的协作状态，需要其他线程明确唤醒。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多线程创建&quot;&gt;&lt;a href=&quot;#多线程创建&quot; class=&quot;headerlink&quot; title=&quot;多线程创建&quot;&gt;&lt;/a&gt;多线程创建&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;Thread：通过继承Thread的方式，可以创建一个线程，需要重写其中的run方法，启动线程时，通过调</summary>
      
    
    
    
    
    <category term="Java" scheme="https://boneink.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>java-集合类</title>
    <link href="https://boneink.github.io/2022/05/22/java-%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    <id>https://boneink.github.io/2022/05/22/java-%E9%9B%86%E5%90%88%E7%B1%BB/</id>
    <published>2022-05-22T04:00:00.000Z</published>
    <updated>2022-05-22T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java集合类"><a href="#Java集合类" class="headerlink" title="Java集合类"></a>Java集合类</h1><h2 id="Java集合类别："><a href="#Java集合类别：" class="headerlink" title="Java集合类别："></a>Java集合类别：</h2><ol><li><p><strong>List（列表）</strong>：</p><ul><li><code>ArrayList</code>：基于动态数组实现的列表，允许快速随机访问，插入和删除操作在列表两端较快，中间较慢，且元素有序且可重复。</li><li><code>LinkedList</code>：基于双向链表实现的列表，插入和删除操作在任何位置都很高效，但随机访问较慢，同样有序且可重复。</li><li><code>Vector</code>：类似ArrayList的老式同步容器，线程安全，但在多线程环境中性能较低。</li><li><code>Stack</code>：继承自Vector，提供栈操作（后进先出，LIFO）。</li></ul></li><li><p><strong>Set（集合）</strong>：</p><ul><li><code>HashSet</code>：基于哈希表实现，不允许存储重复元素，无序。</li><li><code>LinkedHashSet</code>：继承自HashSet，除了不允许存储重复元素之外，还保持了元素插入的顺序。</li><li><code>TreeSet</code>：基于红黑树实现，不允许存储重复元素，自动排序（需元素类型实现Comparable接口或提供Comparator）。</li></ul></li><li><p><strong>Queue（队列）</strong>：</p><ul><li><code>LinkedList</code>（也可以作为队列使用，通过Queue接口操作）</li><li><code>ArrayDeque</code>：高效的双端队列，支持FIFO（先进先出）和LIFO（后进先出）操作。</li><li><code>PriorityQueue</code>：优先级队列，基于堆实现，元素自动排序。</li></ul></li><li><p><strong>Map（映射）</strong>：</p><ul><li><code>HashMap</code>：基于哈希表实现，键值对存储，无序，允许null键和值，但键必须唯一。</li><li><code>LinkedHashMap</code>：继承自HashMap，保持插入顺序或最近最少使用(LRU)访问顺序。</li><li><code>TreeMap</code>：基于红黑树实现，键值对存储，键自动排序。</li><li><code>Hashtable</code>：类似于HashMap的老式同步容器，线程安全，不允许存储null键和值。</li><li><code>ConcurrentHashMap</code>：线程安全的HashMap变体，适合并发环境。</li></ul></li></ol><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol><li>HashMap 和 Hashtable 的区别：<br> <strong>相同点：</strong> 都是实现来Map接口（hashTable还实现了Dictionary 抽象类）。<br> <strong>不同点：</strong><ul><li>历史原因:Hashtable 是基于陈旧的 <strong>Dictionary 类</strong>的，HashMap 是 Java 1.2 引进的 <strong>Map 接口</strong> 的一个实现，HashMap把Hashtable 的contains方法去掉了，改成containsvalue 和containsKey。因为contains方法容易让人引起误解。</li><li>同步性:Hashtable 的方法是 Synchronize 的，线程安全；而 HashMap 是线程不安全的，不是同步的。所以只有一个线程的时候使用hashMap效率要高。</li><li>值：<strong>HashMap对象的key、value值均可为null。HahTable对象的key、value值均不可为null。</strong></li><li>容量：HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75。</li><li>HashMap扩容时是当前容量翻倍即:capacity * 2，Hashtable扩容时是容量翻倍+1 即:capacity * 2+1。</li></ul></li><li>HashSet 和 HashMap 区别<br> HashSet 底层就是基于 HashMap 实现的。只不过HashSet里面的HashMap所有的value都是同一个Object而已，因此HashSet也是非线程安全的。</li><li>ConcurrentHashMap和Hashtable的区别<br> JDK1.7的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表&#x2F;红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类，都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；<ul><li>在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</li><li>Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li></ul></li><li>Set和List的区别<ol><li>Set 接口实例存储的是<strong>无序的，不重复的数据</strong>。List 接口实例存储的是<strong>有序的，可以重复的元素</strong>。都可以存储null值，但是set不能重复所以最多只能有一个空元素。</li><li>Set检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 ，<strong>实现类有:HashSet，TreeSet</strong>。</li><li>List和数组类似，可以动态增长，根据实际存储的数据的长度自动增长List的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 ，<strong>实现类有 ArrayList，LinkedList，Vector</strong></li></ol></li><li>Collection和Collections的区别<br> Collection是单列集合的顶层接口,Map是双列集合的顶层接口<br> Collections是一个集合的工具类，提供了排序、查找等操作集合的一些常用方法</li><li>Collection框架中实现比较要怎么做？<br> 第一种，实体类实现<code>Comparable&lt;T&gt;</code>接口，并实现 <code>compareTo(T t)</code> 方法，我们称为内部比较器。<br> 第二种，创建一个外部比较器，这个外部比较器要实现Comparator接口的 <code>compare(T t1, T t2)</code>方法。</li><li>HashMap底层数据结构<ol><li>jdk1.7：<ul><li>数据结构：HashMap由数组+链表组成，数组的每个元素都是一个链表头结点，当哈希冲突（即不同的键计算出相同的哈希值）发生时，会将冲突的键值对放入对应的链表中。</li><li>扩容机制：当HashMap的大小超过负载因子（默认0.75）与当前容量的乘积时，会触发扩容操作，扩容时会创建一个新的容量翻倍的数组，并将旧数组中的所有元素重新哈希到新数组中。</li></ul></li><li>jdk1.8:<ul><li>数据结构：HashMap依然由数组+链表组成，但是当链表长度大于阈值（默认为8）时，链表会转换为红黑树结构（树形化）。因此，JDK 1.8的HashMap结构变为数组+链表+红黑树，这极大地优化了在高度冲突时的查找性能。</li><li>新的Node结构：HashMap的内部节点类由原来的Entry变成了Node，并且在链表结构中引入了forwarding node来处理扩容时的迁移操作，使得扩容更加平滑和高效。</li><li>扩容机制：扩容仍然是容量翻倍，但不再是全部重哈希，而是采用了一种更加聪明的方式，只将正在扩容的桶链表或红黑树进行迁移，其他桶不受影响，提高了并发扩容时的性能。</li></ul></li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java集合类&quot;&gt;&lt;a href=&quot;#Java集合类&quot; class=&quot;headerlink&quot; title=&quot;Java集合类&quot;&gt;&lt;/a&gt;Java集合类&lt;/h1&gt;&lt;h2 id=&quot;Java集合类别：&quot;&gt;&lt;a href=&quot;#Java集合类别：&quot; class=&quot;header</summary>
      
    
    
    
    
    <category term="Java" scheme="https://boneink.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>java-反射机制</title>
    <link href="https://boneink.github.io/2022/05/21/java-%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>https://boneink.github.io/2022/05/21/java-%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</id>
    <published>2022-05-21T04:00:00.000Z</published>
    <updated>2022-05-21T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h1><p>程序员编写的Java源程序（.java文件）在经过编译器编译之后被转换成字节代码（.class 文件），类加载器将.class文件中的二进制数据读入到内存中，将其放在方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。<br>类加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。<br>![[Pasted image 20240304202935.png]]</p><h1 id="类生命周期"><a href="#类生命周期" class="headerlink" title="类生命周期"></a>类生命周期</h1><p>类的生命周期包括：加载、验证、准备、解析、初始化、使用、卸载7个阶段。其中加载、验证、准备、初始化、卸载5个阶段是按照这种顺序按部就班的开始，而解析阶段则不一定：某些情况下，可以在初始化之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定，其实就是多态），例如子类重写父类方法。<br>![[Pasted image 20240304203349.png]]</p><h2 id="1-加载阶段："><a href="#1-加载阶段：" class="headerlink" title="1. 加载阶段："></a>1. 加载阶段：</h2><ul><li>获取目标类的字节流</li><li>字节流加载为方法区的运行时数据结构</li><li>堆中生成该类的java.lang.Class对象，作为对方法区中这些数据的访问入口。<br>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。</li></ul><h2 id="2-验证阶段："><a href="#2-验证阶段：" class="headerlink" title="2. 验证阶段："></a>2. 验证阶段：</h2><p>确保被加载的类的正确性，分为4个验证阶段：</p><ul><li>文件格式验证</li><li>元数据验证</li><li>字节码验证</li><li>符号引用验证</li></ul><h2 id="3-准备阶段："><a href="#3-准备阶段：" class="headerlink" title="3. 准备阶段："></a>3. 准备阶段：</h2><p>为类的静态变量分配内存，并初始化默认值（同时被final和static修饰的直接初始化为指定的常量值） 。</p><h2 id="4-解析阶段："><a href="#4-解析阶段：" class="headerlink" title="4. 解析阶段："></a>4. 解析阶段：</h2><p>虚拟机将常量池内符号引用（即仅声明引用）替换为直接引用（查询实际地址）。</p><h2 id="5-初始化阶段："><a href="#5-初始化阶段：" class="headerlink" title="5. 初始化阶段："></a>5. 初始化阶段：</h2><p>为类的静态变量赋予正确的初始值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;类加载过程&quot;&gt;&lt;a href=&quot;#类加载过程&quot; class=&quot;headerlink&quot; title=&quot;类加载过程&quot;&gt;&lt;/a&gt;类加载过程&lt;/h1&gt;&lt;p&gt;程序员编写的Java源程序（.java文件）在经过编译器编译之后被转换成字节代码（.class 文件），类加载器将.</summary>
      
    
    
    
    
    <category term="Java" scheme="https://boneink.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>java-反射机制</title>
    <link href="https://boneink.github.io/2022/05/21/java-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>https://boneink.github.io/2022/05/21/java-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</id>
    <published>2022-05-21T04:00:00.000Z</published>
    <updated>2022-05-21T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h1><p>反射（Reflection），Java 中的反射机制是指，Java 程序在运行期间可以获取到一个对象的全部信息。<br>反射机制一般用来解决Java 程序运行期间，对某个实例对象一无所知的情况下，如何调用该对象内部的方法问题。<br>Object-C、C#、JavaScript、PHP、Python、Erlang等动态语言可以在运行时改变自身结构，java通过反射机制可以实现类似于动态语言的特性，使得编程更加灵活。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在Java 程序中，JVM 加载完一个类后，在堆内存中就会产生该类的一个 Class 对象，一个类在堆内存中最多只会有一个 Class 对象，这个Class 对象包含了该类的完整结构信息，我们通过这个 Class 对象便可以得到该类的完整结构信息。<br>同时，由于反射机制实现是动态加载，因此即使该类不存在，在编译时也并不会报错，会在运行过程中创建该类的Class对象时报错。<br>![[Pasted image 20240304201212.png]]</p><h2 id="优劣"><a href="#优劣" class="headerlink" title="优劣"></a>优劣</h2><p>优点：可以动态地创建和使用对象，反射机制是 Java 框架的底层核心，其使用灵活，没有反射机制，底层框架就失去支撑。<br>缺点：使用反射基本是解释执行，对程序执行速度有影响。</p><h2 id="获取Class方法："><a href="#获取Class方法：" class="headerlink" title="获取Class方法："></a>获取Class方法：</h2><ol><li><p>调用运行时类的属性：.class<br>前提：若已知<strong>具体的类</strong>，通过类的class属性获取，该方法最为安全可靠， 程序性能最高<br>示例： Class clazz1 &#x3D; String.class;</p></li><li><p>通过运行时类的对象,调用getClass()<br>前提：已知<strong>某个类的实例</strong>，调用该实例的getClass()方法获取Class对象<br>示例：Class clazz &#x3D; “<a href="http://www.atguigu.com”.getclass()/">www.atguigu.com”.getClass()</a>;</p></li></ol><p>3.调用Class的静态方法：forName(String classPath)<br>前提：已知<strong>一个类的全类名</strong>，且该类在类路径下，可通过Class类的静态方法forName() 获取，可能抛出ClassNotFoundException<br>示例： Class clazz &#x3D; Class.forName(“java.lang.String”);</p><ol start="4"><li>使用<strong>类的加载器</strong>：ClassLoader<br>示例：<br>ClassLoader cl &#x3D; this.getClass().getClassLoader();<br>Class clazz4 &#x3D; cl.loadClass(“类的全类名”);</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java反射&quot;&gt;&lt;a href=&quot;#Java反射&quot; class=&quot;headerlink&quot; title=&quot;Java反射&quot;&gt;&lt;/a&gt;Java反射&lt;/h1&gt;&lt;p&gt;反射（Reflection），Java 中的反射机制是指，Java 程序在运行期间可以获取到一个对象的全部信</summary>
      
    
    
    
    
    <category term="Java" scheme="https://boneink.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>挖矿木马总结</title>
    <link href="https://boneink.github.io/2022/03/01/%E6%8C%96%E7%9F%BF%E6%9C%A8%E9%A9%AC%E6%80%BB%E7%BB%93/"/>
    <id>https://boneink.github.io/2022/03/01/%E6%8C%96%E7%9F%BF%E6%9C%A8%E9%A9%AC%E6%80%BB%E7%BB%93/</id>
    <published>2022-03-01T04:00:00.000Z</published>
    <updated>2022-03-01T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="挖矿木马总结"><a href="#挖矿木马总结" class="headerlink" title="挖矿木马总结"></a>挖矿木马总结</h1><h3 id="腾讯《2020年挖矿木马年度报告》"><a href="#腾讯《2020年挖矿木马年度报告》" class="headerlink" title="腾讯《2020年挖矿木马年度报告》"></a>腾讯《2020年挖矿木马年度报告》</h3><p>2020 年各类数字加密货币价格迎来暴涨，比特币价格一度超过 5 万美元 &#x2F; BTC，市值达到 9200 亿美 元，是 2019 年底的 10 倍之多，达到了历史最高点。同期挖矿木马最偏好的门罗币价格也同步增长 6 倍，这意味着黑客通过进行门罗币挖矿，兑现后收益可达到以往收益的 6 倍。在如此大利益诱惑之下， 黑产团伙已闻风而动，纷纷加入了对主机计算资源的争夺，一个典型现象就是，有大量挖矿木马在运行 时，会尝试清除竞争对手木马。</p><h4 id="挖矿家族Top"><a href="#挖矿家族Top" class="headerlink" title="挖矿家族Top"></a>挖矿家族Top</h4><p>2020 年度挖矿木马家族排名前三的分别为 DTLMiner（永恒之蓝下载器木马）、H2Miner、 GuardMiner，榜单中有通过永恒之蓝漏洞传播的为 DTLMiner、NSABuffMiner、 NSAGluptebaMiner，有利用 Redis、Hadoop、Weblogic、Drupal、thinkphp 等应用程序漏洞传播的 为 H2Miner、GuardMiner、z0Miner、8220Miner 等家族，以及主要通过弱口令爆破进行传播的为 KoiMiner 家族。</p><p><img src="https://wx2.sinaimg.cn/large/69b019d1gy1gnzmju6hq1j20fc0btdg1.jpg"></p><h4 id="入侵通道"><a href="#入侵通道" class="headerlink" title="入侵通道"></a>入侵通道</h4><ol><li><p>利用漏洞</p><p>远程代码执行漏洞（RCE）可以让远程攻击者直接向后台服务器远程注入操作系统命令或者恶意代码，从而控制后台系统，挖矿木马攻击时最常用的远程代码执行漏洞 TOP 统计如下：</p></li></ol><p><img src="https://wx4.sinaimg.cn/large/69b019d1gy1gnzmm3b76sj20fe09v0ue.jpg"></p><p><img src="https://wx4.sinaimg.cn/large/69b019d1gy1gnzmmn5o43j20fo0an3z2.jpg"></p><ol start="2"><li><p>爆破攻击</p><p>用户在设置系统登陆密码时，为了方便记忆往往采用默认的空口令或者非常简单的密码例如 admin、root、test、111111、123456 等，使用这些密码导致黑客可以轻易猜解并登陆，从而入侵系统。</p><p>许多挖矿木马在传播时也会针对系统的弱密码进行爆破攻击，根据腾讯安全 2020 年云上安全报告提供的数据，默认用户名、端口名被爆破攻击的次数达数十亿次之多。常被挖矿木马爆破攻击的服务类型包括 SSH、Mssql、Redis 等，各类型爆破攻击对应的挖矿家族如下：</p><p>MS SQL</p><p>永恒之蓝下载器木马、GuardMiner 、MrbMiner、BasedMiner、贪吃蛇挖矿木马、快 GO 旷工</p><p>SSH 爆破</p><p>永恒之蓝下载器木马、Ks3_Miner、LoggerMiner、8220Miner、DDG</p><p>Redis 爆破</p><p>永恒之蓝下载器木马、H2Miner、GuardMiner、DDG</p><p>Msql 爆破</p><p>Mykings</p></li><li><p>僵尸网络渠道</p><p>具有僵尸网络特征的挖矿木马 TOP 榜如下，其中前三位是 DTLMiner（永恒之蓝下载器木马）、H2Miner、GuardMiner 为老牌僵尸网络，由于控制该僵尸网络的幕后黑客团伙仍在不断更新其攻击方法，使其在出现后的数年里仍然保持很高的活跃度。</p><p>在 2020 年新活跃的挖矿木马家族以 Linux 服务器为攻击对象的居多，例如通过 SSH 弱口令攻击的 Outlaw、Prometei，通过 Docker Remote API 漏洞入侵的 TeamTNT，以及通过 Nexus Repository Manager 3 弱密码入侵，利用 Mysql、Tomcat 弱口令爆破，Weblogic 远程代码执行漏洞进行横向扩散的 Sysrv-hello 家族等等。</p><p><img src="https://wx2.sinaimg.cn/large/69b019d1gy1gnzmnlovikj20fu0btt90.jpg"></p></li><li><p>入侵后开展恶意行为</p><p>4.1 通过linux定时任务</p><p>4.2 通过linux系统服务：启动项&#x2F;安装服务</p><p>4.3 Windows WMI</p></li></ol><h4 id="挖矿类型："><a href="#挖矿类型：" class="headerlink" title="挖矿类型："></a>挖矿类型：</h4><p><strong>基于浏览器的挖矿</strong></p><p>基于浏览器的挖矿劫持的实际攻击对象是网站的服务器。受害者经常是僵尸网络的一部分，因为单个受害者还无法完成工作量证明，一般是多个受害者一起完成一个特定任务。恶意JS脚本（大多数攻击者会直接使用修改的coinhive脚本）一般会被注入网页的广告或者自加载资源，以便用户访问网页时可以自动执行。</p><p>由于受害的是用户，而被攻击的服务器本身没有受到什么损害，所以该攻击难以被网站管理员发现。</p><p>正常的coinhive使用时，会事先询问用户是否允许进行挖矿，用户同意后，赚取的收益的30%由coinhive获得，余下的由网站获得。而攻击者修改后的coinhive脚本运行时，获得的收益全由攻击者获得。</p><p><strong>基于恶意软件的挖矿：</strong></p><p>感染计算机，安装加密矿工（样本），并使用从受害者电脑窃取得来的信息来建立用于非法资金转移的钱包。无需像勒索软件那样对目标进行勒索获取赎金，而是直接从良性互联网用户那里获得加密货币。</p><p>偷渡式挖矿，在受害者系统上只停留很短的时间，然后进入下一个受害者，接着会再次回来并重复这一过程。这种短时间的可用性使其很难被检测到。</p><p>偷渡式下载是一种常见的攻击方法，当用户访问一个嵌入恶意代码的网站时，它会滥用浏览器的合法功能开始自动文件下载或提示下载诱骗用户运行恶意程序。基于恶意软件的挖矿劫持一般会采用这种形式。</p><h3 id="常见的加密货币："><a href="#常见的加密货币：" class="headerlink" title="常见的加密货币："></a>常见的加密货币：</h3><p><strong>比特币</strong>：</p><ol><li>生成coinbase交易，并与其他所有准备打包进区块的交易组成交易列表，通过Merkle树算法生成Merkle根哈希；</li><li>把Merkle根哈希及其他相关字段组装成区块头，将区块头的80字节数据作为工作量证明的输入；</li><li>不停地变更区块头中的随机数，即nonce的数值，并对每次变更后的区块头做双重SHA256运算，将结果值与当前网络的目标值做对比，如果小于目标值则解题成功，工作量证明完成。</li></ol><p><strong>以太坊</strong></p><p>Ethash是以太坊1.0中使用的PoW(工作量证明)算法,它是Hashimoto算法结合Dagger之后产生的一个变种。它的特点是计算的效率基本与CPU无关，却和内存大小和内存带宽正相关。因此通过共享内存的方式大规模部署的矿机芯片并不能在挖矿效率上有线性或者超线性的增长。</p><p>该算法的一般流程如下：</p><p>首先根据块信息计算一个种子(seed, c++代码中为seedhash)<br>使用这个种子，计算出一个16MB的cache数据。轻客户端需要存储这份cache.<br>通过cache，计算出一个1GB(初始大小)的数据集(DAG)，DAG可以理解为是一个完整的搜索空间，全客户端和矿工需要存储完整的DAG，挖矿过程中需要从DAG中重复的随机抽取数据拿去和其他数据计算mixhash，DAG中每个元素的生成只依赖于cache中的少量数据。每到一个新的纪元DAG会完全不一样，并且它的大小也随时间线性增长。<br>由于仅根据cache就可以使用少量内存快速的计算出DAG中指定位置的数据，所以轻客户端只需要存储cache就可以高效的进行校验。</p><p><strong>门罗币</strong></p><p>Monero门罗币XMR计划于2019年的10月份启用最新的RandomX 算法以取代原来的CryptoNight挖矿算法，以继续优化抗ASIC+降低GPU优势来保持门罗POW网络的分散性</p><p>RandomX的行为类似于键控散列函数：它接受一个键。任意输入并产生256位的结果。在底层，RandomX使用虚拟机在一个特殊的指令集中执行程序，该指令集由整数运算、浮点运算和分支组成。这些程序可以动态转换为CPU的本机代码。将RandomX程序转换为x86-64程序集的示例是program.asm…还提供了一种便携式解释模式。</p><p>RandomX可以在具有不同内存需求的两种主要模式下工作：<br>Fast模式-需要2080 MIB共享内存。（该算法要求挖矿者为进程提供超过2G的 RAM，这可能会使加密攻击更难隐藏。）<br>Light模式-只需要256 MIB共享内存，但运行速度要慢得多</p><p><strong>狗狗币</strong></p><p>scrpyt算法是由著名的FreeBSD黑客 Colin Percival为他的备份服务 Tarsnap开发的，当初的设计是为了降低CPU负荷，尽量少的依赖cpu计算，利用CPU闲置时间进行计算，因此scrypt不仅计算所需时间长，而且占用的内存也多，使得并行计算多个摘要异常困难，因此利用rainbow table进行暴力攻击更加困难。scrypt没有在生产环境中大规模应用，并且缺乏仔细的审察和广泛的函数库支持。所以scrpyt一直没有推广开，但是由于其内存依赖的设计特别符合当时对抗专业矿机的设计，成为数字货币算法发展的一个主要应用方向。</p><p>后来有人在SCRYPT的基础上稍作修改形成Scrypt –N算法，改进思路都一样，都是追求更大的内存消耗和计算时间，以有效阻止ASIC专用矿机。</p><p>Scrypt是内存依赖型的POW算法，莱特币采用此算法。第一个使用Scrypt算法的数字货币是Tenebrix，而后该算法被莱特币使用。莱特币创始人在莱特币创世帖中介绍了莱特币采用的共识机制，挖矿算法，发行总量，挖矿难度等相关重要信息。李启威说明了莱特币所使用的挖矿算法为数字货币Tenebrix所使用的Scrypt算法，是一种符合PoW共识机制的算法。Scrypt算法过程中也需要计算哈希值，但是，Scrypt计算过程中需要使用较多的内存资源。</p><p>其它使用Scrypt算法的数字货币还有数码币（DigitalCoin）、狗狗币（DogeCoin）、幸运币（LuckyCoin）、世界币（WorldCoin）等。</p><p><strong>莱特币</strong></p><p>Scrypt算法</p><h3 id="近年来恶意挖矿软件总结："><a href="#近年来恶意挖矿软件总结：" class="headerlink" title="近年来恶意挖矿软件总结："></a>近年来恶意挖矿软件总结：</h3><table><thead><tr><th>文献名</th><th>时间</th><th>期刊&#x2F;会议</th><th>等级</th><th>作者</th><th>学校&#x2F;单位</th><th>贡献</th><th>检测类型</th><th>检测方法</th><th>不足&#x2F;总结</th></tr></thead><tbody><tr><td>Cryptocurrency malware hunting: A deep Recurrent Neural Network  approach</td><td>2020</td><td>Applied  Soft Computing (ASC)</td><td>SCI  Q1</td><td>Abbas  Yazdinejad, Hamed HaddadPajouh, Ali Dehghantanha, Reza M. Parizi, Gautam  Srivastava, Mu-Yen Chen,</td><td>Cyber  Science Lab, School of Computer Science, University of Guelph, Ontario,  Canada</td><td>1.  一个用于检测MS Windows平台上加密货币恶意软件威胁的三层深度循环神经网络(RNN)模型。     2. 一个包含500个真实世界的加密货币恶意软件应用程序和200多个合法加密货币应用程序的数据集。     3. 对传统ml算法和提出的模型进行对比分析，以展示rnnon检测加密货币恶意软件威胁的有效性。</td><td>二进制文件检测</td><td>反编译提取操作码，对每个样本的操作码创建一个特征向量，利用矢量化的数据对深度神经网络模型进行训练。</td><td>拓展：增加字节码、头文件和系统调用等特征，从而降低假阳性率</td></tr><tr><td>An Application Agnostic Defense Against the Dark Arts of  Cryptojacking</td><td>2021</td><td>2021  51st Annual IEEE&#x2F;IFIP International Conference on Dependable Systems and  Networks (DSN)</td><td>CCF  B</td><td>N.  Lachtar, A. A. Elkhail, A. Bacha and H. Malik</td><td></td><td>1.  提出一种应用无关的设计，利用微架构和操作系统层的创新防御加密劫持攻击     2. 演示了通常出现在加密函数中的监控指令     3. 户应用程序的各种指令类型与加密劫持检测的高准确性的相关性     4. 提出一种针对代码混淆、多线程和限制型攻击的健壮设计，同时保留较低误报率。</td><td>二进制文件检测</td><td>分析和统计哈希操作相关的操作码，通过机器学习进行分类操作</td><td></td></tr><tr><td>MineSweeper An In-depth Look into Drive-by Cryptocurrency Mining  and Its Defense</td><td>2018</td><td>Proceedings  of the 2018 ACM SIGSAC Conference on Computer and Communications Security</td><td>CCF  A</td><td>Radhesh  Krishnan Konoth, Emanuele Vineti, Veelasha Moonsamy, Martina Lindorfer,  Christopher Kruegel, Herbert Bos, and Giovanni Vigna</td><td>New  York, NY, USA,</td><td>1.  对偷渡式采矿进行了首次深入评估。       - 互联网上的偷渡式挖矿行为的普遍程度。       - 目前存在多少种偷渡式挖矿服务。       - 偷渡式挖矿采用的规避策略。       - 不同类型的偷渡式挖矿采用的方法。       - 不同类型的偷渡式挖矿的利润。       - 在不同的偷渡式挖矿服务中找到共同特征用于检测。     2. 讨论了为何当前基于黑名单和CPU使用的防御是无效的。     3. 提出了MINESWEEPER这一新的检测方法，通过静态分析识别密码函数，并在运行时监控缓存事件。</td><td>浏览器脚本检测</td><td>1.  匹配原语中的加密计数，计算相似度评分     2. 对于新变体和其他散列算法，计算每个函数循环中加密操作码的计数，对比阈值     3. 对于高度模糊的Wasm模块，检测CPU负载</td><td>1.  爬虫仍需优化。     2. 针对其他设备（如Android手机）的活动研究。     3. 基于静态分析的方法仍容易混淆（但考虑到利润，攻击者会得不偿失）     4. 目前仅针对Wasm的挖矿代码，未来可以考虑分析asm.js。     5. Wasm的加密函数可能会用在其他地方，可能会出现假阳性（但目前wasm还没有被其他用例广泛使用）</td></tr><tr><td>MINOS: A Lightweight Real-Time Cryptojacking Detection System</td><td>2021</td><td>Network  and Distributed Systems Security (NDSS) Symposium 2021</td><td>CCF  B</td><td>Arış,  Ahmet &amp; Naseem, Faraz &amp; Babun, Leonardo &amp; Tekiner, Ege &amp;  Uluagac, Selcuk.</td><td></td><td>1.  提出一种新的加密劫持行为检测机制，在轻量级和端到端框架中实现Wasm二进制分类器：MINOS     2. 提出一种新的Wasm二分类计数，利用二值的灰度图像表示来训练卷积神经网络。     3. MINOS以最小的开销，在真实场景的数据集上以98.97%的准确率检测基于wasm的加密劫持。</td><td>浏览器脚本检测</td><td>收集网站产生的Wasm文件，转换成为灰度图像并导入CNN中进行分类</td><td>未对混淆的分类结果进行阐述</td></tr><tr><td>Cryptomining makes noise Detecting cryptojacking via Machine  Learning</td><td>2021</td><td>Computer  Communications</td><td>CCF  C     SCI Q2</td><td>Maurantonio  Caprolua,Simone Raponia     , Gabriele Oligeria     and Roberto Di Pietroa</td><td></td><td>1.  定义了包含加密劫持攻击的海绵攻击:未经基础设施所有者授权,利用第三方软硬件资源获取个人利益的恶意行为。     2. 详细分析了三种主要加密货币:Bitcoin、Monero和Bytecoin产生的真实网络流量。     3. 分析了两大VPN品牌:NordVPN和ExpressVPN的VPN隧道如何处理由Crypto-clients产生的网络流量。     4. 提出一个基于机器学习的框架:Crypto-Aegis,用于检测几种不同形式的crypto-mining,如单独挖矿和池采矿。     5. 与其他文献中的方案进行了对比,第一个利用机器学习技术通过分析网络流量来检测加密客户端</td><td>流量检测</td><td>分析进站出站流量包大小和达到时间间隔</td><td>1.  本文的错误分类情况大多出现在加密货币之间的错误分类     2. 本文所选正常软件的样本类型偏少     3. 可以考虑综合出站入栈流量</td></tr><tr><td>MineHunter: A Practical Cryptomining Traffic Detection Algorithm  Based on Time Series Tracking</td><td>2021</td><td>Annual  Computer Security Applications Conference (ACSAC)</td><td>CCF  B</td><td>Shize  Zhang, Zhiliang Wang, Jiahai Yang, Xin Cheng, XiaoQian Ma, Hui Zhang, Bo  Wang, Zimu Li, and Jianping Wu</td><td>Association  for Computing Machinery, New York, NY, USA</td><td>1.  分析了加密挖矿的网络流量特征，将加密挖矿的流序列与加密货币的块创建序列相关联     2. 提出一种时间序列跟踪的加密挖掘流量监测算法     3. 在校园网环境中进行了大规模评价实验，效果很好。</td><td>流量监测</td><td>按照加密挖矿的周期和时间间隔对流量进行分类</td><td>未能解决对挖矿软件进行流量分析时，样本的比例悬殊较大引起的高误报率问题</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;挖矿木马总结&quot;&gt;&lt;a href=&quot;#挖矿木马总结&quot; class=&quot;headerlink&quot; title=&quot;挖矿木马总结&quot;&gt;&lt;/a&gt;挖矿木马总结&lt;/h1&gt;&lt;h3 id=&quot;腾讯《2020年挖矿木马年度报告》&quot;&gt;&lt;a href=&quot;#腾讯《2020年挖矿木马年度报告》&quot; c</summary>
      
    
    
    
    
    <category term="恶意软件检测" scheme="https://boneink.github.io/tags/%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8B/"/>
    
    <category term="入侵检测" scheme="https://boneink.github.io/tags/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/"/>
    
    <category term="木马检测" scheme="https://boneink.github.io/tags/%E6%9C%A8%E9%A9%AC%E6%A3%80%E6%B5%8B/"/>
    
    <category term="网络安全" scheme="https://boneink.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>B+树、红黑树、跳表辨析——从MySQL、HashMap和Redis数据结构说起</title>
    <link href="https://boneink.github.io/2021/08/10/B+%E6%A0%91%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E3%80%81%E8%B7%B3%E8%A1%A8%E8%BE%A8%E6%9E%90%E2%80%94%E2%80%94%E4%BB%8EMySQL%E3%80%81HashMap%E5%92%8CRedis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%B4%E8%B5%B7/"/>
    <id>https://boneink.github.io/2021/08/10/B+%E6%A0%91%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E3%80%81%E8%B7%B3%E8%A1%A8%E8%BE%A8%E6%9E%90%E2%80%94%E2%80%94%E4%BB%8EMySQL%E3%80%81HashMap%E5%92%8CRedis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%B4%E8%B5%B7/</id>
    <published>2021-08-10T04:00:00.000Z</published>
    <updated>2021-08-10T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在java开发常见数据结构中，除去教材上介绍的最多的链表、树、堆、图等，还有Redis的跳表这样特殊的数据结构。在常见的面试题目中，经常涉及Redis跳表、HashMap红黑树和MySQL B+树的异同。因此总结一些自己的心得，记录下来。</p><h2 id="数据结构介绍"><a href="#数据结构介绍" class="headerlink" title="数据结构介绍"></a>数据结构介绍</h2><h3 id="B-树之于MySQL"><a href="#B-树之于MySQL" class="headerlink" title="B+树之于MySQL"></a>B+树之于MySQL</h3><p>B+树的“+”代表B+树是B树的改进版，也是树的一种，是MySQL底层使用的数据存储结构。B+树和B树的定义此处不再赘述，仅针对MySQL为何使用B+树进行说明。<br><strong>B+ VS B树</strong>：<br>B树的优点：任何节点都存储有数据，数据本身就是索引，因此需要的空间比B-树小。<br>B+树的优点：只有根节点有数据存储，非根节点仅存储索引，这样每个非根节点能存储的索引比B树更多，使得整个树比B树的高度低，检索时更快。在进行范围检索时，由于B-树不同根节点间也有索引，因此范围检索时只需要在根节点中进行操作即可，不需要重新检索父节点，节省了检索时间。<br>MySQL作为一种使用主存进行数据存储的数据库，其特点就是对检索效率更敏感，对存储数据占用空间不敏感，因此MySQL选择B+树作为自己的存储结构。<br><strong>B+树 VS 红黑树</strong>：<br>红黑树的优点：二叉平衡树的一种，占用空间少，数据较少时查询效率和修改效率都比较好。<br>缺点：由于本身是二叉树的一种，因此尽管相对于其他大类的数据结构其深度会低很多，但是其深度仍比同为树，但每个根节点存储更多数据的B+树大很多。且因为其为平衡二叉树，在进行增删操作时，需要经常对树的结构进行修改，时间效率上会低很多。<br><strong>B+树 VS 跳表</strong>：<br>跳表的优点：跳表基于链表结构构建索引，其可以看成二叉树的一种。其查询思路基于二分法，查询效率高，</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;在java开发常见数据结构中，除去教材上介绍的最多的链表、树、堆、图等，还有Redis的跳表这样特殊的数据结构。在常见的面试题目中，经常涉及</summary>
      
    
    
    
    
    <category term="Java" scheme="https://boneink.github.io/tags/Java/"/>
    
    <category term="mysql" scheme="https://boneink.github.io/tags/mysql/"/>
    
    <category term="Redis" scheme="https://boneink.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>渗透测试-信息收集</title>
    <link href="https://boneink.github.io/2021/08/10/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-SQL%E6%B3%A8%E5%85%A5-WAF%E7%BB%95%E8%BF%87/"/>
    <id>https://boneink.github.io/2021/08/10/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-SQL%E6%B3%A8%E5%85%A5-WAF%E7%BB%95%E8%BF%87/</id>
    <published>2021-08-10T04:00:00.000Z</published>
    <updated>2021-08-10T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WAF简介"><a href="#WAF简介" class="headerlink" title="WAF简介"></a>WAF简介</h2><p><strong>WAF(Web Application Firewall)的具有以下四个方面的功能：</strong></p><ol><li><p>审计设备：用来截获所有HTTP数据或者仅仅满足某些规则的会话</p></li><li><p>访问控制设备：用来控制对Web应用的访问，既包括主动安全模式也包括被动安全模式</p></li><li><p>架构&#x2F;网络设计工具：当运行在反向代理模式，他们被用来分配职能，集中控制，虚拟基础结构等。</p></li><li><p>WEB应用加固工具：这些功能增强被保护Web应用的安全性，它不仅能够屏蔽WEB应用固有弱点，而且能够保护WEB应用编程错误导致的安全隐患。</p></li></ol><p><strong>WAF的常见特点：</strong></p><p>异常检测协议：拒绝不符合HTTP标准的请求</p><p>增强的输入验证：代理和服务端的验证，而不只是限于客户端验证</p><p>白名单&amp;黑名单：白名单适用于稳定的We应用，黑名单适合处理已知问题</p><p>基于规则和基于异常的保护：基于规则更多的依赖黑名单机制，基于异常更为灵活</p><p>状态管理：重点进行会话保护</p><p>另还有：Coikies保护、抗入侵规避技术、响应监视和信息泄露保护等</p><p>如果是对于扫描器，WAF有其识别之道：</p><p><strong>扫描器识别主要由以下几点：</strong></p><ol><li>扫描器指纹(head字段&#x2F;请求参数值)，以wvs为例，会有很明显的Acunetix在内的标识</li><li>单IP+ cookie某时间段内触发规则次数</li><li>隐藏的链接标签等()</li><li>Cookie植入</li><li>验证码验证，扫描器无法自动填充验证码</li><li>单IP请求时间段内Webserver返回http状态404比例， 扫描器探测敏感目录基于字典，找不到文件则返回404</li></ol><h2 id="WAF防护绕过"><a href="#WAF防护绕过" class="headerlink" title="WAF防护绕过"></a>WAF防护绕过</h2><p><a href="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727205214531.png"><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727205214531.png" alt="image-20220727205214531"></a></p><h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><p>在语句中添加某些特殊符号，并不会影响语句的执行效果。在waf绕过中，检测这些特殊符号干扰了检测机制，从而绕过检测。</p><h4 id="通过注释符号-x2F-x2F-进行绕过"><a href="#通过注释符号-x2F-x2F-进行绕过" class="headerlink" title="通过注释符号&#x2F;**&#x2F;进行绕过"></a>通过注释符号&#x2F;**&#x2F;进行绕过</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;WAF简介&quot;&gt;&lt;a href=&quot;#WAF简介&quot; class=&quot;headerlink&quot; title=&quot;WAF简介&quot;&gt;&lt;/a&gt;WAF简介&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;WAF(Web Application Firewall)的具有以下四个方面的功能：&lt;/strong</summary>
      
    
    
    
    
    <category term="网络安全" scheme="https://boneink.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="Web安全" scheme="https://boneink.github.io/tags/Web%E5%AE%89%E5%85%A8/"/>
    
    <category term="渗透测试" scheme="https://boneink.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>渗透测试-信息收集</title>
    <link href="https://boneink.github.io/2021/08/01/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    <id>https://boneink.github.io/2021/08/01/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</id>
    <published>2021-08-01T04:00:00.000Z</published>
    <updated>2021-08-01T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[ <img src="https://boneink.github.io/img/netsafe/信息收集.png" />## 1. 基础概念<h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><h4 id="域名-1"><a href="#域名-1" class="headerlink" title="域名"></a>域名</h4><p>互联网上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置）。</p><h4 id="网域名称系统"><a href="#网域名称系统" class="headerlink" title="网域名称系统"></a>网域名称系统</h4><p>网域名称系统（Domain Name System）有时也简称为域名（DNS），是互联网的一项核心服务，它作为可以将域名和 IP 地址相互映射的一个分布式数据库。</p><h4 id="二级域名或多级域名"><a href="#二级域名或多级域名" class="headerlink" title="二级域名或多级域名"></a>二级域名或多级域名</h4><p><strong>顶级域名</strong></p><p>又叫一级域名，一串字符串中间<strong>一个点</strong>隔开，例如baidu.com。顶级域名是互联网DNS等级之中的最高级的域，它保存于DNS根域的名字空间中。</p><p><strong>二级域名</strong></p><p>实际上就是一个一级域名以下的主机名，一串字符串中间<strong>两个点</strong>隔开，例如[<a href="http://www.baidu.com]。二级域名就是最靠近顶级域名左侧的字段。">www.baidu.com]。二级域名就是最靠近顶级域名左侧的字段。</a></p><p><strong>三级域名</strong></p><p>二级域名的子域名,特征是包含三个点，例如[mp.weixin.qq.com]。</p><ul><li>渗透时域名扫描<br>  进行渗透测试时，其主域名找不到漏洞时，就可以尝试去测试收集到的子域名，然后可以由此横向到主网站。<br>  比如layer子域名探测。</li></ul><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><h4 id="本地Hosts与DNS的关系"><a href="#本地Hosts与DNS的关系" class="headerlink" title="本地Hosts与DNS的关系"></a>本地Hosts与DNS的关系</h4><p>Hosts文件主要作用是定义IP地址和主机名的映射关系，是一个映射IP地址和主机名的规定。<br>Hosts文件是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。</p><h4 id="CDN是什么-与DNS的关系"><a href="#CDN是什么-与DNS的关系" class="headerlink" title="CDN是什么?与DNS的关系?"></a>CDN是什么?与DNS的关系?</h4><p>CDN的全称是Content DeliveryNetwork，即内容分发网络。</p><p><strong>基本思路</strong></p><p>是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。</p><p>通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上（单纯只使用DNS解析，直接PING就会显示出自己的真实IP，如果又使用CDN，PING出来的IP就不是用户的真实IP而是CDN服务器的IP节点。需要绕过CDN后去找真实IP地址。）</p><p><strong>使用CDN的目的</strong></p><p>使用户可就近取得所需内容，解决Internet网络拥挤的状况，提高用户访问网站的响应速度。</p><h4 id="常见的DNS安全攻击"><a href="#常见的DNS安全攻击" class="headerlink" title="常见的DNS安全攻击"></a>常见的DNS安全攻击</h4><ul><li><p><strong>DDoS攻击</strong></p><p>  分布式拒绝服务攻击，可以使很多的计算机在同一时间遭受到攻击，使攻击的目标无法正常使用。攻击者可以伪造自己的DNS服务器地址，同时发送大量请求给其他服务器（频繁的DNS解析请求）。其他服务器的回复会被发送到被伪造服务器的真实地址（真实IP对应的受害者收到大量回复），造成该服务器无法处理请求而崩溃。攻击者同样可以通过利用DNS协议中存在的漏洞，恶意创造一个载荷过大的请求，造成目标DNS服务器崩溃。</p></li><li><p><strong>DNS缓存中毒（DNS欺骗）</strong></p><p>  向DNS服务器注入非法网络域名地址<strong>替换</strong>合法地址（修改合法URL在DNS服务S器上的缓存为非法地址），将流量从合法服务器引导至虚假服务器上的攻击方式，而且以后响应的域名请求将会受黑客所控。当这些非法地址进入DNS服务器缓存，用户的浏览器或者邮件服务器访问合法URL时就会自动跳转到DNS指定的非法地址。这种攻击往往被归类为域欺骗攻击(pharming attack)，由此它会导致出现很多严重问题。首先，用户往往会以为登陆的是自己熟悉的网站，而它们却并不是。与钓鱼攻击采用非法URL不同的是，这种攻击使用的是合法的URL地址。<br>  S</p></li><li><p><strong>域名劫持（DNS重定向）</strong></p><p>  通过攻击域名解析服务器（DNS），或伪造域名解析服务器（DNS）的方法，把目标网站域名解析到错误的地址从而实现用户无法访问目标网站的目的。域名劫持一方面可能影响用户的上网体验，用户被引到假冒的网站进而无法正常浏览网页，而用户量较大的网站域名被劫持后恶劣影响会不断扩大；另一方面用户可能被诱骗到冒牌网站进行登录等操作导致泄露隐私数据。</p></li><li><p><strong>DNS查询嗅探</strong></p><p>  利用对DNS的配置信息获取网络环境的信息，为之后的攻击做准备。</p><p>  为此，需要对DNS服务器需要采取特别的安全保护措施，在防火墙网络中，分开设置内部DNS服务器和外部DNS服务器，连接外部服务的外部DNS服务器上不留有对外禁止访问的内部网络系统的服务器，做到内外网络服务器分割。</p></li><li><p><strong>ARP欺骗</strong></p><p>  <strong>ARP协议</strong></p><p>  在一个局域网内，广播ARP请求包，通过交换机，到达目标IP地址的PC机，从而获取对方的MAC地址。获取到之后会将IP和MAC地址的对应关系存入ARP缓存表，减少大量广播，降低网络拥塞。</p><p>  在网络中产生大量的ARP通信量使网络阻塞，攻击者只要持续不断的发出伪造的ARP响应包就能更改目标主机ARP缓存中的IP-MAC条目，造成网络中断或中间人攻击。</p><p>  ARP攻击主要是存在于局域网网络中，局域网中若有一台计算机感染ARP病毒，则感染该ARP病毒的系统将会试图通过”ARP欺骗”手段截获所在网络内其它计算机的通信信息，并因此造成网内其它计算机的通信故障。</p><p>  比如在攻击机上执行如下命令，就是在告诉主机192.168.42.236，网关192.168.42.2的MAC地址是我，这样网络中就会充斥着这个ARP响应包，使得主机192.168.42.236的网络请求发送到攻击机，无法上网。</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arpspoof -i eth0 -t 192.168.42.236 192.168.42.2</span><br></pre></td></tr></table></figure> <img src="https://boneink.github.io/img/netsafe/1.png" /> - 本机劫持    <pre><code>本机的计算机系统被木马或流氓软件感染后，也可能会出现部分域名的访问异常。</code></pre><h3 id="后门"><a href="#后门" class="headerlink" title="后门"></a>后门</h3><ul><li><p>概念</p><p>  指绕过安全控制而获取对程序或系统访问权的方法。最主要的目的就是方便以后再次秘密进入或者控制系统。</p></li><li><p>分类</p><p>  <strong>网页后门</strong></p><p>  一般都是通过服务器上正常的web服务来构造自己的连接方式，便于控制网站，比如现在非常流行的ASP、cgi脚本后门等。</p><p>  <strong>线程插入后门</strong></p><p>  利用系统自身的某个服务或者线程，将后门程序插入到其中（最流行）。</p><p>  <strong>扩展后门</strong></p><p>  所谓的“扩展”，是指在功能上有大的提升，比普通的单一功能的后门有更强的使用性，这种后门本身就相当于一个小的安全工具包，能实现非常多的常驻见安全功能，适合新手使用。</p><p>  <strong>C&#x2F;S后门（客户端服务器后门）</strong></p><p>  和传统的木马程序类似的控制方法，采用“客户端&#x2F;服务端”的控制方式，通过某种特定的访问方式来启动后门进而控制服务器。可以进行脱库、盗取信息。</p></li><li><p>特点</p><p>  即使管理员通过改变所有密码之类的方法来提高安全性，仍然能再次侵入，使再次侵入被发现的可能性减至最低。大多数后门设法躲过日志，大多数情况下即使入侵者正在使用系统也无法显示他已在线。</p></li></ul><h3 id="web"><a href="#web" class="headerlink" title="web"></a>web</h3><ul><li><p>WEB的组成框架模型</p><p>  网站原码、操作系统、中间件（搭建平台，提供服务的）、数据库。</p>   <img src="https://boneink.github.io/img/netsafe/2.png" />  </li><li><p>各个层面对应的安全测试</p><p>  <strong>通信层</strong></p><p>  主要测试通信协议的安全，系统开放的端口，其中操作系统提供网络层和数据链路层协议，存在问题的可能性较小，一般关注开源协议已存在漏洞即可，无需重点关注。应用层服务与协议一般由产品形态决定，产品中可以自定义配置相关协议与参数，需要重点关注与测试。</p><p>  <strong>应用层</strong></p><p>  应用层包含开发人员开发代码，为整个安全测试的核心模块。主要包括web安全测试，源码安全测试。其中web安全测试从web访问服务的维度，偏向黑盒，进行安全测试。源码安全测试从代码的维度，偏向白盒，进行安全测试。</p><p>  <strong>系统层</strong></p><p>  主要测试操作系统安全，数据库服务安全，web服务器安全，以及其他一些中间件的安全。</p><p>  <strong>管理层</strong></p><p>  主要包括产品资料的安全测试，安全策略制定，协调各个层面的安全测试以及安全风险的整体评估。</p>  <img src="https://boneink.github.io/img/netsafe/3.png" /></li></ul><h2 id="2-数据包扩展"><a href="#2-数据包扩展" class="headerlink" title="2. 数据包扩展"></a>2. 数据包扩展</h2><h3 id="http-x2F-https数据包"><a href="#http-x2F-https数据包" class="headerlink" title="http&#x2F;https数据包"></a>http&#x2F;https数据包</h3><ul><li><p><strong>概念</strong></p><p>  HTTP协议是超文本传输协议的缩写，英文是Hyper Text Transfer Protocol。它是从WEB服务器传输超文本标记语言(HTML)到本地浏览器的传送协议。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。HTPP有多个版本，目前广泛使用的是HTTP&#x2F;1.1版本。</p></li><li><p><strong>原理</strong></p><p>  HTTP是一个基于TCP&#x2F;IP通信协议来传递数据的协议，传输的数据类型为HTML文件、图片文件、查询结果等。HTTP协议一般用于B&#x2F;S架构，浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。</p></li><li><p><strong>特点</strong></p><p>  http协议支持客户端&#x2F;服务端模式，也是一种请求&#x2F;响应模式的协议。</p><p>  <strong>简单快速</strong>：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。</p><p>  <strong>灵活</strong>：HTTP允许传输任意类型的数据对象。传输的类型由Content-Type加以标记。</p><p>  <strong>无连接</strong>：限制每次连接只处理一个请求。服务器处理完请求，并收到客户的应答后，即断开连接，但是却不利于客户端与服务器保持会话连接，为了弥补这种不足，产生了两项记录http状态的技术，一个叫做Cookie,一个叫做Session。</p><p>  <strong>无状态</strong>：无状态是指协议对于事务处理没有记忆，服务器并不知道用户身份。如果后续处理需要前面的信息，则必须重传。（或者借助cookie</p></li></ul><h3 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h3><p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。</p><p><strong>URI</strong>：Uniform Resource Identifier 统一资源标识符。用来标示一个具体的资源，可以通过 URI 知道<strong>一个资源是什么</strong>。</p><p><strong>URL</strong>：Uniform Resource Location 统一资源定位符。用来定位具体的资源的，标示了一个具体的资源位置，即通过URL知道<strong>一个资源在哪里</strong>。互联网上的每个文件都有一个唯一的URL。</p><h3 id="HTTP报文组成"><a href="#HTTP报文组成" class="headerlink" title="HTTP报文组成"></a>HTTP报文组成</h3><p>HTTP报文由三部分组成：<strong>状态行</strong>(请求行 | 响应行)、<strong>首部</strong>、<strong>主体</strong>。<br> <img src="https://boneink.github.io/img/netsafe/4.png" /><br>HTTP报文以状态行开始，跟在后面的是HTTP首部，首部由多个首部字段构成，每行一个首部字段；HTTP首部后是一个空行，然后是报文主体。<br><strong>状态行和首部</strong>中的每行都是以<strong>回车符</strong>(\r，%0d，CR)和<strong>换行符</strong>(\n，%0a，LF)结束，这是因为HTTP规范中行应该使用CRLF结束。另外，首部和主体之间由一空行隔开，或者可以理解为HTTP首部的最后一个字段有两个CRLF。<br>与状态行和首部不同的是，<strong>主体</strong>是可选的，也就是说报文中不一定要有主体；另外状态行和首部是ASCII文本，主体可包含文本或二进制数据。<br>HTTP报文分为请求报文和响应报文；请求报文向服务器传达请求，响应报文将请求的结果返回给客户端。以下两图，分别是请求报文以及响应报文的结构图。<br><img src="https://boneink.github.io/img/netsafe/5.png" /><br><img src="https://boneink.github.io/img/netsafe/6.png" /><br><img src="https://boneink.github.io/img/netsafe/7.png" /><br><img src="https://boneink.github.io/img/netsafe/8.png" /></p><h3 id="常见请求方法"><a href="#常见请求方法" class="headerlink" title="常见请求方法"></a>常见请求方法</h3><p>GET：请求指定的页面信息，并返回实体主体。</p><p>POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。</p><p>HEAD：类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</p><p>PUT：从客户端向服务器传送的数据取代指定的文档的内容。</p><p>DELETE：请求服务器删除指定的页面。</p><ul><li><p><strong>get和post的区别</strong></p><p>  get请求：</p>  <img src="https://boneink.github.io/img/netsafe/9.png" />  post请求：  <img src="https://boneink.github.io/img/netsafe/10.png" />  - 编码和请求方式不同：get通过URL显式的请求，只能是ASCII码。post不会显示在URL，请求的参数存放在请求实体body中（例如提交表单或者上传文件），在报文内部，且编码不唯一；post比get更加安全；  - 请求的数据量不同：get请求的数据有限，不超过2k-4k（视浏览器而定），而post没有上限；  - 缓存性：get会进行缓存，而post没有；  - 可刷新性：get请求可刷新，由于有本地缓存，不会重复请求，而post请求在刷新时会重新提交请求；  - get多用来查询，请求参数放在url中，不会对服务器上的内容产生作用；post请求可能会导致新的资源的建立和/或已有资源的修改。</li></ul><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTP很多信息是明文传输，因此不适合用来传输一些敏感信息，比如：各种账号、密码等信息，使用http协议传输隐私信息非常不安全。存在以下问题：</p><ul><li>请求信息明文传输，容易被窃听截取。（机密性）</li><li>数据的完整性未校验，容易被篡改。（完整性）</li><li>没有验证对方身份，存在冒充危险。（不可抵赖性）</li></ul><p>HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：一般理解为HTTP+SSL&#x2F;TLS，通过 SSL证书来验证服务器的身份（SSL安全套接字层位于传输层和应用层之间），并为浏览器和服务器之间的通信进行加密。<br><img src="https://boneink.github.io/img/netsafe/11.png" /></p><ul><li><strong>HTTPS的缺点</strong><br>  HTTPS协议多次握手，导致页面的加载时间延长近50%；<br>  HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗；<br>  申请SSL证书需要钱，功能越强大的证书费用越高。<br>  SSL涉及到的安全算法会消耗 CPU 资源，对服务器资源消耗较大。</li><li><strong>HTTP和HTTPS的区别</strong><ul><li><strong>申请证书</strong>：https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。</li><li><strong>传输数据</strong>：http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl&#x2F;tls加密传输协议。</li><li><strong>端口</strong>：http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li><strong>安全性</strong>：http的连接很简单，是无状态的；HTTPS协议是由SSL&#x2F;TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li></ul></li></ul><h2 id="3-系统及数据库安全"><a href="#3-系统及数据库安全" class="headerlink" title="3. 系统及数据库安全"></a>3. 系统及数据库安全</h2>  <img src="https://boneink.github.io/img/netsafe/12.png" />### 操作系统层面<ul><li><p>识别操作系统</p><p>  <strong>方法一：</strong>网站路径修改大小写</p><p>  windows对大小写不敏感，也就是说你在网页中可以替换网站路径的大小写进行测试；</p><p>  <strong>方法二：</strong>nmap扫描</p><p>  没有网站可以用于测试时，可以使用nmap扫描主机，获得主机的一些信息。如下：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">──(root💀kali)-[~/桌面]  </span><br><span class="line">└─# nmap -O 10.1.1.10   </span><br><span class="line">Starting Nmap 7.91 ( https://nmap.org ) at 2021-06-07 21:06 CST  </span><br><span class="line">Nmap scan report for 10.1.1.10 (10.1.1.10)  </span><br><span class="line">Host is up (0.0011s latency).  </span><br><span class="line">Not shown: 999 closed ports  </span><br><span class="line">PORT   STATE SERVICE  </span><br><span class="line">22/tcp open  ssh  </span><br><span class="line">MAC Address: 00:0C:29:13:E9:61 (VMware)  </span><br><span class="line">Device type: general purpose  </span><br><span class="line">Running: Linux 3.X|4.X  </span><br><span class="line">OS CPE: cpe:/o:linux:linux_kernel:3 cpe:/o:linux:linux_kernel:4  </span><br><span class="line">OS details: Linux 3.2 - 4.9  </span><br><span class="line">Network Distance: 1 hop</span><br></pre></td></tr></table></figure></li></ul><p>备注：不是所有的系统都可以用这种方式扫描出操作系统的类型、在windows的一些高版本中nmap也无法探测其操作系统类型。</p><p> <strong>方法三：</strong>TTL值</p><p>不同的操作系统的默认TTL值（网络中数据包的生存周期，经过多少次路由后自动丢弃，经过一次路由就减一）是不同的， 所以我们可以通过TTL值来判断主机的操作系统，但是当用户在注册表中修改了TTL值的时候，就会误导我们的判断，所以这种判断方式也不一定准确。下面是默认操作系统的TTL：</p><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WINDOWS NT/2000   TTL：128  </span><br><span class="line">WINDOWS 95/98     TTL：32  </span><br><span class="line">UNIX              TTL：255  </span><br><span class="line">LINUX             TTL：64  </span><br><span class="line">WIN7           TTL：64</span><br></pre></td></tr></table></figure></code></pre><p>比如，使用ping命令可以看到TTL为53，可以估计出TTL值原本为64，经过了11次路由。<br>    <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\cbcao&gt;ping baidu.com  </span><br><span class="line">正在 Ping baidu.com [110.242.68.66] 具有 32 字节的数据:  </span><br><span class="line">来自 110.242.68.66 的回复: 字节=32 时间=42ms TTL=53  </span><br><span class="line">来自 110.242.68.66 的回复: 字节=32 时间=42ms TTL=53  </span><br><span class="line">来自 110.242.68.66 的回复: 字节=32 时间=42ms TTL=53  </span><br><span class="line">来自 110.242.68.66 的回复: 字节=32 时间=42ms TTL=53</span><br></pre></td></tr></table></figure><br><strong>方法四</strong>：特殊端口 如（22 &#x2F; 139 &#x2F; 445 &#x2F; 1433 &#x2F; 3389）</p><ul><li><p>识别操作系统的意义</p><p>  不同操作系统对应着不同的漏洞、不同的利用条件。</p></li></ul><h3 id="数据库层面"><a href="#数据库层面" class="headerlink" title="数据库层面"></a>数据库层面</h3><ul><li><p>识别数据库的常见方法</p><p>  <strong>方法一</strong>：根据搭配的语言进行识别</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">默认的语言搭配的数据库  </span><br><span class="line">组合类型 asp + access/mssql  </span><br><span class="line">组合类型 php + mysql   </span><br><span class="line">组合类型 aspx+mssql  </span><br><span class="line">组合类型 jsp +mysql/oracle  </span><br><span class="line">组合类型 Python + MongoDB</span><br></pre></td></tr></table></figure><p> <strong>方法二</strong>：根据端口号进行识别</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">常见的数据库默认端口号  </span><br><span class="line">关系型数据库  </span><br><span class="line">  mysql3306  </span><br><span class="line">  sqlserver1433  </span><br><span class="line">  oracle1521  </span><br><span class="line">  psotgresql5432  </span><br><span class="line">非关系型数据库  </span><br><span class="line">  MongoDB27017  </span><br><span class="line">  Redis6379  </span><br><span class="line">  memcached11211</span><br></pre></td></tr></table></figure></li><li><p>识别数据库的意义<br>  数据库的不同表示的结构也是不同、写法结构也不一样、所以产生的漏洞也不一样。<br>  不同的数据库的攻击方式也不完全一样。</p></li><li><p>数据库漏洞的影响<br>  数据库权限、网站权限、修改网页内容</p></li><li><p>漏洞演示<br>  <a href="https://vulhub.org/#/environments/mysql/CVE-2012-2122/">https://vulhub.org/#/environments/mysql/CVE-2012-2122/</a><br>  首先kali中进入metasploit：<code>msfconsole</code><br>  <a href="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725164309854.png"><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725164309854.png" alt="image-20220725164309854"></a><br>  然后搜索mysql漏洞：<code>search mysql</code><br>  <a href="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725204945302.png"><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725204945302.png" alt="image-20220725204945302"></a><br>  选择一个准备利用的漏洞，使用该模块：<br>  <a href="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725205142250.png"><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725205142250.png" alt="image-20220725205142250"></a><br>  <a href="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725205202105.png"><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725205202105.png" alt="image-20220725205202105"></a><br>  然后按照rhost选项配置攻击机IP、线程数threads，接着执行run即可：<br>  <a href="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725205258549.png"><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725205258549.png" alt="image-20220725205258549"></a></p><p>  最后得到数据库密码的hash值：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[+] 10.1.1.133:3306       - 10.1.1.133:3306 Saving HashString as Loot: root:*6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9  </span><br><span class="line">[+] 10.1.1.133:3306       - 10.1.1.133:3306 Hash Table has been saved: /root/.msf4/loot/20210608111341_default_10.1.1.133_mysql.hashes_091970.txt  </span><br><span class="line">[*] 10.1.1.133:3306       - Scanned 1 of 1 hosts (100% complete)  </span><br><span class="line">[*] Auxiliary module execution completed  </span><br><span class="line">  </span><br><span class="line">md5在线解密  </span><br><span class="line">https://www.cmd5.com/</span><br></pre></td></tr></table></figure><p>  <a href="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725205818311.png"><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725205818311.png" alt="image-20220725205818311"></a></p></li></ul><h3 id="第三方层面"><a href="#第三方层面" class="headerlink" title="第三方层面"></a>第三方层面</h3><ul><li><p>如何判断有哪些第三方平台或软件：nmap</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">nmap -O -sV 10.1.1.130  </span><br><span class="line">Starting Nmap 7.91 ( https://nmap.org ) at 2021-06-08 09:26 CST  </span><br><span class="line">Nmap scan report for 10.1.1.130 (10.1.1.130)  </span><br><span class="line">Host is up (0.00085s latency).  </span><br><span class="line">Not shown: 978 closed ports  </span><br><span class="line">PORT     STATE SERVICE     VERSION  </span><br><span class="line">21/tcp   open  ftp         vsftpd 2.3.4  </span><br><span class="line">22/tcp   open  ssh         OpenSSH 4.7p1 Debian 8ubuntu1 (protocol 2.0)  </span><br><span class="line">23/tcp   open  telnet      Linux telnetd  </span><br><span class="line">25/tcp   open  smtp        Postfix smtpd  </span><br><span class="line">80/tcp   open  http        Apache httpd 2.2.8 ((Ubuntu) DAV/2)  </span><br><span class="line">111/tcp  open  rpcbind     2 (RPC #100000)  </span><br><span class="line">139/tcp  open  netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP)  </span><br><span class="line">445/tcp  open  netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP)  </span><br><span class="line">512/tcp  open  exec?  </span><br><span class="line">513/tcp  open  login?  </span><br><span class="line">514/tcp  open  tcpwrapped</span><br></pre></td></tr></table></figure><ul><li>识别第三方平台或软件的意义</li></ul><p>  不同的第三方软件或工具存在不同的漏洞、识别到更多的信息对收集到的漏洞也就越多。  </p></li><li><p>渗透第三方平台或软件的目标</p><p>  直接获取到软件的权限便于进一步的提权和攻击</p></li><li><p>漏洞演示</p><p>  <a href="https://vulhub.org/#/environments/phpmyadmin/CVE-2018-12613/">https://vulhub.org/#/environments/phpmyadmin/CVE-2018-12613/</a></p><p>  首先进入该漏洞的目录，启动phpmyadmin：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@hdss7-11 CVE-2018-12613]# pwd  </span><br><span class="line">/opt/vulhub/vulhub-master/phpmyadmin/CVE-2018-12613  </span><br><span class="line">[root@hdss7-11 CVE-2018-12613]# docker-compose up -d</span><br></pre></td></tr></table></figure><p>  <a href="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1623123783733-3cba9200-6e65-4115-b589-0b777315382c.png"><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1623123783733-3cba9200-6e65-4115-b589-0b777315382c.png" alt="img"></a></p><p>  成功访问phpmyadmin之后，访问<code>http://10.1.1.133:8080/?target=db_sql.php%3f/../../../../../../../../etc/passwd</code>实现漏洞利用，得到执行etc&#x2F;passwd的结果：</p><p>  <a href="https://cdn.nlark.com/yuque/0/2021/png/2476579/1623123853171-a2f0af6d-42bd-483d-a96e-02c553f0f297.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/2476579/1623123853171-a2f0af6d-42bd-483d-a96e-02c553f0f297.png" alt="image.png"></a></p></li></ul><h2 id="4-加密编码算法"><a href="#4-加密编码算法" class="headerlink" title="4. 加密编码算法"></a>4. 加密编码算法</h2><ul><li><p>时间戳</p><p>  在线转换工具：<a href="https://tool.lu/timestamp/">https://tool.lu/timestamp/</a></p></li><li><p>URL编码</p><p>  <a href="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725211231394.png"><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725211231394.png" alt="image-20220725211231394"></a></p></li><li><p>base64编码</p><p>  随着编码的文本增加而增加、由大小写和数字组成且字符结尾一般有两个等号。</p></li><li><p>unescape编码</p><p>  和URL编码有点像，特点是一般是%U+四个数字对应着两个字符，主要运用于网站web应用。</p></li><li><p>AES加密</p></li></ul><h2 id="5-CDN绕过"><a href="#5-CDN绕过" class="headerlink" title="5. CDN绕过"></a>5. CDN绕过</h2><p>CDN依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。但在安全测试过程中，若目标存在CDN服务，将会影响到后续的安全测试过程。</p><ul><li><p>判断是否存在CDN服务</p><p>  利用多节点技术进行请求返回判断<br>  <a href="http://ping.chinaz.com/">http://ping.chinaz.com/</a><br>  <a href="http://ping.aizhan.com/">http://ping.aizhan.com/</a><br>  <a href="http://ce.cloud.360.cn/">http://ce.cloud.360.cn/</a></p><p>  验证获取到ip是否可信可以采用第三方的ip地址查询工具经行验证。</p><p>  <a href="https://get-site-ip.com/">https://get-site-ip.com/</a></p><p>  cdn网站</p><p>  <a href="https://tools.ipip.net/cdn.php">https://tools.ipip.net/cdn.php</a></p></li><li><p>CDN对安全测试的影响</p><p>  CDN会隐藏服务器真实的ip地址，无法对目标网站的操作系统进行渗透，但CDN站点又可以理解为是目标站点的镜像站点（大多数都是静态cdn加速），拥有相同的网站架构，且cdn服务器可与站点服务器进行交互，因此sql注入，xss等漏洞的挖掘并不受太大影响。</p></li><li><p>目前常见的CDN绕过技术</p><p>  <strong>子域名查询</strong></p><p>  因为有些主站是做了CDN服务而子站是没有做CDN服务</p><p>  <strong>邮件服务查询</strong></p><p>  因为邮箱大部分都是内部人在访问、而且访问的量也不是很大，一般是没有做CDN。</p><p>  <strong>国外地址请求</strong></p><p>  因为很多的企业没有在国外部署CDN，要是用国外的地址请求、就容易找到他的真实地址。</p><p>  <strong>遗留文件、扫描全网</strong></p><p>  如PHPinfo信息当中会遗留出ip地址</p><p>  <strong>黑暗引擎搜索</strong></p><p>  fofa、傻蛋、谛听、zoomeye、censys</p><p>  <strong>特定文件dns历史记录，以量打量</strong></p><p>  CDN真实IP地址获取后绑定指向地址，即更改本地HOSTS解析指向文件</p><p>  <strong>奇淫技巧</strong></p><p>  fackcdn w8fuckcdn zmap</p></li></ul><h2 id="6-信息收集、WAF"><a href="#6-信息收集、WAF" class="headerlink" title="6. 信息收集、WAF"></a>6. 信息收集、WAF</h2><h3 id="站点搭建分析"><a href="#站点搭建分析" class="headerlink" title="站点搭建分析"></a>站点搭建分析</h3><ul><li><p>目录型站点</p><p>  主站上面存在其他的cms程序。</p><p>  比如学生网站[<a href="http://www.xxx.com]的上面通过后台扫描探针发现有一个bbs的目录，一点击发现是一个bbs的论坛网站如：www.xxx.com/bbs。我们把这个称为目录型网站，可以有两种找到漏洞的思路，一个是主站的漏洞另外的一个是bbs上面的漏洞。">www.xxx.com]的上面通过后台扫描探针发现有一个bbs的目录，一点击发现是一个bbs的论坛网站如：www.xxx.com/bbs。我们把这个称为目录型网站，可以有两种找到漏洞的思路，一个是主站的漏洞另外的一个是bbs上面的漏洞。</a></p></li><li><p>端口类站点</p><p>  有的站点不是使用的是默认的站点80而是其他的端口，可以使用shodan这种工具去收集端口。</p></li><li><p>子域名站点</p><p>  比如bbs.goodlift.net是goodlift.net的子域名，且为不同的站点。</p><p>  现在的主流网站都是采用的这种模式且子域名和网站之间很有可能是不在同一台的服务器上面。</p></li><li><p>类似域名站点</p><p>  例如：京东的网站是jd.com 那么他就有可能是采用了jd.net jd.cn等域名我们采用社工的方式去尝试获取他的相关域名信息。</p></li><li><p>旁注，c段站点</p><p>  <strong>旁注</strong>：同一个服务器上面存在多个站点、但是你要攻击的是A网站由于各种原因不能完成安全测试。就通过测试B网站进入服务器然后在攻击A网站最终实现目的。</p><p>  <strong>C段</strong>：不同的服务器上面存在不同的网站，通过扫描发现与你渗透测试的是同一个网段，最终拿下服务器，然后通过内网渗透的方式拿下渗透服务器。</p><p>  查询服务器上站点：在线工具：<a href="https://www.webscan.cc/">https://www.webscan.cc/</a></p></li><li><p>搭建软件特征站点</p><p>  有的网站是借助于第三方的集成搭建工具实现，例如：PHPstudy、宝塔等环境。这样的集成环境搭建的危害就是泄露了详细的版本信息。</p><p>  phpstudy搭建了之后，在默认的站点安装了phpmyadmin。有的网站没有做安全性直接可以通过用户名：root密码：root 登录进入。</p></li></ul><h3 id="WAF"><a href="#WAF" class="headerlink" title="WAF"></a>WAF</h3><p>Web应用防护系统（也称为：网站应用级入侵防御系统。英文：Web Application Firewall，简称： WAF）。利用国际上公认的一种说法：Web应用防火墙是通过执行一系列针对HTTP&#x2F;HTTPS的安全策略来专门为Web应用提供保护的一款产品。</p><p><strong>识别WAF的存在</strong>：直接使用工具进行扫描有可能会导致waf将你的ip地址拉入黑名单而不能访问，针对不同的厂商的waf可能存在着不同的绕过思路。</p><ul><li><p>采用工具wafwoof，缺点是并不特别准确</p><p>  获取地址：<a href="https://codeload.github.com/EnableSecurity/wafw00f/zip/refs/heads/master">https://codeload.github.com/EnableSecurity/wafw00f/zip/refs/heads/master</a></p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">unzip wafw00f-master.zip      <span class="comment"># 解压</span></span>  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">python3.8 setup.py install    <span class="comment"># 安装</span></span>  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> -ld wafw00f</span>  </span><br><span class="line">drwxr-xr-x 6 root root 4096  6月 10 17:22 wafw00f  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cd</span> wafw00f</span>   </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">python main.py https://www.hlszsb.com/   <span class="comment"># 识别网站https://www.hlszsb.com/</span></span>  </span><br><span class="line">  </span><br><span class="line">[*] Checking https://www.hlszsb.com/  </span><br><span class="line">[+] Generic Detection results:  </span><br><span class="line">[-] No WAF detected by the generic detection  </span><br><span class="line">[~] Number of requests: 7</span><br></pre></td></tr></table></figure><ul><li>identYwaf</li></ul><p>  参考地址：<a href="https://github.com/stamparm/identywaf">https://github.com/stamparm/identywaf</a></p><p>  与wafwoof相比运行速度慢，但是比较稳定  </p></li><li><p>在有些网站的请求信息当中留下了waf的相关信息</p><p>  <a href="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725213558764.png"><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725213558764.png" alt="image-20220725213558764"></a></p></li><li><p>nmap</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmap --script==http-waf-fingerprint  </span><br><span class="line">nmap --script=http-waf-detect</span><br></pre></td></tr></table></figure></li></ul><h2 id="7-资产收集"><a href="#7-资产收集" class="headerlink" title="7. 资产收集"></a>7. 资产收集</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Github监控  </span><br><span class="line">  便于收集整理最新exp或poc  </span><br><span class="line">  便于发现相关测试目标的资产  </span><br><span class="line">  server酱：http://sc.ftqq.com/3.version  </span><br><span class="line">  GitHub项目监控地址：https://github.com/weixiao9188/wechat_push  </span><br><span class="line">  </span><br><span class="line"># 各种子域名查询  </span><br><span class="line"># DNS,备案,证书  </span><br><span class="line"># 全球节点请求cdn  </span><br><span class="line">  枚举爆破或解析子域名对应  </span><br><span class="line">  便于发现管理员相关的注册信息  </span><br><span class="line">  </span><br><span class="line">#黑暗引擎相关搜索  </span><br><span class="line">fofa, shodan, zoomeye  </span><br></pre></td></tr></table></figure><h2 id="8-web漏洞"><a href="#8-web漏洞" class="headerlink" title="8. web漏洞"></a>8. web漏洞</h2><p><a href="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725233424804.png"><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725233424804.png" alt="image-20220725233424804"></a></p><p><strong>漏洞危害情况</strong></p><ol><li>获取网站的数据库的权限（数据），后台账号和密码—SQL注入</li><li>直接获取网站权限—文件上传</li></ol><p><strong>漏洞等级划分</strong></p><ol><li>高危：文件上传、SQL注入、代码执行、文件包含、未授权访问</li><li>中危：逻辑安全、目录遍历</li><li>低危：信息泄露—源码、部分账号密码</li></ol><p><strong>漏洞重点内容</strong></p><ol><li>CTF：SQL注入、反序列化、代码执行</li><li>SRC：以上都有，逻辑安全</li><li>红蓝对抗：高危漏洞—权限</li></ol>]]></content>
    
    
      
      
    <summary type="html"> &lt;img src=&quot;https://boneink.github.io/img/netsafe/信息收集.png&quot; /&gt;
## 1. 基础概念

&lt;h3 id=&quot;域名&quot;&gt;&lt;a href=&quot;#域名&quot; class=&quot;headerlink&quot; title=&quot;域名&quot;&gt;&lt;/a&gt;域名&lt;/h3</summary>
      
    
    
    
    
    <category term="网络安全" scheme="https://boneink.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="Web安全" scheme="https://boneink.github.io/tags/Web%E5%AE%89%E5%85%A8/"/>
    
    <category term="渗透测试" scheme="https://boneink.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Web安全-XSS攻击渗透报告</title>
    <link href="https://boneink.github.io/2021/07/13/Web%E5%AE%89%E5%85%A8-XSS%E6%94%BB%E5%87%BB%E6%B8%97%E9%80%8F%E6%8A%A5%E5%91%8A/"/>
    <id>https://boneink.github.io/2021/07/13/Web%E5%AE%89%E5%85%A8-XSS%E6%94%BB%E5%87%BB%E6%B8%97%E9%80%8F%E6%8A%A5%E5%91%8A/</id>
    <published>2021-07-13T04:00:00.000Z</published>
    <updated>2021-07-13T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<embed id="pdfPlayer" src="https://boneink.github.io/img/pdf/8.XSS攻击渗透报告.pdf" type="application/pdf" width="100%" height="600" >]]></content>
    
    
      
      
    <summary type="html">&lt;embed id=&quot;pdfPlayer&quot; src=&quot;https://boneink.github.io/img/pdf/8.XSS攻击渗透报告.pdf&quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;600&quot; &gt;</summary>
      
    
    
    
    
    <category term="网络安全" scheme="https://boneink.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="Web安全" scheme="https://boneink.github.io/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Web安全-SQL注入爆表</title>
    <link href="https://boneink.github.io/2021/07/12/Web%E5%AE%89%E5%85%A8-SQL%E6%B3%A8%E5%85%A5%E7%88%86%E8%A1%A8/"/>
    <id>https://boneink.github.io/2021/07/12/Web%E5%AE%89%E5%85%A8-SQL%E6%B3%A8%E5%85%A5%E7%88%86%E8%A1%A8/</id>
    <published>2021-07-12T04:00:00.000Z</published>
    <updated>2021-07-12T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<embed id="pdfPlayer" src="https://boneink.github.io/img/pdf/7.SQL注入爆表.pdf" type="application/pdf" width="100%" height="600" >]]></content>
    
    
      
      
    <summary type="html">&lt;embed id=&quot;pdfPlayer&quot; src=&quot;https://boneink.github.io/img/pdf/7.SQL注入爆表.pdf&quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;600&quot; &gt;</summary>
      
    
    
    
    
    <category term="网络安全" scheme="https://boneink.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="Web安全" scheme="https://boneink.github.io/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Web安全-文件上传攻击实战</title>
    <link href="https://boneink.github.io/2021/07/10/Web%E5%AE%89%E5%85%A8-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%94%BB%E5%87%BB%E5%AE%9E%E6%88%98/"/>
    <id>https://boneink.github.io/2021/07/10/Web%E5%AE%89%E5%85%A8-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%94%BB%E5%87%BB%E5%AE%9E%E6%88%98/</id>
    <published>2021-07-10T04:00:00.000Z</published>
    <updated>2021-07-10T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<embed id="pdfPlayer" src="https://boneink.github.io/img/pdf/6.文件上传攻击实战.pdf" type="application/pdf" width="100%" height="600" >]]></content>
    
    
      
      
    <summary type="html">&lt;embed id=&quot;pdfPlayer&quot; src=&quot;https://boneink.github.io/img/pdf/6.文件上传攻击实战.pdf&quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;600&quot; &gt;</summary>
      
    
    
    
    
    <category term="网络安全" scheme="https://boneink.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="Web安全" scheme="https://boneink.github.io/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Web安全-反射型XSS攻击实战</title>
    <link href="https://boneink.github.io/2021/07/05/Web%E5%AE%89%E5%85%A8-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%94%BB%E5%87%BB%E5%AE%9E%E6%88%98/"/>
    <id>https://boneink.github.io/2021/07/05/Web%E5%AE%89%E5%85%A8-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%94%BB%E5%87%BB%E5%AE%9E%E6%88%98/</id>
    <published>2021-07-05T04:00:00.000Z</published>
    <updated>2021-07-05T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<embed id="pdfPlayer" src="https://boneink.github.io/img/pdf/5.文件包含攻击实战.pdf" type="application/pdf" width="100%" height="600" >]]></content>
    
    
      
      
    <summary type="html">&lt;embed id=&quot;pdfPlayer&quot; src=&quot;https://boneink.github.io/img/pdf/5.文件包含攻击实战.pdf&quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;600&quot; &gt;</summary>
      
    
    
    
    
    <category term="网络安全" scheme="https://boneink.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="Web安全" scheme="https://boneink.github.io/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Web安全-反射型XSS攻击实战</title>
    <link href="https://boneink.github.io/2021/06/30/Web%E5%AE%89%E5%85%A8-%E5%8F%8D%E5%B0%84%E5%9E%8BXSS%E6%94%BB%E5%87%BB%E5%AE%9E%E6%88%98/"/>
    <id>https://boneink.github.io/2021/06/30/Web%E5%AE%89%E5%85%A8-%E5%8F%8D%E5%B0%84%E5%9E%8BXSS%E6%94%BB%E5%87%BB%E5%AE%9E%E6%88%98/</id>
    <published>2021-06-30T04:00:00.000Z</published>
    <updated>2021-06-30T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<embed id="pdfPlayer" src="https://boneink.github.io/img/pdf/4.反射型XSS攻击实战.pdf" type="application/pdf" width="100%" height="600" >]]></content>
    
    
      
      
    <summary type="html">&lt;embed id=&quot;pdfPlayer&quot; src=&quot;https://boneink.github.io/img/pdf/4.反射型XSS攻击实战.pdf&quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;600&quot; &gt;</summary>
      
    
    
    
    
    <category term="网络安全" scheme="https://boneink.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="Web安全" scheme="https://boneink.github.io/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Web安全-存储型XSS攻击实战</title>
    <link href="https://boneink.github.io/2021/06/28/Web%E5%AE%89%E5%85%A8-%E5%AD%98%E5%82%A8%E5%9E%8BXSS%E6%94%BB%E5%87%BB%E5%AE%9E%E6%88%98/"/>
    <id>https://boneink.github.io/2021/06/28/Web%E5%AE%89%E5%85%A8-%E5%AD%98%E5%82%A8%E5%9E%8BXSS%E6%94%BB%E5%87%BB%E5%AE%9E%E6%88%98/</id>
    <published>2021-06-28T04:00:00.000Z</published>
    <updated>2021-06-28T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<embed id="pdfPlayer" src="https://boneink.github.io/img/pdf/4.存储型XSS攻击实战.pdf" type="application/pdf" width="100%" height="600" >]]></content>
    
    
      
      
    <summary type="html">&lt;embed id=&quot;pdfPlayer&quot; src=&quot;https://boneink.github.io/img/pdf/4.存储型XSS攻击实战.pdf&quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;600&quot; &gt;</summary>
      
    
    
    
    
    <category term="网络安全" scheme="https://boneink.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="Web安全" scheme="https://boneink.github.io/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Web安全-命令注入攻击实战</title>
    <link href="https://boneink.github.io/2021/06/27/Web%E5%AE%89%E5%85%A8-DOM%E5%9E%8BXSS%E6%94%BB%E5%87%BB%E5%AE%9E%E6%88%98/"/>
    <id>https://boneink.github.io/2021/06/27/Web%E5%AE%89%E5%85%A8-DOM%E5%9E%8BXSS%E6%94%BB%E5%87%BB%E5%AE%9E%E6%88%98/</id>
    <published>2021-06-27T04:00:00.000Z</published>
    <updated>2021-06-27T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<embed id="pdfPlayer" src="https://boneink.github.io/img/pdf/4.DOM型XSS攻击实战.pdf" type="application/pdf" width="100%" height="600" >]]></content>
    
    
      
      
    <summary type="html">&lt;embed id=&quot;pdfPlayer&quot; src=&quot;https://boneink.github.io/img/pdf/4.DOM型XSS攻击实战.pdf&quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;600&quot; &gt;
</summary>
      
    
    
    
    
    <category term="网络安全" scheme="https://boneink.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="Web安全" scheme="https://boneink.github.io/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Web安全-命令注入攻击实战</title>
    <link href="https://boneink.github.io/2021/06/22/Web%E5%AE%89%E5%85%A8-%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%E5%AE%9E%E6%88%98/"/>
    <id>https://boneink.github.io/2021/06/22/Web%E5%AE%89%E5%85%A8-%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%E5%AE%9E%E6%88%98/</id>
    <published>2021-06-22T04:00:00.000Z</published>
    <updated>2021-06-22T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<embed id="pdfPlayer" src="https://boneink.github.io/img/pdf/3.命令注入攻击实战.pdf" type="application/pdf" width="100%" height="600" >]]></content>
    
    
      
      
    <summary type="html">&lt;embed id=&quot;pdfPlayer&quot; src=&quot;https://boneink.github.io/img/pdf/3.命令注入攻击实战.pdf&quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;600&quot; &gt;</summary>
      
    
    
    
    
    <category term="网络安全" scheme="https://boneink.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="Web安全" scheme="https://boneink.github.io/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Web安全-Web爆破攻击实战</title>
    <link href="https://boneink.github.io/2021/06/20/Web%E5%AE%89%E5%85%A8-Web%E7%88%86%E7%A0%B4%E6%94%BB%E5%87%BB%E5%AE%9E%E6%88%98/"/>
    <id>https://boneink.github.io/2021/06/20/Web%E5%AE%89%E5%85%A8-Web%E7%88%86%E7%A0%B4%E6%94%BB%E5%87%BB%E5%AE%9E%E6%88%98/</id>
    <published>2021-06-20T04:00:00.000Z</published>
    <updated>2021-06-20T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<embed id="pdfPlayer" src="https://boneink.github.io/img/pdf/2.Web爆破攻击实战.pdf" type="application/pdf" width="100%" height="600" >]]></content>
    
    
      
      
    <summary type="html">&lt;embed id=&quot;pdfPlayer&quot; src=&quot;https://boneink.github.io/img/pdf/2.Web爆破攻击实战.pdf&quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;600&quot; &gt;</summary>
      
    
    
    
    
    <category term="网络安全" scheme="https://boneink.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="Web安全" scheme="https://boneink.github.io/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
</feed>
