<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>临渊羡鱼</title>
  
  
  <link href="https://boneink.github.io/atom.xml" rel="self"/>
  
  <link href="https://boneink.github.io/"/>
  <updated>2022-08-23T04:00:00.000Z</updated>
  <id>https://boneink.github.io/</id>
  
  <author>
    <name>BoneInk</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WhiteRabbitTracke项目运行和问题</title>
    <link href="https://boneink.github.io/2022/08/23/WhiteRabbitTracker%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C%E5%92%8C%E9%97%AE%E9%A2%98/"/>
    <id>https://boneink.github.io/2022/08/23/WhiteRabbitTracker%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C%E5%92%8C%E9%97%AE%E9%A2%98/</id>
    <published>2022-08-23T04:00:00.000Z</published>
    <updated>2022-08-23T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WhiteRabbitTracke项目运行和问题"><a href="#WhiteRabbitTracke项目运行和问题" class="headerlink" title="WhiteRabbitTracke项目运行和问题"></a>WhiteRabbitTracke项目运行和问题</h2><hr><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><ul><li><p>虚拟机镜像选择：</p><p>编译阶段使用Windows 10 x86 1709及之后的镜像。</p><p>运行阶段使用Windows 7 x86 sp1。</p></li><li><p>拉取项目：</p><p>采用git指令直接拉取包含子项目在内的所有内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recursive https://github.com/AndreaNaspi/WhiteRabbitTracker.githttps://github.com/AndreaNaspi/WhiteRabbitTracker.git</span><br></pre></td></tr></table></figure><p>由于网络原因，可能无法拉取，因此可以手动下载解压：</p><p>主项目：<a href="https://github.com/AndreaNaspi/WhiteRabbitTracker">GitHub - AndreaNaspi&#x2F;WhiteRabbitTracker: WhiteRabbitTracker: Analyzing malware evasions with information flow tracking</a></p><p>子项目：<a href="https://github.com/zyantific/zydis/tree/564f0b843ca28b7b9b29dabfc2da1ae6abc9fee9">GitHub - zyantific&#x2F;zydis at 564f0b843ca28b7b9b29dabfc2da1ae6abc9fee9</a></p><p>zydis的子项目：<a href="https://github.com/zyantific/zycore-c/tree/0c372cdefe799e99812c008a0b74537bfa5fe077">GitHub - zyantific&#x2F;zycore-c at 0c372cdefe799e99812c008a0b74537bfa5fe077</a></p><p>之后将zydis放置于<code>WhiteRabbitTracker/deps/</code>下，将zycore放置于<code>WhiteRabbitTracker/deps/zydis/dependencies/</code>下即可。</p></li><li><p>配置相关环境：</p><p>虽然zydis号称几乎不需要任何额外的库，但是在编译时一些基础的工具时必要的。</p><p>安装以下工具：<code>Cmake</code>,<code>Visual Studio x86 2019</code>(2017也可以，对应的SDK和WDK最好要与之对应)，visual studio 2019对应的<code>SDK</code>和<code>WDK</code>（也可以不对应，但是SDK和WDK版本一定要一致，且一定要对应Windows 10 1709之后的版本，同时SDK安装时后会提示安装对应的Visual Studio扩展，一定要记得安装，否则VS无法检测到对应的WDK），额外安装<code>WDK 8.1</code>。</p><p>下载<code>Intel Pin v3.15</code>压缩文件，在C盘根目录创建<code>pin315</code>目录，将压缩文件内文件解压到改目录下，在环境配置中添加该目录。</p></li><li><p>编译项目：</p><p>首先要对<code>zydis</code>进行编译，用VS打开<code>zydis/msvc/</code>下的<code>Zydis.sln</code>，导入解决方案，检查所有项目的配置页的VS库版本号和WDK号是否正确或者满足，无误后，运行模式选择<code>Debug MT DLL</code>，(MT代表静态链接，会将所需的链接库都一次编译进来，否则后续可能会提示缺少必要组件，同时，最好选择用管理员权限打开VS，防止某些文件无法访问，DLL后缀代表生成DLL文件)，同时选择<code>Win32</code>，之后运行，默认会先编译Zydis和Zycore，生成必要的组件后，运行第一个示例。</p><p>完成后，会在<code>deps/zydis/msvc/bin/DebugX86</code>下找到<code>WhiteRabbitTracker</code>需要的<code>Zydis.dll</code>, <code>Zycore.dll</code>, <code>Zydis.lib</code> 和 <code>Zycore.li</code>，这代表编译没有问题。</p><p>同样的，用VS2019打开<code>WhiteRabbitTracker/solution.sln</code>,会提示升级库，WDK选择8.1。</p><p>如果编译提示找不到某些库，那就是WDK之类的地址没有对，修改根目录下的<code>Locals.props</code>，由于使用的是32位系统，因此不存在<code>Program Files (x86)</code>文件夹，仅有<code>Program Files</code>文件夹，所以需要修改<code>WinHPath</code>标签对应的地址。</p><p>编译成功后，在<code>pin</code>的目录下，可以找到<code>WhiteRabbitTracker.dll</code>文件。通过以下指令即可实现对软件的反逃逸。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Pin315\pin.exe -t WhiteRabbitTracker32.dll [options] -- &lt;file.exe&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="运行尝试："><a href="#运行尝试：" class="headerlink" title="运行尝试："></a>运行尝试：</h4><p>最好在Windows 7 sp1 x86下运行，将前一个虚拟机中<code>pin315</code>目录复制到新的虚拟机中即可使用。</p><p>同样的，使用指令对<code>pafish.exe</code>进行反逃逸，对比直接运行<code>patfish.exe</code>的结果，成功使之将虚拟机识别为真实环境。</p><p>    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;WhiteRabbitTracke项目运行和问题&quot;&gt;&lt;a href=&quot;#WhiteRabbitTracke项目运行和问题&quot; class=&quot;headerlink&quot; title=&quot;WhiteRabbitTracke项目运行和问题&quot;&gt;&lt;/a&gt;WhiteRabbitTra</summary>
      
    
    
    
    
    <category term="软件逃逸" scheme="https://boneink.github.io/tags/%E8%BD%AF%E4%BB%B6%E9%80%83%E9%80%B8/"/>
    
    <category term="IntelPin" scheme="https://boneink.github.io/tags/IntelPin/"/>
    
    <category term="恶意软件检测" scheme="https://boneink.github.io/tags/%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>挖矿样本特征总结</title>
    <link href="https://boneink.github.io/2022/06/27/%E6%8C%96%E7%9F%BF%E6%A0%B7%E6%9C%AC%E7%89%B9%E5%BE%81%E6%80%BB%E7%BB%93/"/>
    <id>https://boneink.github.io/2022/06/27/%E6%8C%96%E7%9F%BF%E6%A0%B7%E6%9C%AC%E7%89%B9%E5%BE%81%E6%80%BB%E7%BB%93/</id>
    <published>2022-06-27T04:00:00.000Z</published>
    <updated>2022-06-27T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、挖矿病毒的套路-https-zhuanlan-zhihu-com-p-164557943"><a href="#一、挖矿病毒的套路-https-zhuanlan-zhihu-com-p-164557943" class="headerlink" title="一、挖矿病毒的套路: https://zhuanlan.zhihu.com/p/164557943"></a>一、挖矿病毒的套路: <a href="https://zhuanlan.zhihu.com/p/164557943">https://zhuanlan.zhihu.com/p/164557943</a></h3><ol><li><p>DTStealer(又名“永恒之蓝下载器木马”)</p><ul><li><p>病毒运行后，除了执行挖矿行为，占用终端资源以外，还会窃取终端信息并回传服务器，并利用钓鱼邮件、SMBexec、WMIexec、常见漏洞等方式，在内、外网肆意传播。</p><p>该病毒内网传播方式较多，在部署火绒查杀后，还有被其他已经中毒终端攻击攻击的可能，出现火绒“文件实时监控”的查杀记录。</p></li><li><p>感染症状<br>如您的终端出现以下症状，极有可能感染了此病毒。<br>（1）出现以下名称的任务计划:<br>l Drivers<br>l WebServers<br>l DnsScan<br>l Bluetooths<br>l Credentials<br>l Rtsa·<br>l 00-00-00-00-00-00或??-??-??-??-??-??(MAC地址)<br>l Bluetea<br>l Blackball<br>（2）以下位置可能会生成的病毒文件:<br>l C:\Windows\temp\svchost.exe<br>l %AppData%\Microsoft\cred.ps1<br>l %AppData%\flashplayer.tmp<br>l %AppData%\Microsoft\Windows\StartMenu\Programs\Startup\FlashPlayer.lnk<br>（3）U盘内出现以下文件：<br>l blue3.bin<br>l blue6.bin<br>l (D-K)blue3.lnk<br>l (D-K)blue6.lnk<br>（4）火绒出现”隐藏执行PowerShell”、“利用PowerShell执行可疑脚本”等系统加固拦截<br><img src="https://pic2.zhimg.com/v2-8ac149f62555c15478d4565a9863bc75_b.jpg" alt="image"><br>（5)可能会出现的网址访问拦截:<br>l <a href="http://beahh.com/">http://beahh.com</a><br>l <a href="http://ackng.com/">http://ackng.com</a><br>l <a href="http://zer2.com/">http://zer2.com</a></p></li></ul></li><li><p>WannaMine</p><ul><li>该挖矿病毒于2017年底被发现，也是企业内较为常见的挖矿病毒、病毒运行后会扫描企业网络内是否启用了445端口的终端，并通过”永恒之蓝”漏洞在内网横向传播，感染更多终端进行挖矿。</li><li>感染症状<br>如果火绒“文件实时监控”拦截查杀以下目录内的“永恒之蓝”传播组件，则有可能感染了此病毒。<br>l C:\Windows\SpeechsTracing<br>l C:\Windows\NetworkDistribution<br>火绒”文件实时监控”查杀此挖矿程序：<br>l C:\Windows\SysWOW64\dllhostex.exe</li></ul></li><li><p>隐匿者(MyKings)</p><ul><li><p>隐匿者(MyKings)是由多个子僵尸网络构成的多重僵尸网络，除挖矿外，该僵尸网络还包含DDoS、Proxy、RAT等恶意功能。自2017年以来，该僵尸网络至今处于持续更新、传播的状态。</p><p>该病毒会感染MBR，在系统引导时进行加载，加载时机多早于正常的软件启动，成功加载后除了执行恶意行为外，还会对自身进行保护。</p></li><li><p>感染症状</p><p>终端被感染后，会出现以下特征：</p><p>（1）安全软件部署后，无法正常运行</p><p>l Sql Server日志内，出现大量”sa”账户登陆失败日志。</p><p>l Sql Server的作业内，出现异常定时作业。</p><p>（2）出现以下任务计划</p><p>l My</p><p>l Mysa</p><p>l ok</p><p>（3）出现以下文件：</p><p>l C:\Windows\debug\lsmo.exe</p><p>l C:\Windows\debug\lsmos.exe</p><p>l C:\Windows\debug\ok.dat</p><p>l C:\Windows\System32\ok.exe</p><p>l C:\Windows\temp\conhost.exe</p><p>l C:\Windows\System\msinfo.exe</p></li></ul></li><li><p>匿影挖矿</p><ul><li><p>匿影挖矿于2019年2月被发现，该病毒会利用大量网络上的公共资源(例如免费图床)存放病毒模块。在企业内，会利用”永恒之蓝”在内网横向传播，感染更多终端进行挖矿。病毒运行后，会利用驱动阻碍安全软件正常运行，并对自身进行保护。</p><p>该挖矿会利用驱动妨碍安全软件正常运行。</p></li><li><p>终端被感染后，出现以下文件：</p><p>l C:\Windows\Temp\retboolDriver.sys</p><p>l C:\Windows\Temp\FlrefoxDriver.sys</p><p>l C:\ProgramData\dll*</p><p>l C:\ProgramData\kuaizipUpdateChecker.dll</p><p>l C:\ProgramData\MS_17_010_Scan.exe</p><p>l C:\ProgramData\Microsoft\Chromme.exe</p><p>l C:\ProgramData\Flrefox.exe</p></li></ul></li><li><p>紫狐</p><ul><li><p>紫狐病毒最初发现于2018年，多年来一直保持活跃，除了挖矿外，该病毒还有流量暗刷、DDoS、盗号、恶意推广等恶意行为。并会通过软件捆绑、Ghost镜像、永恒之蓝、Sql暴破、服务漏洞等方式进行传播。</p><p>该病毒会通过驱动对自身进行保护。</p></li><li><p>感染症状</p><p>被感染终端，会出现以下文件：</p><p>l C:\Windows\System32\Ms********App.dll(*为任意字符)</p></li></ul></li></ol><h3 id="二、Avast-Q4-x2F-21-Threat-report：https-decoded-avast-io-threatresearch-avast-q4-21-threat-report"><a href="#二、Avast-Q4-x2F-21-Threat-report：https-decoded-avast-io-threatresearch-avast-q4-21-threat-report" class="headerlink" title="二、Avast Q4&#x2F;21 Threat report：https://decoded.avast.io/threatresearch/avast-q4-21-threat-report/"></a>二、Avast Q4&#x2F;21 Threat report：<a href="https://decoded.avast.io/threatresearch/avast-q4-21-threat-report/">https://decoded.avast.io/threatresearch/avast-q4-21-threat-report/</a></h3><p>CoinHelper是流行的硬币矿工之一，在 21 年第四季度仍然非常活跃，主要<code>Russia</code>针对<code>Ukraine</code>. 当恶意软件在受害者的系统上执行时，<code>CoinHelper</code>通过网络下载臭名昭著的 XMRig 矿工<code>Tor</code>并开始挖矿。除了硬币挖掘，CoinHelper 还收集有关受害者的各种信息，以识别他们的地理位置、他们安装的 AV 解决方案以及他们正在使用的硬件。</p><p>该恶意软件以捆绑的形式与许多流行的应用程序、破解软件（例如<code>MS Office</code>，游戏和游戏作弊程序（例如<code>Minecraft</code>and <code>Cyberpunk 2077</code>），甚至是干净的安装程序（例如<code>Google Chrome</code>or <code>AV products</code>）以及隐藏在 中<code>Windows 11 ISO image</code>，等等）一起传播。通过种子下载捆绑的应用程序也支持传播范围，进一步滥用了下载软件的非官方方式。</p><p>尽管我们观察到多种加密货币（包括以太坊或比特币）被配置为开采，但有一种特殊类型脱颖而出—— <code>Monero</code>. 尽管门罗币被设计为匿名的，但由于地址使用错误和矿池运作机制，我们能够更深入地了解恶意软件作者的门罗币挖矿操作，并发现总的货币收益CoinHelper<code>339,694.86 USD</code>截至 2021 年 11 月 29 日。</p><h3 id="三、关于CoinHelper（https-decoded-avast-io-janrubin-toss-a-coin-to-your-helper-）"><a href="#三、关于CoinHelper（https-decoded-avast-io-janrubin-toss-a-coin-to-your-helper-）" class="headerlink" title="三、关于CoinHelper（https://decoded.avast.io/janrubin/toss-a-coin-to-your-helper/）:"></a>三、关于CoinHelper（<a href="https://decoded.avast.io/janrubin/toss-a-coin-to-your-helper/%EF%BC%89">https://decoded.avast.io/janrubin/toss-a-coin-to-your-helper/）</a>:</h3><p>CoinHelper 大多与 WinRAR 和游戏秘籍等破解软件安装程序捆绑在一起。</p><p>其传播方式之一为通过MyKing的僵尸网络的剪切板窃取进行传播（<a href="https://decoded.avast.io/janrubin/the-king-is-dead-long-live-mykings/%EF%BC%89%E3%80%82">https://decoded.avast.io/janrubin/the-king-is-dead-long-live-mykings/）。</a></p><p>通过剪切板窃取，误导用户在下载软件时，使用被绑定了CoinHelper的软件，从而无意中执行该程序。</p><p>感染流程：</p><p><img src="https://decoded.avast.io/wp-content/uploads/sites/2/2021/11/image-29.png" alt="image"></p><ol><li><p>修复损坏的存档、执行第二阶段和确保持久性：</p><p>下载获得一个名称和图标均正常的exe文件（为一个已经编译的Autolt二进制文件）。</p><p>提取后，可以获得三个组件：</p><ul><li><code>asacpiex.dll</code>（一个损坏（修改）的 7zip 存档，带有恶意软件的第二阶段）</li><li><code>CL_Debug_Log.txt</code>（干净的 7zip 独立可执行文件）</li><li><code>glue\ChromeSetup.exe</code></li></ul><p>第一阶段还包含一个非常简单但有效的附加功能：攻击者收集有关受害者的信息，重点关注受害者的操作系统、安装的 RAM 数量、CPU 和显卡信息，以及系统上存在的安全解决方案。所有收集到的信息都被格式化并连接成一个字符串。</p><p>然后，该字符串通过 GET 请求以用户代理的形式发送到硬编码的 URL 地址。在我们的示例中，硬编码的 URL 看起来像<code>https://2no[.]co/1wbYc7</code>.</p></li><li><p>修复asacpiex.dll后，将其保存为CR_Debug_Log.txt到Temp文件夹中。</p><p>为了解压档案，恶意软件使用密码JDQJndnqwdnqw2139dn21n3b312idDQDB。这是这些 AutoIt dropper 最常用的密码。但是，它不是唯一的，到目前为止，我们还计算了两个额外的密码：</p><p>dkwqdqw9324328NDQDN@@!)(#($%&amp;^!ND21<br>jDWQJkdqkwdqo2m@mdwmsxPAS,sq%<br>解包显示两个附加文件：</p><p>32.exe<br>64.exe</p><p>根据操作系统的体系结构以及 AES 指令集是否可用，这些文件之一将被复制到<br><code>C:\Users\&lt;username&gt;\AppData\Roaming\Microsoft\Windows\Helper.exe</code><br>并执行（通过计划任务）。</p><p>这两个文件都再次编译了 AutoIt 脚本，具有通过 Tor 网络以硬币矿工的形式向受害者分发更多有效负载的功能。</p><p>尽管<code>Helper.exe</code>它是迄今为止最常见的恶意软件名称，但它并不是唯一的可能性。我们在野外看到的其他选项例如：</p><ul><li><code>fuck.exe</code></li><li><code>Helperr.exe</code></li><li><code>svchost.exe</code></li><li><code>System.exe</code></li><li><code>system32.exe</code></li><li><code>WAPDWA;DJ.exe</code></li><li><code>WorkerB.exe</code></li></ul><p>关于hepler.exe：主要目标是通过 Tor 网络将 XMRig 硬币矿工投放到受害者的系统上。</p><p><code>Helper.exe</code>还拥有许多其他功能，例如在受害者的 PC 上执行多个系统检查、将自身注入<code>%WINDIR%\System32\attrib.exe</code>系统二进制文件、检查系统的“空闲”以加强挖掘等等。</p><p>通过tor网络将coinminer下载到受感染系统的准备：</p><p>首先，该恶意软件包含两个额外的十六进制文件。第一个再次是一个干净的 7zip 二进制文件（但不同于<code>CL_Debug_Log.txt</code>），第二个是一个 7zip 存档，其中包含一个干净的 Tor 二进制文件和所属库：</p><ul><li><p><code>libcrypto-1_1-x64.dll</code></p></li><li><p><code>libevent-2-1-7.dll</code></p></li><li><p><code>libevent_core-2-1-7.dll</code></p></li><li><p><code>libevent_extra-2-1-7.dll</code></p><ul><li><code>libgcc_s_seh-1.dll</code></li></ul></li><li><p><code>libssl-1_1-x64.dll</code></p></li><li><p><code>libssp-0.dll</code></p><ul><li><code>libwinpthread-1.dll</code></li></ul></li><li><p><code>tor.exe</code></p></li><li><p><code>zlib1.dll</code></p></li></ul><p>tor解压密码：DxSqsNKKOxqPrM4Y3xeK<br>Tor 执行后，它会监听<code>9303</code>localhost ( <code>127.0.0.1</code>) 上的端口并等待请求。为防止此时出现混淆，请注意默认情况下此执行是隐藏的，因为<code>tor.exe</code>不应将其误认为是 Tor 浏览器。<code>tor.exe</code>是一个提供 Tor 路由的进程（没有 GUI）。在常见的 Tor 浏览器安装中，通常可以在<code>\&lt;Tor browser root folder&gt;\Browser\TorBrowser\Tor\tor.exe</code>.<br>该脚本还包含 C&amp;C 服务器的一些 Base64 编码的 Tor 地址，并尝试哪个是活着的。这是通过通过精心制作的请求（以十六进制形式）初始化 SOCKS4 通信来完成的：所需的服务器地址<br> <code>04 01 00 50 00 00 00 FF 00 $host 00</code><br> 该恶意脚本仅仅在收到一个包含了0x5A字节的标准协议响应后才会进一步与服务器进行通信。</p><p>恶意软件能从服务器上下载四个文件：</p><ul><li><code>public/upd.txt</code></li><li><code>public/64/64.txt</code>（或者<code>public/32/32.txt</code>如果使用脚本的“32 位变体”）</li><li><code>public/vc/amd.txt</code></li><li><code>public/vc/nvidia.txt</code></li></ul><p>文件<code>64.txt</code>( <code>32.txt</code>)、<code>amd.txt</code>和<code>nvidia.txt</code>都是 <strong>XMRig coinminers（编码和压缩），用于 CPU 或相应的 GPU 卡</strong>。</p><p>该<code>upd.txt</code>文件是一个纯文本文件，其中包含由<code>_</code>和<code>!</code>符号界定的版本号，例如<code>_!1!_</code>. 恶意软件会询问服务器当前版本多少，如果版本较新，则所有 coinminers都会更新。</p><p>矿工从 C&amp;C 下载为十六进制字符串，以常量字符串结尾<code>_!END!_</code>。移除结束存根并解码字符串后，我们得到一个 7zip 存档。我们可以使用<code>DxSqsNKKOxqPrM4Y3xeK</code>密码来解压它。</p><p>解压后，我们可以得到这些文件：</p><ul><li><code>SysBackup.txt</code>– 适用于 CPU 矿工（32 位和 64 位）</li><li><code>SysBackupA.txt</code>– 当还检测到 AMD GPU 时</li><li><code>SysBackupN.txt</code>– 当还检测到 NVIDIA GPU 时</li></ul><p>这些文件再次以十六进制形式出现，这次以<code>0x</code>前缀开头，没有结束存根。</p><hr><p><strong>挖矿</strong></p><p>挖矿（和 7zip 解包）是通过进程注入执行的。CPU 挖矿是通过注入新创建和挂起的 <code>%WINDIR%\System32\attrib.exe</code>.</p><p>所有其他组件的执行，例如 GPU 挖掘或从 Tor 下载的 coinminer 有效载荷的解包，都是通过注入自身来完成的，这意味着使用一个新的暂停实例<code>Helper.exe</code>进行注入。当支持 GPU 挖矿时，CPU 和 GPU 并行执行。</p><p>根据我们的研究，我们只看到 XMRig 被部署为最终的挖矿有效载荷。该恶意软件使用通用参数执行它，其中一种方法值得一提——为挖矿服务器“设置密码”的参数<code>-p</code>。在标准情况下，密码并不重要，因此恶意软件作者通常使用“ <code>x</code>”作为密码。然而，在这种情况下，恶意软件会生成受害者的 GUID 并将其附加到通常的“ <code>x</code>”中。</p><p><strong>持久性</strong></p><p>与第一阶段类似，在第二阶段开始时，会检查并在必要时创建特定的互斥锁：</p><ul><li><code>QPRZ1bWvXh</code></li><li><code>QPRZ1bWvXh2</code></li></ul><p>正如我们所看到的，与第一阶段（）相比，只有互斥锁中间的数字发生了变化<code>QPRZ3bWvXh</code>。第二个互斥体附加了一个常量<code>2</code>。我们也看到<code>QPRZ2bWvXh</code>了使用，再次更改中间数字。</p><p>为了尽可能长时间地隐藏，恶意软件使用原生 AutoIt <code>ProcessExists</code>功能检查多个进程，以检查任何正在运行的系统监控和分析工具：</p><ul><li><code>aida64.exe</code></li><li><code>AnVir.exe</code></li><li><code>anvir64.exe</code></li><li><code>GPU-Z.exe</code></li><li><code>HWiNFO32.exe</code></li><li><code>HWiNFO64.exe</code></li><li><code>i7RealTempGT.exe</code></li><li><code>OpenHardwareMonitor.exe</code></li><li><code>pchunter64.exe</code></li><li><code>perfmon.exe</code></li><li><code>ProcessHacker.exe</code></li><li><code>ProcessLasso.exe</code></li><li><code>procexp.exe</code></li><li><code>procexp64.exe</code></li><li><code>RealTemp.exe</code></li><li><code>RealTempGT.exe</code></li><li><code>speedfan.exe</code></li><li><code>SystemExplorer.exe</code></li><li><code>taskmgr.exe</code></li><li><code>VirusTotalUpload2.exe</code></li></ul><p>当发现该工具时，恶意软件会暂时禁用挖掘。有关运行硬币矿工的信息存储在两个文件中：</p><ul><li><code>mn.pid</code></li><li><code>gmn.pid</code></li></ul><p>该恶意软件还监控受害者目前是否实际使用他们的 PC。如果用户空闲了一段时间，在我们的特殊情况下为 3 分钟，当前的挖矿将终止，并执行一个新的挖矿过程并设置为在所有线程上利用 100% 的 CPU。此信息 (PID) 存储在名为<code>mn.ld</code>. 主动使用 PC 时，挖矿设置为可用性能的 50%。另一方面，GPU 挖掘<strong>仅</strong>在用户没有主动使用他们的 PC 时（2 分钟）执行。</p><p>该恶意软件还列出了系统上存在的所有控制台窗口，并找出那些可见性设置为隐藏的控制台窗口。如果找到这样的窗口并且它不属于 CoinHelper，则恶意软件会</p><p>程。</p><p><strong>数据收集和反病毒检查</strong></p><p>与之前的 AutoIt 阶段类似，它<code>Helper.exe</code>也会收集有关受感染系统的信息。</p><p>如果检测到任何在列表中的卡并且视频适配器名称与“ <code>Advanced Micro Devices, Inc.</code>”或“ <code>NVIDIA</code>”匹配，则恶意软件使用 XMRig 来利用 GPU 进行挖矿。</p></li><li><p>除了我们开始调查的 Yandex 磁盘存储之外，我们可以确认，传播 CoinHelper 的另一种重要方法是通过放置在专注于破解软件的互联网论坛上的恶意种子。</p></li></ol><h3 id="四、DirtyMoe-Introduction-and-General-Overview-of-Modularized-Malware：https-decoded-avast-io-martinchlumecky-dirtymoe-1"><a href="#四、DirtyMoe-Introduction-and-General-Overview-of-Modularized-Malware：https-decoded-avast-io-martinchlumecky-dirtymoe-1" class="headerlink" title="四、DirtyMoe: Introduction and General Overview of Modularized Malware：https://decoded.avast.io/martinchlumecky/dirtymoe-1/"></a>四、DirtyMoe: Introduction and General Overview of Modularized Malware：<a href="https://decoded.avast.io/martinchlumecky/dirtymoe-1/">https://decoded.avast.io/martinchlumecky/dirtymoe-1/</a></h3><ol><li><p>DirtyMoe整体介绍：</p><p>DirtyMoe 恶意软件使用了一个简单的想法，即如何同时<strong>模块化、不可检测和不可跟踪</strong>。该恶意软件的目标主要集中在 Cryptojacking 和 DDoS 攻击。DirtyMoe 通过 EternalBlue 和至少三个其他漏洞在系统级权限下作为 Windows 服务运行。特定功能由恶意软件作者远程控制，他们可以在几个小时内将数千个 DirtyMoe 实例重新配置为所需的功能。DirtyMoe 只是下载一个加密的有效载荷，对应于所需的功能，并将有效载荷注入自身。</p></li><li><p>感染方式：</p><p>攻击者通过端口扫描和漏洞开放数据库，发现并瞄准大量弱计算机。PurpleFox 是 DirtyMoe 常用的漏洞利用工具包。之后通过如EnternalBlue漏洞或 SMB 密码暴力破解 Windows 等获取管理员权限。</p><p>用 DirtyMoe 感染受害者机器的另一种方法是钓鱼电子邮件，其中包含可以通过 Internet Explorer 攻击目标的 URL。</p><p>此外，通过受感染的正常文件来部署也是方式之一。</p><p>当其中一个漏洞利用成功并获得系统权限时，DirtyMoe 可以安装在受害者的机器上。我们观察到 DirtyMoe 利用 Windows MSI Installer 来部署恶意软件。MSI Installer 提供了一种在多个平台和 Windows 版本上安装适当软件的简单方法。每个版本都需要安装文件和注册表项的不同位置。恶意软件作者可以轻松地为目标系统和平台设置 DirtyMoe 配置。</p><p>MSI Installer 通过 MSI 安装程序将受害者环境准备到适当的状态。他们专注于禁用反间谍软件和文件保护功能。此外，MSI 软件包使用一项系统功能，该功能有助于覆盖系统文件以进行恶意软件部署。</p><p>MSI Installer 通过修改注册表，修改系统文件从而避免自身被检测。</p><p>DirtyMoe 服务在 maware 部署期间在系统中注册。在开始时，该服务提取并加载 DirtyMoe 驱动程序以保护自己。加载驱动程序时，该服务会从文件系统和注册表中清除有关该驱动程序的所有证据。</p><p>DirtyMoe 恶意软件由两个进程组成，即<em>DirtyMoe Core</em>和<em>DirtyMoe Executioner</em>，由 DirtyMoe 服务创建，如果进程被创建和配置，则会自行终止。DirtyMoe 服务通过多个随时间终止的进程和线程创建<em>核心</em>和<em>执行器进程。</em>因此，取证和跟踪方法更加困难。</p></li><li><p>安装：</p><p><em>DirtyMoe Core</em>负责将恶意代码注入执行它的<em>DirtyMoe Executioner</em>。注入的代码，称为 MOE 对象或模块，是从 C&amp;C 服务器下载的。MOE 对象是<em>DirtyMoe Core</em>解密并注入<em>DirtyMoe Executioner</em>的加密 PE 文件。</p><p>此外，确定<em>DirtyMoe Core</em>介绍行为的初始有效负载由 MSI 安装程序部署为<code>sysupdate.log</code>文件。因此，<em>DirtyMoe Core</em>可以通过有效负载注入来更新或更改自己的功能。</p></li><li><p>控制和行动：</p><p><em>DirtyMoe Core</em>和<em>DirtyMoe Executioner</em>为恶意软件作者提供了一个接口，他们可以远程模块化 DirtyMoe 并通过 MOE 对象更改用途和配置。<em>DirtyMoe Core</em>与命令和控制 (C&amp;C) 服务器通信以获取攻击者命令。因此，整个复杂的层次结构高度模块化，配置和控制非常灵活。</p><p>C&amp;C 通信的阴险之处在于 DirtyMoe 没有使用固定的 IP 地址，而是实施了一种独特的机制来混淆最终的 C&amp;C 服务器地址。因此，不可能阻止受害者机器上的 C&amp;C 服务器，因为每次 C&amp;C 通信的服务器地址都不同。此外，该机制基于无法轻易阻止的 DNS 请求，因为它会影响日常通信。</p><blockquote><p>关于 DirtyMoe 模块化，如果恶意软件作者不需要进行有针对性的攻击，加密挖掘似乎是一种持续使用受害者机器的活动。因此，加密采矿是和平时期的一项活动。然而，绿盟科技威胁情报中心发现了分布式拒绝服务（DDoS）攻击[<a href="https://decoded.avast.io/martinchlumecky/dirtymoe-1/#ref">1]</a>。一般来说，DirtyMoe 可以将任意恶意软件部署到受感染的系统中，例如信息窃取器、勒索软件、木马等。</p></blockquote></li><li><p>自我保护机制：</p><p> DirtyMoe 驱动程序提供了广泛的功能；请参阅以下候选名单：</p><ul><li>Minifilter：对目录枚举的影响（隐藏、插入、修改）</li><li>注册表隐藏：可以隐藏已定义的注册表项</li><li>服务隐藏：修补<code>service.exe</code>结构以隐藏所需的服务</li><li>驱动隐藏：可以在系统中隐藏自己</li></ul><p>DirtyMoe 代码包含许多可以被大多数 AV 捕获的恶意模式。恶意软件作者使用 <strong>VMprotect 来混淆 DirtyMoe 服务 DLL 文件</strong>。下载的 DirtyMoe 对象使用硬编码密钥使用对称密码进行加密。我们已经看到了几个 MOE 对象，<strong>它们本质上包含相同的 PE 文件，只是 PE 标头不同</strong>。尽管如此，即使是这些轻微的修改也足以让使用的密码产生完全不同的 MOE 对象。因此，<strong>静态检测不能应用于 MOE 加密对象</strong>。此外，DirtyMoe 不会将解密后的 MOE 对象（PE 文件）转储到文件系统中，而是<strong>直接将 MOE 对象注入内存</strong>。</p><p> DirtyMoe 工作人员是通过多个进程和线程启动的。工作人员最初运行为<code>svchost.exe</code>，但 DirtyMoe 驱动程序将工作人员的进程名称更改为<code>fontdrvhost.exe</code>。DirtyMoe 有两个相互保护的工作进程（<em>Core</em>和<em>Executioner</em>）。因此，如果第一个工作人员被杀死，第二个工作人员将启动第一个工作人员的新实例，反之亦然。</p><p><strong>反检测</strong>补充：DirtyMoe: Deployment：<a href="https://decoded.avast.io/martinchlumecky/dirtymoe-4/">https://decoded.avast.io/martinchlumecky/dirtymoe-4/</a></p><p><strong>DisableAntiSpyware</strong><br><code>HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Windows Defender\DisableAntiSpyware = 1</code><br>Microsoft Defender Antivirus 可以通过将<code>DisableAntiSpyware</code>注册表项设置为 1 来禁用。因此，如果系统没有第三方防病毒产品，则系统没有针对恶意软件的保护，包括间谍软件。</p><p><strong>SFCDisable</strong><br><code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\SFCDisable = 4</code><br>Windows 文件保护 (WFP) 可防止非系统应用程序替换可能导致操作系统完整性和稳定性问题的关键 Windows 系统文件。WFP 通常在所有版本的 Windows中默认启用。</p><p>自然地，DirtyMoe 希望避免 WFP 检测到对系统文件进行任何操作的情况。因此，该<code>SFCDisable</code>值设置为4，启用 WFP，但 GUI 不会弹出每个 WFP 操作。效果是 WFP 已启用，因此不会调用系统警报，但会为用户隐藏 WFP 警告。<strong>这仅适用于 Windows XP。</strong></p><p><strong>SFCScan</strong><br><code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\SFCScan = 0</code><br>系统文件检查器 (SFC) 提供扫描受系统保护的文件的能力。SFC 验证文件版本，如果它检测到任何文件操作，SFC 将文件更新为正确的版本。这种注册表操作有助于禁用 SFC 保护滥用的 Windows 服务。此设置仅影响文件扫描，但 WFP 仍可处于活动状态。</p><p><strong>SvcHostSplitThresholdInKB</strong><br><code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SvcHostSplitThresholdInKB = 0xFFFFFFFF</code><br>关键的注册表操作控制系统启动和设备配置的某些方面。</p><p>在大多数情况下，Windows 服务从 Windows 通过通用主机进程 (svchost.exe) 执行的动态链接库运行。托管进程可以在一个进程中加载更多服务 (DLL) 作为线程。这是 Windows XP 时代的历史遗留物，当时系统内存曾经是一种稀缺商品。该系统使用了一些托管所有 Windows 服务的服务主机进程，由 DLL 文件表示，因为进程的创建和维护在系统内存方面是昂贵的。</p><p>如今，没有理由将服务分组在几个进程中，由此产生的积极影响是提高了系统的稳定性和安全性，以及更容易进行错误分析。服务现在通常不再共享进程；提供系统功能的小程序有一个独占的内存位置。并且如果 svchost.exe 进程崩溃，它不再拖着整个服务链。</p><p>Windows 10 带有一个阈值 ( <code>SvcHostSplitThresholdInKB</code>)，用于确定何时应将服务创建为常规进程。默认值为 380,000，因此如果系统内存小于 3.5 GB，则使用分组服务模型。也就是说，增大阈值可以减少宿主进程的数量，从而判断服务进程是否被拆分。</p><p>我们以 Windows 10 为例，如果该值设置为 1，则主机进程数约为。70. 等于最大值 ( <code>0xFFFFFFFF</code>) 的阈值导致主机进程数仅为 26。</p><p>最大值<code>SvcHostSplitThresholdInKB</code>可以隐藏有关运行进程的详细信息。因此，恶意软件作者将阈值设置为最大值以隐藏线程中的恶意服务活动。结果，恶意服务在其线程之一中的一个主机进程中运行。因此，跟踪和取证分析变得更加困难，因为 svchost 进程托管了许多其他服务，并且很难将系统活动分配给恶意软件服务。</p></li></ol><h3 id="五、Crackonosh-A-New-Malware-Distributed-in-Cracked-Software：https-decoded-avast-io-danielbenes-crackonosh-a-new-malware-distributed-in-cracked-software"><a href="#五、Crackonosh-A-New-Malware-Distributed-in-Cracked-Software：https-decoded-avast-io-danielbenes-crackonosh-a-new-malware-distributed-in-cracked-software" class="headerlink" title="五、Crackonosh: A New Malware Distributed in Cracked Software：https://decoded.avast.io/danielbenes/crackonosh-a-new-malware-distributed-in-cracked-software/"></a>五、Crackonosh: A New Malware Distributed in Cracked Software：<a href="https://decoded.avast.io/danielbenes/crackonosh-a-new-malware-distributed-in-cracked-software/">https://decoded.avast.io/danielbenes/crackonosh-a-new-malware-distributed-in-cracked-software/</a></h3><p>下图描述了整个 Crackonosh 安装过程。</p><p><a href="https://decoded.avast.io/wp-content/uploads/sites/2/2021/06/Installation-process.png"><img src="https://decoded.avast.io/wp-content/uploads/sites/2/2021/06/Installation-process.png" alt="img"></a>安装示意图</p><ol><li>首先，受害者运行破解软件的安装程序。</li><li>安装程序运行<code>maintenance.vbs</code></li><li><code>Maintenance.vbs</code>然后使用开始安装<code>serviceinstaller.msi</code></li><li><code>Serviceinstaller.msi</code>注册并运行<code>serviceinstaller.exe</code>，主要的恶意软件可执行文件。</li><li><code>Serviceintaller.exe</code> 运行<code>StartupCheckLibrary.DLL</code>。</li><li><code>StartupCheckLibrary.DLL</code>下载并运行<code>wksprtcli.dll</code>。</li><li><code>Wksprtcli.dll</code> 提取更新并<code>winlogui.exe</code> 删除它包含的内容，解密并放置在文件夹中。</li></ol><p>规避和禁用安全软件所采取的具体措施包括：</p><ul><li>在安全模式下删除防病毒软件</li><li>停止 Windows 更新(它会删除以下注册表项以停止 Windows Defender 并关闭自动更新。)</li><li>用绿色勾选系统托盘图标替换 Windows 安全</li><li>使用的库不使用将<code>DllMain</code>库作为主可执行文件 (by <code>rundll32.exe</code>) 运行时使用的常用库，而是从其他一些导出函数开始。</li><li>Serviceinstaller 测试它是否在安全模式下运行</li></ul><p>为了防止分析，它会采取以下操作来测试以确定它是否在 VM 中运行：</p><ul><li>检查注册表项：<ul><li><code>SOFTWARE\VMware, Inc</code></li><li><code>SOFTWARE\Microsoft\Virtual Machine\Guest\Parameters</code></li><li><code>SOFTWARE\Oracle\VirtualBox Guest Additions</code></li></ul></li><li>测试计算机时间是否在某个合理的时间间隔内，例如在恶意软件创建之后和 2023 年之前 ( <code>wksprtcli.dll</code>)</li></ul><p>此外，如前所述，它会延迟运行以更好地隐藏自己。我们发现特定安装程序使用硬编码的日期和时间来延迟，如下所示。</p><table><thead><tr><th><strong>SHA of installer</strong></th><th><strong>Installer doesn’t run before</strong></th></tr></thead><tbody><tr><td>9EC3DE9BB9462821B5D034D43A9A5DE0715FF741E0C171ADFD7697134B936FA3</td><td>2018-06-10 13:08:20</td></tr><tr><td>8C52E5CC07710BF7F8B51B075D9F25CD2ECE58FD11D2944C6AB9BF62B7FBFA05</td><td>2018-06-19 14:06:37</td></tr><tr><td>93A3B50069C463B1158A9BB3A8E3EDF9767E8F412C1140903B9FE674D81E32F0</td><td>2018-07-04 17:33:20</td></tr><tr><td>6A3C8A3CA0376E295A2A9005DFBA0EB55D37D5B7BF8FCF108F4FFF7778F47584</td><td>2018-07-10 15:35:57</td></tr><tr><td>4B01A9C1C7F0AF74AA1DA11F8BB3FC8ECC3719C2C6F4AD820B31108923AC7B71</td><td>2018-07-25 13:56:35</td></tr><tr><td>65F39206FE7B706DED5D7A2DB74E900D4FAE539421C3167233139B5B5E125B8A</td><td>2018-08-03 15:50:40</td></tr><tr><td>C6817D6AFECDB89485887C0EE2B7AC84E4180323284E53994EF70B89C77768E1</td><td>2018-08-14 12:36:30</td></tr><tr><td>7F836B445D979870172FA108A47BA953B0C02D2076CAC22A5953EB05A683EDD4</td><td>2018-09-13 12:29:50</td></tr><tr><td>D8C092DE1BF9B355E9799105B146BAAB8C77C4449EAD2BDC4A5875769BB3FB8A</td><td>2018-10-01 13:52:22</td></tr><tr><td>E497EE189E16CAEF7C881C1C311D994AE75695C5087D09051BE59B0F0051A6CF</td><td>2018-10-19 14:15:35</td></tr><tr><td>D7A9BF98ACA2913699B234219FF8FDAA0F635E5DD3754B23D03D5C3441D94BFB</td><td>2018-11-07 12:47:30</td></tr></tbody></table><p>它还采取了特定的行动来隐藏自己，以免使用可能会泄露其存在的工具的可能的高级用户。</p><p>它使用类似 Windows 的名称和描述，例如 <code>winlogui.exe</code>Windows 登录 GUI 应用程序。</p><p>它还检查正在运行的进程并将其与下面的阻止列表进行比较。如果它找到具有指定名称的进程<code>winrmsrv.exe</code>并<code>winlogui.exe</code>终止自身并等待PC的下一次启动。</p><ul><li><ul><li>Blocklist:<ul><li>dumpcap.exe</li><li>fiddler.exe </li><li>frst.exe </li><li>frst64.exe </li><li>fse2.exe </li><li>mbar.exe </li><li>messageanalyzer.exe </li><li>netmon.exe </li><li>networkminer.exe </li><li>ollydbg.exe </li><li>procdump.exe </li><li>procdump64.exe </li><li>procexp.exe </li><li>procexp64.exe </li><li>procmon.exe </li><li>procmon64.exe </li><li>rawshark.exe </li><li>rootkitremover.exe </li><li>sdscan.exe </li><li>sdwelcome.exe </li><li>splunk.exe </li><li>splunkd.exe </li><li>spyhunter4.exe </li><li>taskmgr.exe</li><li>tshark.exe </li><li>windbg.exe </li><li>wireshark-gtk.exe </li><li>wireshark.exe </li><li>x32dbg.exe </li><li>x64dbg.exe </li><li>X96dbg.exe</li></ul></li></ul></li></ul><h3 id="六、HackBoss-A-cryptocurrency-stealing-malware-distributed-through-Telegram：https-decoded-avast-io-romanalinkeova-hackboss-a-cryptocurrency-stealing-malware-distributed-through-telegram"><a href="#六、HackBoss-A-cryptocurrency-stealing-malware-distributed-through-Telegram：https-decoded-avast-io-romanalinkeova-hackboss-a-cryptocurrency-stealing-malware-distributed-through-telegram" class="headerlink" title="六、HackBoss: A cryptocurrency-stealing malware distributed through Telegram：https://decoded.avast.io/romanalinkeova/hackboss-a-cryptocurrency-stealing-malware-distributed-through-telegram/"></a>六、HackBoss: A cryptocurrency-stealing malware distributed through Telegram：<a href="https://decoded.avast.io/romanalinkeova/hackboss-a-cryptocurrency-stealing-malware-distributed-through-telegram/">https://decoded.avast.io/romanalinkeova/hackboss-a-cryptocurrency-stealing-malware-distributed-through-telegram/</a></h3><p>在窃取加密货币的恶意软件属于三个主要类别之一： </p><ul><li><code>Password stealers</code>：专注于窃取加密货币钱包或带有密码的文件的恶意软件。</li><li><code>Coinminers</code>：使用受害者机器的计算能力来挖掘加密货币的恶意软件。</li><li><code>Keyloggers</code>：记录击键以记录密码或助记词的恶意软件。</li></ul><p>这三类与加密货币相关的恶意软件加起来是过去一年中常见的第三大恶意软件类型。</p><p><img src="https://decoded.avast.io/wp-content/uploads/sites/2/2021/04/image-16.png" alt="img"><em>自 2020 年 3 月至 2021 年 3 月以来最常见的恶意软件类型</em></p><p>HackBoss 是一个简单的窃取加密货币的恶意软件，但它的金钱收益非常可观。这种恶意软件最有趣的方面是它传递给受害者的方式。HackBoss 的作者拥有一个 Telegram 频道，他们将其用作传播恶意软件的主要来源.</p><p>Hack Boss 频道上宣传虚假破解或黑客应用程序的帖子通常包含一个指向加密或匿名文件存储的链接，可以从中下载应用程序。该帖子还包含对应用程序假定功能的虚假描述以及应用程序 UI 的屏幕截图。它有时还包含一个指向 YouTube 频道的链接<code>https://www.youtube.com/channel/UC1IEdha7riKwVCfPk</code>（该频道在发布时已被删除）<code>Bank God</code> ，并带有促销视频。</p><p>Hack Boss 频道上宣传虚假破解或黑客应用程序的帖子通常包含一个指向加密或匿名文件存储的链接，可以从中下载应用程序。该帖子还包含对应用程序假定功能的虚假描述以及应用程序 UI 的屏幕截图。它有时还包含一个指向 YouTube 频道的链接<code>https://www.youtube.com/channel/UC1IEdha7riKwVCfPk</code>（该频道在发布时已被删除）<code>Bank God</code> ，并带有促销视频。</p><h3 id="七、SkidMap病毒利用Redis未授权访问漏洞攻击，数千台云主机沦为矿机（Linux）：https-mp-weixin-qq-com-s-biz-MzI5ODk3OTM1Ng-amp-mid-2247498404-amp-idx-2-amp-sn-bb356408fb8abc6e8d5a3411a42daa7a-amp-scene-19-wechat-redirect"><a href="#七、SkidMap病毒利用Redis未授权访问漏洞攻击，数千台云主机沦为矿机（Linux）：https-mp-weixin-qq-com-s-biz-MzI5ODk3OTM1Ng-amp-mid-2247498404-amp-idx-2-amp-sn-bb356408fb8abc6e8d5a3411a42daa7a-amp-scene-19-wechat-redirect" class="headerlink" title="七、SkidMap病毒利用Redis未授权访问漏洞攻击，数千台云主机沦为矿机（Linux）：https://mp.weixin.qq.com/s?__biz=MzI5ODk3OTM1Ng==&amp;mid=2247498404&amp;idx=2&amp;sn=bb356408fb8abc6e8d5a3411a42daa7a&amp;scene=19#wechat_redirect"></a>七、SkidMap病毒利用Redis未授权访问漏洞攻击，数千台云主机沦为矿机（Linux）：<a href="https://mp.weixin.qq.com/s?__biz=MzI5ODk3OTM1Ng==&amp;mid=2247498404&amp;idx=2&amp;sn=bb356408fb8abc6e8d5a3411a42daa7a&amp;scene=19#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzI5ODk3OTM1Ng==&amp;mid=2247498404&amp;idx=2&amp;sn=bb356408fb8abc6e8d5a3411a42daa7a&amp;scene=19#wechat_redirect</a></h3><ul><li>利用redis未授权访问漏洞入侵云主机；</li><li>下载门罗币、莱特币、比特币挖矿木马，通过挖矿牟利；</li><li>添加SSH公钥，以持久化远控失陷主机；</li><li>下载功能更加复杂的恶意软件包：接受远程指令，清除系统审计日志，安装服务，关闭SELinux降低系统安全性，通过安装Linux内核模块隐藏恶意行为。</li></ul><p>SkidMap病毒在2019年9月左右被发现，主要目标为感染肉鸡挖矿，该病毒的明显特征为通过加载Linux恶意内核模块来隐藏其恶意行为，增加了运维人员排查威胁的难度。</p><p>此次SkidMap病毒感染后会下载XMRig（门罗币挖矿木马）、cpuminer（莱特币和比特币挖矿木马），同时写入SSH后门公钥以方便远程登录，然后下载恶意程序包gold8.tar.gz，通过3DES解压后释放多个模块，完成挖矿木马启动、替换pam_unix.so文件留置登陆后门、上传日志到远程服务器，安装远控程序rctl的功能，还会安装Linux内核模块对恶意行为进行隐藏。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWWAXmCiceVcSLGmpT1yiabDzr7RZpFMhPrhk6Jspzj7HrYGXyX9sd8XVcK1k7vjV9lATGgrzibcKrqvw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><center>SkidMap病毒最新变种的恶意行为</center><h3 id="八、Sysrv-hello僵尸网络集木马、后门、蠕虫于一身，攻击Linux、Windows主机挖矿：https-mp-weixin-qq-com-s-biz-MzI5ODk3OTM1Ng-amp-mid-2247497474-amp-idx-1-amp-sn-87eb580380ee3ff5efd389da419f82c9-amp-scene-19-wechat-redirect"><a href="#八、Sysrv-hello僵尸网络集木马、后门、蠕虫于一身，攻击Linux、Windows主机挖矿：https-mp-weixin-qq-com-s-biz-MzI5ODk3OTM1Ng-amp-mid-2247497474-amp-idx-1-amp-sn-87eb580380ee3ff5efd389da419f82c9-amp-scene-19-wechat-redirect" class="headerlink" title="八、Sysrv-hello僵尸网络集木马、后门、蠕虫于一身，攻击Linux、Windows主机挖矿：https://mp.weixin.qq.com/s?__biz=MzI5ODk3OTM1Ng==&amp;mid=2247497474&amp;idx=1&amp;sn=87eb580380ee3ff5efd389da419f82c9&amp;scene=19#wechat_redirect"></a>八、Sysrv-hello僵尸网络集木马、后门、蠕虫于一身，攻击Linux、Windows主机挖矿：<a href="https://mp.weixin.qq.com/s?__biz=MzI5ODk3OTM1Ng==&amp;mid=2247497474&amp;idx=1&amp;sn=87eb580380ee3ff5efd389da419f82c9&amp;scene=19#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzI5ODk3OTM1Ng==&amp;mid=2247497474&amp;idx=1&amp;sn=87eb580380ee3ff5efd389da419f82c9&amp;scene=19#wechat_redirect</a></h3><p>该木马不仅攻击Linux系统，同时发现针对Windows平台的恶意载荷，攻击Windows系统成功后会植入powershell恶意脚本，脚本会进一步拉取Windows平台的相同模块到tmp目录执行。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYNEiasBtqHv28bRC3MkrxibbnSHEhJuHwQAeibPCibia9Iy2ziaF5d54icrnwg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>Linux系统下sysrv模块通过使用52013端口作为互斥量，端口开启状态判定为已感染环境直接退出，否则打开本地该端口进行占用。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYV8s9ib6NewG6XaLqLNNvO81uFTBCoTteIksff5gnbbkCoTjuu59fssg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYDexNqyxSGjrQCsj9V8wC2OS6EyFDtldt5RDIsqzUkHJmOmSXh7bZdg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>sysrv通过检测进程，判断network01进程（矿机进程）是否正常运行，如果未正常运行，就在tmp目录进一步释放出文件内嵌的elf文件，并命名为network01将其执行。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYlJjo4gvwviaIic78sFnS3PUdibSNu9ax8bcd1edyBU1JMUTPJjwnvhGfw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYicnYbPzf4tfL3RibSMCcHqPJaTfnp5mUIcPiaCs3Ry3hoX0EZycdD1AQw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYg2eSEYmpwQmxt7sO0qmQvDX6wEtsSlJafOC50RMzLRIDxJEib5XJsrw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>network01模块为门罗币矿机程序，该团伙通过清理可能的竞品挖矿进程或其他占CPU资料较多的进程实现独占CPU资源挖矿。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYibI5wb4WAPI0RoV0flaAVENJCjbkK9svXXNAqWqVP5cLBMameQrLoXw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>sysrv确认挖矿行为正常运行后，会开始进行蠕虫式的攻击传播：进行随机IP的端口扫描与漏洞利用，会尝试对mysql，Tomcat服务进行爆破攻击，尝试对Weblogic服务使用CVE-2020-14882漏洞（该漏洞公告由Oracle官方于2020年10月21日公开）进行远程代码执行攻击，这一横向扩散行为使该团伙控制的肉鸡规模迅速增大。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYrlm1UUrMpua7c2uqIUOc31pmBIjagN1gefmgYCpgnPKXRH2ATcoSYQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYKzbGSl4jicDxKzkt9CNYhKniaGhuxMdUz1xRw4xEqFZN190SicXeNwwPw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>hello_src_exp爆破，漏洞利用组合攻击</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYnEjXuw46MJfOpdlPb3QQXf7vRByRyUCDgcmVo9MDrsF0dcngxAN3NQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>攻击mysql服务使用的弱口令爆破字典</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYlf0XjYQzofW8lhJUkwmvUL6TNKqicUbx5Ichej0ictiasKpibANIpnmvGg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>攻击Tomcat服务使用的爆破口令</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYiannQk0ybp2bC8sRaMuV28RGazCX0PaFDHI9MTtCLI4TywfykEnhb5Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>对Weblogic组件利用CVE-2020-14882 远程代码执行漏洞攻击，该安全漏洞为2020年10月Oracle官方公告修复，属于相对比较新的漏洞攻击武器。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYO9MicAygYgvoIuOMFRicePv2oiblSukMgXsqfoZ55LvRNzdUXMRGEBBfg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6AoQM3RKCWUbhM7Eh1xwnmD5k3tnv1iaYZkqS78hCgOHDLDIzmbAUADicMHbORVOnDvG1SSpj3Jj3kdeJkoZdZGg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="九、Putting-an-end-to-Retadup-A-malicious-worm-that-infected-hundreds-of-thousands：https-decoded-avast-io-janvojtesek-putting-an-end-to-retadup-a-malicious-worm-that-infected-hundreds-of-thousands-（据文章介绍，服务器已被清查）"><a href="#九、Putting-an-end-to-Retadup-A-malicious-worm-that-infected-hundreds-of-thousands：https-decoded-avast-io-janvojtesek-putting-an-end-to-retadup-a-malicious-worm-that-infected-hundreds-of-thousands-（据文章介绍，服务器已被清查）" class="headerlink" title="九、Putting an end to Retadup: A malicious worm that infected hundreds of thousands：https://decoded.avast.io/janvojtesek/putting-an-end-to-retadup-a-malicious-worm-that-infected-hundreds-of-thousands/（据文章介绍，服务器已被清查）"></a>九、Putting an end to Retadup: A malicious worm that infected hundreds of thousands：<a href="https://decoded.avast.io/janvojtesek/putting-an-end-to-retadup-a-malicious-worm-that-infected-hundreds-of-thousands/%EF%BC%88%E6%8D%AE%E6%96%87%E7%AB%A0%E4%BB%8B%E7%BB%8D%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B7%B2%E8%A2%AB%E6%B8%85%E6%9F%A5%EF%BC%89">https://decoded.avast.io/janvojtesek/putting-an-end-to-retadup-a-malicious-worm-that-infected-hundreds-of-thousands/（据文章介绍，服务器已被清查）</a></h3><p>Retadup 是一种恶意蠕虫，影响整个拉丁美洲的 Windows 计算机。它的目标是在受害者的计算机上实现持久性，将自身传播得更广泛，并在受感染的计算机上安装额外的恶意软件有效负载。在绝大多数情况下，安装的有效负载是代表恶意软件作者挖掘加密货币的恶意软件。但是，在某些情况下，我们还观察到 Retadup 分发了 Stop 勒索软件和 Arkei 密码窃取程序。</p><p>核心是用 AutoIt 或 AutoHotkey 编写的。在这两种情况下，它都包含两个文件：干净的脚本语言解释器和恶意脚本本身。这与当今大多数 AutoIt 恶意软件不同，后者通常仅由一个包含解释器和恶意脚本的恶意可执行文件组成。在 Retadup 的 AutoHotkey 变种中，恶意脚本作为源代码分发，而在 AutoIt 变种中，脚本首先被编译然后分发。</p><p>首先，程序检查是否存在另一个Retadup实例在运行，以保证任何时间仅有一个实例运行。之后会进行一些基本检查确保自己没有被分析，否则便静默退出。最后进入一个无线循环，定期轮询C&amp;C服务器以获取命令，若收到来自C&amp;C的命令，则执行收到的命令的处理程序，在联系C&amp;C 的同时，它还会定期执行其他尝试来传播自己并恢复其持久性机制。</p><p>几乎所有的 Retadup 样本都会首先检查它们运行的文件系统路径。如果解释器路径或脚本路径与预期不同，则脚本不会执行任何恶意操作。大多数示例还实现了一种延迟执行的方法。在执行开始时，它们要么执行一次长睡眠，要么执行一系列多次短睡眠。最后，一些变体还检查名称为<code>vmtoolsd.exe</code> 或 <code>procmon.exe</code>的进程是否正在运行、名称为<code>C:\CWSandbox\</code>或<code>C:\cuckoo\``SbieDll.dll``api_log.dll</code>的目录是否存在以及名称为 或 的模块是否已加载到当前进程中。</p><p><strong>Retadup 通过在其中创建注册表值<code>HKCU\Software\Microsoft\Windows\CurrentVersion\Run</code>和&#x2F;或创建计划任务来实现持久性</strong>。计划任务是使用<code>schtasks.exe</code>实体程序创建的，并设置为每分钟执行一次。Retadup 的 AutoIt 变体通常使用硬编码的注册表值.名称，而 AutoHotkey 变体倾向于使用注册表值和随机生成名称的计划任务。</p><p>Retadup主要通过将恶意快捷方式文件放到驱动器中实现传播。首先，它会遍历除了C盘外的所有驱动器根目录下的文件夹，并在每个文件夹下创建一个快捷方式，该快捷方式与源文件名相同，仅附加一个如<code>copy fpl.lnk</code>的字符后缀，它模拟真实的文件夹从而诱导用户执行。Retadup还将干净的AutoIt&#x2F;AutoHotkey 解释器和恶意脚本复制到系统隐藏目录，该目录位于相对于所选中的<code>LNK</code>文件的硬编码路径中。</p><p>每个 Retadup 样本都配置了一组C&amp;C 域名和端口，样本通过向他们发出 HTTP GET 请求来单独联系他们，样本会在发出的请求的URL的路径中对受害者的一些信息进行编码。虽然编码信息的确切内容和形式在不同的 Retadup 变体中有所不同，但所有 Retadup 变体都会在路径的开头对受害者的 ID 进行编码。</p><p>C&amp;C 服务器从接收到的 GET 请求的路径中解析信息，并返回一个包含要执行的命令的类似混淆的 HTTP 响应。</p><p>对于执行下载的命令，其执行附加 PE 有效负载的方式通常使用多层间接。首先获取 AutoIt 脚本，而不是直接下载和执行 PE 有效负载。AutoIt 脚本中嵌入了一个能够加载嵌入式 PE 文件的 shellcode。shellcode 被复制到通过<code>VirtualAlloc</code>. AutoIt 功能<code>DllCallAddress</code> 然后用于将控制权转移到 shellcode，shellcode 又将控制权加载并传递给最终的 PE 有效负载。这种间接的目的大概是为了避免将 PE 有效负载放到磁盘上，这会增加检测的机会。但上述工作流程并不是专门使用的。在其他一些情况下，我们还观察到 AutoIt 脚本直接下载 PE 文件，删除其区域标识符并直接从磁盘运行它。</p><p>由于内核以 AutoHotkey 源代码或 AutoIt 字节码（易于反编译）的形式分发，因此作者试图对其进行混淆以使分析更加困难。</p><p><strong>挖矿有效载荷</strong></p><p>矿工有效载荷以 32 位 PE 文件的形式出现，并且通常与各种打包程序&#x2F;加密程序打包在一起。以解压样本<code>9c46a0e48ea9b104f982e5ed04735b0078938866e3822712b5a5374895296d08</code>为例：它解密内存中的 XMRig PE 文件，并通过进程挖空将其注入到新创建的进程中。它还动态构建一个 XMRig 配置文件，将其放到磁盘上并将其传递给新创建的进程。该恶意软件在检测到<code>taskmgr.exe</code>运行时停止挖掘，因此用户更难检测到其增加的 CPU 使用率。注入 XMRig 的进程也充当看门狗。如果注入的工作进程因任何原因终止，则看门狗进程会生成一个新的工作进程来替换它。</p><p>从我们的角度来看，这个矿工最有趣的方面是注入方法。在足够高的水平上，注入只是常规的过程空心化。然而，虽然进程空心化通常是通过调用更高级别的函数来实现的，例如<code>WriteProcessMemory</code>or <code>NtMapViewOfSection</code>，但矿工选择了一种更隐蔽的方式直接使用系统调用。这比常规的进程空心化更难实现，但它可能允许作者绕过一些安全解决方案的用户态钩子。</p><p>大多数常规的流程空心实现直接使用从<code>ntdll</code>导出的未记录函数（例如<code>NtUnmapViewOfSection</code>）来实现流程注入。但是，许多终端安全解决方案能够通过挂钩众所周知的函数来检测这种注入方法。因此，某些恶意软件（例如Formbook）会将<code>ntdll</code>的第二个副本加载到其内存中，并调用从该副本导出的函数（这也称为“拉各斯岛”方法）。这背后的想法是，新副本<code>ntdll</code> （通常直接从磁盘读取）可能不包含原始副本所包含的钩子，因此安全软件可能看不到恶意软件调用了哪些函数。</p><p>(ntdll.dll是重要的Windows NT内核级文件。描述了windows本地NTAPI的接口。当Windows启动时，ntdll.dll就驻留在内存中特定的<a href="https://baike.baidu.com/item/%E5%86%99%E4%BF%9D%E6%8A%A4">写保护</a>区域，使别的程序无法占用这个内存区域。)</p><p>该矿机使用了上述“拉各斯岛”使用新的未挂钩<code>ntdll</code>副本的方法，但它也更进了一步。与进程空心相关的函数不会通过<code>ntdll</code>. 相反，矿工解析这些函数的主体并提取它们相应的系统调用号（在 Windows 上，系统调用号可以在版本之间更改，因此它们不能简单地在示例中硬编码）。一旦恶意软件获得了必要的系统调用号，它就会直接使用<code>sysenter</code> 指令调用系统调用。</p><p>这是可能的，因为大多数使用的<code>ntdll</code>函数只是系统调用的简单包装器。这样做的结果是恶意软件不调用任何导出的函数，因此常规的用户空间钩子可能不会拦截这些“函数”的使用。</p><p>由于矿工是32位PE文件，上述方法在32位系统上运行良好。但是WOW64呢？当然，矿工不能只从 32 位代码调用 64 位系统调用。相反，它使用了所谓的<a href="http://rce.co/knockin-on-heavens-gate-dynamic-processor-mode-switching/">天堂之门</a>技术来突破WOW64仿真层。一旦恶意软件通过天堂之门并执行 64 位代码，它就可以直接调用 64 位系统调用，然后返回到 32 位代码。Heaven’s Gate 技术的使用还允许矿工从 WoW64 子系统中注入 64 位版本的 XMRig。</p><p>（WoW64子系统是一个轻量级的compatibility layer, 在所有版本的windows上都拥有同样的接口. 它的主要目的是用来创建32-bit环境, 为了让32位的应用程序可以不经过任何修改就运行在64-bit的系统上, 它提供了必须的接口.</p><p>WOW64 是在用户模式下实现的，作为 ntdll.dll 和内核之间的层。WOW64 及其支持的一些 DLL 仅仅是可以加载到 32 位进程中的 64 位的 DLL。对于所有其他情况，进程保持为纯进程。32 位的进程无法加载 64 位的 DLL，反之亦然。）</p><p>矿工本身不使用任何特殊的混淆（作者可能假设他们使用的加密器就足够了）。但是，创建 XMRig 配置文件的代码包含使用硬编码密钥使用 Vigenère 密码加密的字符串。这似乎是一项基本的努力，使重新利用矿工变得更加困难。否则，其他恶意软件作者修补接收挖矿收入的地址并将矿工用于他们自己的邪恶目的将是微不足道的。</p><h3 id="十、F-Scrack-mimikatz-–-A-bundle-of-tools：https-decoded-avast-io-ondrejmokos-f-scrack-mimikatz-a-bundle-of-tools"><a href="#十、F-Scrack-mimikatz-–-A-bundle-of-tools：https-decoded-avast-io-ondrejmokos-f-scrack-mimikatz-a-bundle-of-tools" class="headerlink" title="十、F-Scrack-mimikatz – A bundle of tools：https://decoded.avast.io/ondrejmokos/f-scrack-mimikatz-a-bundle-of-tools/"></a>十、F-Scrack-mimikatz – A bundle of tools：<a href="https://decoded.avast.io/ondrejmokos/f-scrack-mimikatz-a-bundle-of-tools/">https://decoded.avast.io/ondrejmokos/f-scrack-mimikatz-a-bundle-of-tools/</a></h3><p>最近，在分析试图绕过各种 applocking 技术的样本时，我们重新审视了旧的各种工具包，其唯一目的是为运营商赚钱。尽管该活动似乎长期不活跃，但它表明创建能够赚钱的恶意软件几乎不需要编写原始代码，所需要的只是使用公开可用的代码片段将现有工具捆绑在一起。</p><p>该链以包含两个文件的自解压存档开始 -<code>Xagent.exe</code>和<code>depszip</code>. Depszip 是一个 ZIP 存档，其中包含各种辅助文件。Xagent.exe 是使用 PyInstaller 创建的二进制文件，并设置为在解压缩 SFX 存档后自动运行。调用了原始 Python 脚本<code>F-Scrack-mimikatz.py</code>并表明该代码源自<a href="https://github.com/qianniaoge/F-Scrack">F-Scrack</a>工具。</p><p>运行Mimikatz（用于从内存中提取铭文密码、哈希、PIN码等）：存档 depszip 包含 x86 和 x64 版本<code>mimi32.exe</code>以及<code>mimi64.exe</code>.  Mimikatz 找到的凭据被上传到<code>u.swb[.]one/upload/win</code>并用于构建攻击列表。然后使用该攻击列表在本地计算机上运行脚本，使用工具<a href="https://github.com/Twi1ight/AD-Pentest-Script/blob/master/wmiexec.vbs">wmiexec.vbs</a>和称为<a href="https://attack.mitre.org/techniques/T1117">Squibldoo</a>的技术。这种技术可能允许绕过安全工具和应用程序白名单的检测，将<code>regsvr32.exe</code>其用作执行代码的“代理”。执行的代码托管在<code>xmr.enjoytopic[.]tk/d/regxmr222.sct</code>.</p><p>通过攻击列表和Squibldoo技术攻击连接到相同LAN的其他计算机（进行端口扫描）。</p><p>之后通国ThreadNum类利用永恒之蓝漏洞排队检查并攻击指定IP和端口。之后通过无身份验证或者使用默认用户名和弱密码尝试访问服务，并查找如贸易、VIP、比特币、门罗币等有用的数据库。将找到的数据库和凭证返回，删除其他数据库并创建要求赎金的条目。</p><p>通过一个VBScript，按照泄露的Vault7文档描述，使用Vmic.exe设置持久性，此外，他还通过注册表设置持久性。它创造了两个键，一个使用mshta.exe运行来自于xmr.enjoytopic[.]tk&#x2F;d&#x2F;ps3.txt的代码，一个使用 Squiblydoo运行来自xmr.enjoytopic[.]tk&#x2F;d&#x2F;regxmr999.sct的代码。</p><p>除了设置持久性之外，该脚本还在受感染的机器上下载并运行 XMRig。XMRig 二进制文件有多个版本。这些二进制文件是定制的——除了运行 XMRig，它们还创建一个计划任务，通过Squibldoo 运行在</p><ul><li><code>xmr.enjoytopic[.]tk/d/regxmr222.sct</code>,</li><li><code>down.cacheoffer[.]tk/d2/reg9.sct</code>,</li><li><code>xmr.enjoytopic[.]tk/d/regxmr999.sct</code></li></ul><p>的代码，并使用vmic.exe保持持久性。</p><p>此外，还用过一个PowerShell脚本，从png.realtimenews[.]tk&#x2F;m.png下载XMRig脚本并运行，并通过每分钟的计划任务写入和运行自身。</p><h3 id="十一、Clipsa-–-Multipurpose-password-stealer：https-decoded-avast-io-janrubin-clipsa-multipurpose-password-stealer-（内容过长，暂时放一放）"><a href="#十一、Clipsa-–-Multipurpose-password-stealer：https-decoded-avast-io-janrubin-clipsa-multipurpose-password-stealer-（内容过长，暂时放一放）" class="headerlink" title="十一、Clipsa – Multipurpose password stealer：https://decoded.avast.io/janrubin/clipsa-multipurpose-password-stealer/（内容过长，暂时放一放）"></a>十一、Clipsa – Multipurpose password stealer：<a href="https://decoded.avast.io/janrubin/clipsa-multipurpose-password-stealer/%EF%BC%88%E5%86%85%E5%AE%B9%E8%BF%87%E9%95%BF%EF%BC%8C%E6%9A%82%E6%97%B6%E6%94%BE%E4%B8%80%E6%94%BE%EF%BC%89">https://decoded.avast.io/janrubin/clipsa-multipurpose-password-stealer/（内容过长，暂时放一放）</a></h3><p>Clipsa 是一个多用途密码窃取器，用 Visual Basic 编写，专注于从不安全的 WordPress 网站窃取加密货币、暴力破解和窃取管理员凭据、替换剪贴板中的加密地址以及在受感染机器上挖掘加密货币。Clipsa 的几个版本还部署了 XMRig 硬币矿工，以从受感染的计算机中赚取更多的钱。</p><p>我们估计攻击媒介很可能是媒体播放器（<code>Ultra XVid Codec Pack.exe</code>或<code>Installer_x86-x64_89006.exe</code>）的恶意编解码器包安装程序。尝试为其媒体播放器安装这些编解码器的用户会无意中下载恶意安装程序而不是干净的安装程序。一旦用户开始安装过程，他们就会在他们的机器上部署 Clipsa，恶意软件会立即开始其恶意行为。</p><p>Clipsa 使用带有多个参数（命令行参数）的单个可执行二进制文件。这些参数区分作为单独进程同时运行的程序阶段。每个阶段专注于不同的功能，并由 Clipsa 的初始化过程开始，该过程没有任何参数。</p><p>Clipsa 将这些参数用于相位：</p><ol><li><p>无参数</p></li><li><p>–CLIPS</p></li><li><p>–CLIPSS</p></li><li><p>–WALLS</p></li><li><p>–PARSE</p></li><li><p>–BRUTE</p></li></ol><p>阶段 2-4 旨在窃取用户数据，重点关注加密钱包相关数据。第 5 阶段和第 6 阶段的重点是查找易受攻击的 WordPress 网站并窃取其管理凭据。在本分析的其余部分，我们将重点关注这些阶段中的每一个。</p><ol><li><p>无参数阶段：</p><ul><li><p>预安装</p><p>当恶意软件在受感染的机器上运行时，程序无需任何参数即可直观地启动。此阶段允许 Clipsa 在系统上安装和隐藏自身。然后它继续初始化执行恶意操作的其他阶段。</p><p>在预安装阶段，Clipsa 会创建一个消息对话框，使其看起来像是某种设置过程。但是，这个对话框（见下图）实际上只是一个伪装，所以用户认为他们下载的编解码器包正在被安装。事实是该对话框仅显示随机生成的数字（增量相加）并打印总和。Clipsa 还在增量之间添加了随机睡眠，使过程看起来很自然。</p><p><img src="https://lh5.googleusercontent.com/BniDt3p_-XAMargEsAu0knBw16faRT2Fa7dEc6E9QpNLNDq04aFJJ9_a8esJL7sxljKRxhbTbFea4KXTIw0lczlMAyKNbvAnG3BbNfQ1aUxJU1zCvUmxrdduO8kpHRPbSDf9d0MG" alt="img"></p><center>以伪装方式说明设置进度的图</center><p>在总和达到 99% 后，该过程关闭对话框。在虚构的设置过程中，恶意软件不会执行任何恶意或有用的操作。我们认为这种行为的目的是延迟实际的恶意进程，从而避免在自动沙盒工具中被检测到。</p><p>虚拟设置完成后，Clipsa 使用 Windows Management Instrumentation (WMI) 检查任务管理器是否正在运行：<br><code>Select * from Win32_Process WHERE Name = &#39;taskmgr.exe&#39;</code><br>如果正在运行，则终止程序以避免用户检测。</p></li><li><p>安装</p><p>Clipsa 然后将自身复制到<code>%APPDATA%\Roaming</code>目录中。特定文件夹和二进制文件的命名取决于 Clipsa 的版本。较新版本之一将自身复制到：<br><code>C:\Users\user\AppData\Roaming\AudioDG\condlg.exe</code></p><p><code>C:\Users\user\AppData\Roaming\AudioDG\zcondlg.exe</code></p><p>在安装过程中，还会创建其他目录和文件：<br><code>C:\Users\user\AppData\Roaming\AudioDG\log.datC:\Users\user\AppData\Roaming\AudioDG\obj\C:\Users\user\AppData\Roaming\AudioDG\udb\</code></p><p>此外，将路径<code>condlg.exe</code>添加到注册表自动运行，确保恶意软件的持久性：<br><code>HCU\Software\Microsoft\Windows\CurrentVersion\Run\11f86284</code></p><p>此外，condlg.exe还会创建一个新进程（不带参数），该进程用作释放器并启动其他恶意阶段。然而，这个过程是从隐藏文件夹 AudioDG 开始的，这正是 Clipsa 知道它已经安装在系统上的方式。</p><p>最后但同样重要的是，最初的 Clipsa 流程注定要结束。即使整个 Clipsa 安装过程成功，恶意软件也会向用户显示错误消息，让用户相信编解码器安装失败，让他们认为没有安装任何内容：</p></li><li><p>condlg.dll 文件</p><p>在安装过程中，Clipsa 会检查用户执行恶意软件的目录中是否存在其他文件。此文件通常命名为65923_VTS.vob或setup.dll. 但是，它既不是多媒体容器也不是库。该文件是由 Clipsa 解密的加密文本文件，并保存到一个新文件中：<br>C:\Users\user\AppData\Roaming\AudioDG\condlg.dll</p><p>该文件包含数千个比特币地址。正如我们稍后将看到的，此文件将用于CLIPS 阶段，在此期间，剪贴板中的加密钱包地址被替换。但是，它的存在是可选的，没有它，Clipsa 也能完全发挥作用。</p><p>请注意，原始文件的名称遵循 Clipsa 伪装成媒体播放器的编解码器包安装程序的假设。</p></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、挖矿病毒的套路-https-zhuanlan-zhihu-com-p-164557943&quot;&gt;&lt;a href=&quot;#一、挖矿病毒的套路-https-zhuanlan-zhihu-com-p-164557943&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    
    <category term="恶意软件检测" scheme="https://boneink.github.io/tags/%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8B/"/>
    
    <category term="入侵检测" scheme="https://boneink.github.io/tags/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/"/>
    
    <category term="木马检测" scheme="https://boneink.github.io/tags/%E6%9C%A8%E9%A9%AC%E6%A3%80%E6%B5%8B/"/>
    
    <category term="网络安全" scheme="https://boneink.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>java类和接口-接口与嵌套接口</title>
    <link href="https://boneink.github.io/2022/05/23/java%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%B5%8C%E5%A5%97%E6%8E%A5%E5%8F%A3/"/>
    <id>https://boneink.github.io/2022/05/23/java%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%B5%8C%E5%A5%97%E6%8E%A5%E5%8F%A3/</id>
    <published>2022-05-23T04:00:00.000Z</published>
    <updated>2022-05-23T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><strong>接口</strong>： 是java的一种抽象类型，是抽象方法的集合。接口比抽象类更加抽象的抽象类型。</p><p><strong>接口语法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] [<span class="keyword">abstract</span>] interface 接口名 [extends 父接口名列表]&#123;  </span><br><span class="line">[<span class="keyword">public</span>] [<span class="keyword">static</span>] [<span class="keyword">final</span>] 常量;  </span><br><span class="line">[<span class="keyword">public</span>] [<span class="keyword">abstract</span>] 方法;  </span><br><span class="line">[<span class="keyword">public</span>] [<span class="keyword">static</span>] 方法&#123;&#125;；<span class="comment">//JDK1.8后  </span></span><br><span class="line">[<span class="keyword">public</span>] [<span class="keyword">static</span>] 类/接口；  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口成员的修饰符"><a href="#接口成员的修饰符" class="headerlink" title="接口成员的修饰符"></a>接口成员的修饰符</h2><p>接口中的所有成员的访问权限默认强制是 <code>public</code></p><ul><li><p><strong>变量</strong>： 默认强制是<code>public static final</code></p></li><li><p><strong>方法</strong>： 默认强制是<code>public abstract</code>,即抽象方法。但JDK1.8后，允许定义静态方法<code>public static</code>,接口存在非抽象方法;</p></li><li><p><strong>内部类&#x2F;接口</strong>： 默认强制是 <code>public static</code></p></li></ul><p>下面例子中的接口中定义了各种接口成员：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceTest</span> &#123;  </span><br><span class="line">   <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//全局变量默认强制是 public static final  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;  <span class="comment">//静态方法，JDK1.8下编译通过  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">     <span class="type">int</span> <span class="title function_">abstractMethod</span><span class="params">()</span>; <span class="comment">//抽象方法  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span>&#123;<span class="comment">//抽象内部类，默认强制 public static  </span></span><br><span class="line">        <span class="comment">//......  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">MyEnum</span>&#123;RED,BLUE,GRREN&#125; <span class="comment">//枚举类，默认强制 public static  </span></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">InnerInteerface</span>&#123; <span class="comment">//嵌套接口，默认强制 public static  </span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">aa</span><span class="params">()</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">InterfaceTest</span>&#123;<span class="comment">//实现上面的接口  </span></span><br><span class="line">   <span class="meta">@Override</span>  </span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">abstractMethod</span><span class="params">()</span> &#123;<span class="comment">//实现抽象方法  </span></span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意一下，实现接口并不需要实现接口里面的内部抽象类成员、或者嵌套接口成员。</p><h2 id="接口的多继承"><a href="#接口的多继承" class="headerlink" title="接口的多继承"></a>接口的多继承</h2><p>接口是可以继承多个接口（在类中，是不允许多继承的）。由于接口的实例成员方法都是抽象方法，所以多继承不会对接口造成太大影响（<strong>不同父接口可以定义相同的方法</strong>），但还是有一点要注意的，<strong>多继承接口时，从父接口继承下来的方法，有相同的方法名，但不满足方法重载的条件，就会冲突。</strong>如果出现这种情况，编译将失败，不允许多继承。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;  </span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">sameMethodA</span><span class="params">()</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">B</span>&#123;  </span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">sameMethodA</span><span class="params">()</span>;  </span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">sameMethodB</span><span class="params">(<span class="type">int</span> a)</span>;<span class="comment">//返回类型是void  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">C</span>&#123;  </span><br><span class="line">   <span class="type">int</span> <span class="title function_">sameMethodB</span><span class="params">(<span class="type">int</span> a)</span>;<span class="comment">//返回类型是 int  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">A</span>,B&#123; <span class="comment">//编译通过，即使A，B定义了相同方法  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">E</span> <span class="keyword">extends</span> <span class="title class_">B</span>,C&#123;<span class="comment">//编译失败  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字接口D多继承父接口A，B成功，但子接口E却多继承父接口B，C失败，就是因为两个接口定义的<code>sameMethodB()</code>除了返回类型外，方法名、参数列表都一样，这不满足方法重载，导致继承时方法冲突。<br>如果非得要多继承，Java的解决方案是使用 内部类或嵌套接口；</p><h2 id="接口与抽象类的区别"><a href="#接口与抽象类的区别" class="headerlink" title="接口与抽象类的区别"></a>接口与抽象类的区别</h2><p><strong>接口与抽象类的区别：</strong></p><ul><li><strong>抽象级别不一样</strong>： 接口更加抽象，JDK1.8前只允许抽象方法，JDK1，8后才允许存在静态方法；抽象类的抽象基本低，允许存在具体方法，甚至抽象类中可以没有抽象方法。但有抽象方法的类就必须是抽象类；</li><li>接口对成员的定义时的修饰符都有固定的限制，参考前面；抽象类定义成员与普通类是一样的； </li><li>接口中不允许定义初始化块（静态或实例），但抽象类允许定义这两种初始化块；</li><li>接口中不能定义构造方法，但抽象类允许定义构造方法。<br>补充：抽象类中的抽象方法的访问权限不能是<code>private</code>。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;接口&quot;&gt;&lt;a href=&quot;#接口&quot; class=&quot;headerlink&quot; title=&quot;接口&quot;&gt;&lt;/a&gt;接口&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;接口&lt;/strong&gt;： 是java的一种抽象类型，是抽象方法的集合。接口比抽象类更加抽象的抽象类型。&lt;/p&gt;
&lt;p&gt;&lt;st</summary>
      
    
    
    
    
    <category term="java" scheme="https://boneink.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java类和接口-四种内部类</title>
    <link href="https://boneink.github.io/2022/05/22/java%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3-%E5%9B%9B%E7%A7%8D%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>https://boneink.github.io/2022/05/22/java%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3-%E5%9B%9B%E7%A7%8D%E5%86%85%E9%83%A8%E7%B1%BB/</id>
    <published>2022-05-22T04:00:00.000Z</published>
    <updated>2022-05-22T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四种内部类"><a href="#四种内部类" class="headerlink" title="四种内部类"></a>四种内部类</h1><p>内部类，嵌套在另一个类的里面，所以也称为 嵌套类;</p><p><strong>内部类分为以下四种：</strong></p><ul><li>静态内部类</li><li>成员内部类</li><li>局部内部类</li><li>匿名内部类</li></ul><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类： 一般也称”静态嵌套类“，在类中用static声明的内部类。</p><p>因为是static，所以不依赖于外围类对象实例而独立存在，<strong>静态内部类的可以访问外围类中的所有静态成员，包括private的静态成员。</strong></p><p>同时静态内部类可以说是所有内部类中独立性最高的内部类，其创建对象、继承（实现接口）、扩展子类等使用方式与外围类并没有多大的区别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;<span class="comment">//外围类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> aa; <span class="comment">//实例成员</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">1.5f</span>;<span class="comment">//private的静态成员</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClass</span>&#123;<span class="comment">//protected的静态内部类</span></span><br><span class="line">        <span class="type">float</span> a;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">StaticInnerClass</span><span class="params">()</span> &#123;</span><br><span class="line">             a = f;<span class="comment">// 外围类的private静态变量</span></span><br><span class="line">             println();<span class="comment">//外围类的静态方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OtherClass</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">//创建静态内部类的对象</span></span><br><span class="line">    OuterClass.<span class="type">StaticInnerClass</span> <span class="variable">staticInnerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>.StaticInnerClass(); </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p><strong>成员内部类</strong>： 定义在类的内部，而且与成员方法、成员变量同级，即也是外围类的成员之一，因此 成员内部类 与 外围类 是紧密关联的。</p><p>成员内部类的对象的创建必须依赖于外围类的对象（即没有外围类对象，就不可能创建成员内部类）。因此，成员内部类有以下3个特点：</p><ul><li>成员内部类可以访问外围类的所有成员，包括私有成员；</li><li>成员内部类是不可以声明静态成员（包括静态变量、静态方法、静态成员类、嵌套接口）,但有个例外—可以声明 <code>static final</code>的变量， 这是因为编译器对<code>final</code>类型的特殊处理，是直接将值写入字节码；</li><li>成员内部类对象都隐式地保存了一个引用，指向创建它的外部类对象；或者说，成员内部类的入口是由外围类的对象保持着（静态内部类的入口，则直接由外围类保持着）<br><strong>成员内部类中的 this，new关键字：</strong></li><li>获取外部类对象：<code>OuterClass.this</code></li><li>明确指定使用外部类的成员（当内部类与外部类的名字冲突时）： <code>OuterClass.this</code>.成员名</li><li>创建内部类对象的new：<code>外围类对象.new</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先创建外围类对象</span></span><br><span class="line">OuterClass outer=<span class="keyword">new</span> <span class="title class_">OuterClass</span>();<span class="comment">//创建成员内部类对象</span></span><br><span class="line">OuterClass.InnerClass inner=outer.<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br></pre></td></tr></table></figure></li></ul><ol><li>创建成员内部类时，需要通过创建外围类对象，再通过该外围类对象创建内部类对象。 <strong>成员内部可以继续嵌套多层的成员内部类，但无法嵌套静态内部类；</strong> 静态内部类则都可以继续嵌套这两种内部类。</li><li>成员内部类也是可以被继承的。<strong>继承了成员内部类的子类必须要与一个外围类对象关联起来。同时，子类的构造器是必须要调用父类的构造器方法，所以也只能通过父类的外围类对象来调用父类构造器。</strong></li><li>局部内部类：在方法、构造器、初始化块中声明的类，在结构上类似于一个局部变量。因此<strong>局部内部类是不能使用访问修饰符</strong>。局部内部类的<strong>两个访问限制</strong>：</li></ol><ul><li>对于局部变量，局部内部类只能访问<code>final</code>的局部变量。不过，后期JDK（忘了是JDK几了）局部变量可不用final修饰，也可以被局部内部类访问，但你必须时刻记住此局部变量已经是final了，不能再改变。</li><li>对于类的全局成员，局部内部类定义在实例环境中（构造器、对象成员方法、实例初始化块），则可以访问外围类的所有成员；但如果内部类定义在静态环境中（静态初始化块、静态方法），则只能访问外围类的静态成员。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;  </span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">21</span>;  </span><br><span class="line">   <span class="keyword">static</span> &#123;<span class="comment">//静态域中的局部内部类  </span></span><br><span class="line">      <span class="keyword">class</span> <span class="title class_">LocalClass1</span>&#123;  </span><br><span class="line">             <span class="comment">//  int z = a; //错误，在静态的作用域中无法访问对象成员  </span></span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   &#123;<span class="comment">//实例初始化块中的局部内部类  </span></span><br><span class="line">       <span class="keyword">class</span> <span class="title class_">localClass2</span>&#123;            </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">OuterClass</span><span class="params">()</span>&#123;  </span><br><span class="line">       <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">2</span>;  </span><br><span class="line">       <span class="keyword">final</span> <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">3</span>;  </span><br><span class="line">       <span class="comment">// x = 3;//若放开此行注释，编译无法通过，因为局部变量x已经是final类型  </span></span><br><span class="line">       <span class="comment">//构造器中的局部内部类  </span></span><br><span class="line">       <span class="keyword">class</span> <span class="title class_">localClass3</span>&#123;  </span><br><span class="line">           <span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> y; <span class="comment">//可以访问final的局部变量  </span></span><br><span class="line">           <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a;<span class="comment">//可以访问类的所有成员  </span></span><br><span class="line">            <span class="comment">//访问没有用final修饰的局部变量  </span></span><br><span class="line">           <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> x;  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createRunnable</span><span class="params">()</span> &#123;  </span><br><span class="line">       <span class="keyword">final</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">4</span>;  </span><br><span class="line">       <span class="comment">//方法中的局部内部类  </span></span><br><span class="line">       <span class="keyword">class</span> <span class="title class_">LocalClass4</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;<span class="comment">//  </span></span><br><span class="line">           <span class="meta">@Override</span>  </span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">               System.out.println(<span class="string">&quot;局部final变量：&quot;</span>+x);  </span><br><span class="line">               System.out.println(<span class="string">&quot;对象成员变量：&quot;</span>+a);  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li>匿名内部类:与局部内部类很相似，只不过匿名内部类是一个没有给定名字的内部类，在创建这个匿名内部类后，便会立即用来创建并返回此内部类的一个对象引用。<br><strong>匿名内部类的访问限制</strong>： 与局部内部类一样，请参考局部内部类；<br><strong>匿名内部类的优缺点：</strong><br><strong>优点：</strong> 编码方便快捷；<br><strong>缺点：</strong></li></ol><ul><li>只能继承一个类或实现一个接口，不能再继承其他类或其他接口。</li><li>只能用于创建一次对象实例；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyOuterClass</span> &#123;  </span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;  </span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">createThread</span><span class="params">()</span> &#123;  </span><br><span class="line">       <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;  </span><br><span class="line">       <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">189</span>;  </span><br><span class="line">       <span class="comment">// 匿名内部类继承Thread类，并重写Run方法  </span></span><br><span class="line">       <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;thread-1&quot;</span>) &#123;  </span><br><span class="line">           <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> x;  <span class="comment">//访问成员变量  </span></span><br><span class="line">           <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> a;  <span class="comment">//final的局部变量  </span></span><br><span class="line">           <span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> b; <span class="comment">//访问没有用final修饰的局部变量  </span></span><br><span class="line">           <span class="meta">@Override</span>  </span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">               System.out.println(<span class="string">&quot;这是线程thread-1&quot;</span>);  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;;  </span><br><span class="line">       <span class="comment">// 匿名内部类实现Runnable接口  </span></span><br><span class="line">       <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;  </span><br><span class="line">           <span class="meta">@Override</span>  </span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">               System.out.println(<span class="string">&quot;线程运行中&quot;</span>);  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>类 型</th><th>访问修饰符</th><th>声明静态成员</th><th>绑定外围类</th></tr></thead><tbody><tr><td>静态内部类</td><td>四种访问修饰符</td><td>可以声明</td><td>不绑定</td></tr><tr><td>成员内部类</td><td>四种访问修饰符</td><td>除 final static 的变量外，其余静态成员都不行</td><td>绑定</td></tr><tr><td>局部内部类</td><td>不可以声明</td><td>不可以声明</td><td>取决于此内部类的声明环境</td></tr><tr><td>匿名内部类</td><td>不可以声明</td><td>不可以声明</td><td>取决于此内部类的声明环境</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;四种内部类&quot;&gt;&lt;a href=&quot;#四种内部类&quot; class=&quot;headerlink&quot; title=&quot;四种内部类&quot;&gt;&lt;/a&gt;四种内部类&lt;/h1&gt;&lt;p&gt;内部类，嵌套在另一个类的里面，所以也称为 嵌套类;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内部类分为以下四种：&lt;/stron</summary>
      
    
    
    
    
    <category term="java" scheme="https://boneink.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java-枚举类型</title>
    <link href="https://boneink.github.io/2022/05/21/java-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://boneink.github.io/2022/05/21/java-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/</id>
    <published>2022-05-21T04:00:00.000Z</published>
    <updated>2022-05-21T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h1><h3 id="枚举成员"><a href="#枚举成员" class="headerlink" title="枚举成员"></a>枚举成员</h3><p>枚举成员 就是枚举类中，没有任何类型修饰，只有变量名，也不能赋值的成员。<br>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//枚举类型  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">FavouriteColor</span> &#123;  </span><br><span class="line">   <span class="comment">//枚举成员  </span></span><br><span class="line">   RED,GREEN,BLACK,BLUE,WHITE,BROWN  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>反编译之后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FavouriteColor</span> <span class="keyword">extends</span> <span class="title class_">Enum</span> &#123;  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> FavouriteColor RED;  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> FavouriteColor GREEN;  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> FavouriteColor BLACK;  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> FavouriteColor BLUE;  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> FavouriteColor WHITE;  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> FavouriteColor BROWN;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 从反编译的结果可以看出，枚举成员都被处理成 <code>public static final</code> 的静态枚举常量。即上面例子的枚举成员都是 枚举类<code>FavouriteColor</code> 的实例。</p><h3 id="添加方法、构造器、非枚举成员"><a href="#添加方法、构造器、非枚举成员" class="headerlink" title="添加方法、构造器、非枚举成员"></a>添加方法、构造器、非枚举成员</h3><p>枚举类型与普通类型的区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 枚举成员必须是最先声明，且只能用一行声明（相互间以逗号隔开，分号结束声明）。</span><br><span class="line">    </span><br><span class="line">- 构造器的访问权限只能是<span class="keyword">private</span>（可以不写，默认强制是<span class="keyword">private</span>），不能是<span class="keyword">public</span>、<span class="keyword">protected</span>。</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">FavouriteColor</span> &#123;  </span><br><span class="line">  <span class="comment">//枚举成员  </span></span><br><span class="line">   RED, GREEN(<span class="number">2</span>), BLACK(<span class="number">3</span>), BLUE, WHITE, BROWN;<span class="comment">// 必须要有分号  </span></span><br><span class="line">   <span class="comment">// 非枚举类型的成员  </span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> colorValue;  </span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> aa;  </span><br><span class="line">   <span class="comment">// 静态常量也可以  </span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">cc</span> <span class="operator">=</span> <span class="number">2</span>;  </span><br><span class="line">   <span class="comment">//无参构造器  </span></span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">FavouriteColor</span><span class="params">()</span> &#123;  </span><br><span class="line">   &#125;  </span><br><span class="line">      <span class="comment">//有参构造器  </span></span><br><span class="line">   FavouriteColor(<span class="type">int</span> colorValue) &#123;  </span><br><span class="line">        <span class="built_in">this</span>.colorValue = colorValue;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">//方法  </span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;  </span><br><span class="line">       System.out.println(cc);  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举成员其实就是枚举类型的实例，所以，<code>GREEN(2)</code>, <code>BLACK(3)</code> 就是指明了用带参构造器，并传入参数，即可以理解成 <code>FavouriteColor GREEN = new FavouriteColor(2)</code>。其他几个枚举类型则表示使用无参构造器来创建对象。( 事实上，编译器会重新创建每个构造器，为每个构造器多加两个参数)。</p><h3 id="包含抽象方法的枚举类型"><a href="#包含抽象方法的枚举类型" class="headerlink" title="包含抽象方法的枚举类型"></a>包含抽象方法的枚举类型</h3><p>以一个包含抽象方法的枚举类的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Frutit</span> &#123;  </span><br><span class="line">   APPLE &#123;  </span><br><span class="line">       <span class="meta">@Override</span>  </span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printFruitInfo</span><span class="params">()</span> &#123;  </span><br><span class="line">          System.out.println(<span class="string">&quot;This is apple&quot;</span>);  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;,BANANA &#123;  </span><br><span class="line">       <span class="meta">@Override</span>  </span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printFruitInfo</span><span class="params">()</span> &#123;  </span><br><span class="line">           System.out.println(<span class="string">&quot;This is apple&quot;</span>);  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;,WATERMELON &#123;  </span><br><span class="line">       <span class="meta">@Override</span>  </span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printFruitInfo</span><span class="params">()</span> &#123;  </span><br><span class="line">           System.out.println(<span class="string">&quot;This is apple&quot;</span>);  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;;  </span><br><span class="line">   <span class="comment">//抽象方法  </span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">printFruitInfo</span><span class="params">()</span>;  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arg)</span> &#123;  </span><br><span class="line">       Frutit.APPLE.printFruitInfo();  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>This is apple</p></blockquote><p>对于上面的枚举成员的形式也很容易理解，因为枚举成员是一个枚举类型的实例，上面的这种形式就是一种匿名内部类的形式，即每个枚举成员的创建可以理解成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   BANANA = <span class="keyword">new</span> <span class="title class_">Frutit</span>(<span class="string">&quot;BANANA&quot;</span>, <span class="number">1</span>) &#123;<span class="comment">//此构造器是编译器生成的，下面会说  </span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printFruitInfo</span><span class="params">()</span> &#123;<span class="comment">//匿名内部类的抽象方法实现。  </span></span><br><span class="line">           System.out.println(<span class="string">&quot;This is apple&quot;</span>);  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure><p>上面的例子中，创建了三个匿名内部类，同时也会多创建三个class文件.</p><p>最后，我们反编译一下fruit类，看fruit类的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Frutit</span> <span class="keyword">extends</span> <span class="title class_">Enum</span></span><br></pre></td></tr></table></figure><p>Fruit类被处理成抽象类，所以可以说，枚举类型经过编译器的处理，含抽象方法的将被处理成抽象类，否则处理成final类。</p><h3 id="枚举类型的父类-–-Enum"><a href="#枚举类型的父类-–-Enum" class="headerlink" title="枚举类型的父类 – Enum"></a>枚举类型的父类 – Enum</h3><p>Enum的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Enum</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt;  </span><br><span class="line">       <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;E&gt;, Serializable &#123;  </span><br><span class="line"><span class="comment">//枚举成员的名称  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String name;  </span><br><span class="line"><span class="comment">//枚举成员的顺序，是按照定义的顺序，从0开始  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> ordinal;  </span><br><span class="line"><span class="comment">//构造方法  </span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">Enum</span><span class="params">(String name, <span class="type">int</span> ordinal)</span> &#123;  </span><br><span class="line">       <span class="built_in">this</span>.name = name;  </span><br><span class="line">       <span class="built_in">this</span>.ordinal = ordinal;  </span><br><span class="line">   &#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">ordinal</span><span class="params">()</span> &#123;<span class="comment">//返回枚举常量的序数  </span></span><br><span class="line">       <span class="keyword">return</span> ordinal;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">name</span><span class="params">()</span> &#123;<span class="comment">//返回此枚举常量的名称，在其枚举声明中对其进行声明。  </span></span><br><span class="line">       <span class="keyword">return</span> name;  </span><br><span class="line">   &#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object other)</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">this</span>==other;<span class="comment">//比较地址  </span></span><br><span class="line">   &#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">super</span>.hashCode();  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(E o)</span> &#123;<span class="comment">//返回枚举常量的序数  </span></span><br><span class="line">   <span class="comment">//是按照次序 ordinal来比较的  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;T&gt;&gt; T <span class="title function_">valueOf</span><span class="params">(Class&lt;T&gt; enumType,  String name)</span> &#123; &#125;  </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> name;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Enum类实现了 Serializable 接口</strong>，也就是说可以枚举类型可以进行序列化。</li><li><strong>Enum的几乎所有方法都是final方法</strong>，也就是说，枚举类型只能重写toString()方法，其他方法不能重写，连hashcode()、equal()等方法也不行。</li></ul><h3 id="枚举类型的原理"><a href="#枚举类型的原理" class="headerlink" title="枚举类型的原理"></a>枚举类型的原理</h3><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Fruit</span> &#123;  </span><br><span class="line">   APPLE ,BANANA ,WATERMELON ;  </span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> value;  </span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">Fruit</span><span class="params">()</span> &#123;<span class="comment">//默认构造器  </span></span><br><span class="line">      <span class="built_in">this</span>.value = <span class="number">0</span>;    </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">Fruit</span><span class="params">(<span class="type">int</span> value)</span> &#123;<span class="comment">//带参数的构造器  </span></span><br><span class="line">       <span class="built_in">this</span>.value = value;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Fruit</span> <span class="keyword">extends</span> <span class="title class_">Enum</span> &#123;  </span><br><span class="line">  <span class="comment">//3个枚举成员实例  </span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Fruit APPLE;  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Fruit BANANA;  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Fruit WATERMELON;  </span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> value;<span class="comment">//普通变量  </span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Fruit ENUM$VALUES[];<span class="comment">//存储枚举常量的枚举数组  </span></span><br><span class="line">   <span class="keyword">static</span> &#123;<span class="comment">//静态域，初始化枚举常量，枚举数组  </span></span><br><span class="line">       APPLE = <span class="keyword">new</span> <span class="title class_">Fruit</span>(<span class="string">&quot;APPLE&quot;</span>, <span class="number">0</span>);  </span><br><span class="line">       BANANA = <span class="keyword">new</span> <span class="title class_">Fruit</span>(<span class="string">&quot;BANANA&quot;</span>, <span class="number">1</span>);  </span><br><span class="line">       WATERMELON = <span class="keyword">new</span> <span class="title class_">Fruit</span>(<span class="string">&quot;WATERMELON&quot;</span>, <span class="number">2</span>);  </span><br><span class="line">       ENUM$VALUES = (<span class="keyword">new</span> <span class="title class_">Fruit</span>[]&#123;APPLE, BANANA, WATERMELON&#125;);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">Fruit</span><span class="params">(String s, <span class="type">int</span> i)</span> &#123;<span class="comment">//编译器改造了默认构造器  </span></span><br><span class="line">       <span class="built_in">super</span>(s, i);  </span><br><span class="line">       value = <span class="number">0</span>;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">Fruit</span><span class="params">(String s, <span class="type">int</span> i, <span class="type">int</span> value)</span> &#123;<span class="comment">//编译器改造了带参数的构造器  </span></span><br><span class="line">       <span class="built_in">super</span>(s, i);  </span><br><span class="line">       <span class="built_in">this</span>.value = value;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Fruit[] values() &#123;<span class="comment">//编译器添加了静态方法values()  </span></span><br><span class="line">       Fruit afruit[];  </span><br><span class="line">       <span class="type">int</span> i;  </span><br><span class="line">       Fruit afruit1[];  </span><br><span class="line">       System.arraycopy(afruit = ENUM$VALUES, <span class="number">0</span>, afruit1 = <span class="keyword">new</span> <span class="title class_">Fruit</span>[i = afruit.length], <span class="number">0</span>, i);  </span><br><span class="line">       <span class="keyword">return</span> afruit1;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title function_">valueOf</span><span class="params">(String s)</span> &#123;<span class="comment">//编译器添加了静态方法valueOf()  </span></span><br><span class="line">       <span class="keyword">return</span> (Fruit) Enum.valueOf(Test_2018_1_16 / Fruit, s);  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从反编译的结果可以看出，编译器为我们创建出来的枚举类做了很多工作：</p><ul><li>对枚举成员的处理<br>     编译器对所有的枚举成员处理成<code>public static final</code>的枚举常量，并在静态域中进行初始化。  </li><li>构造器<br>     编译器重新定义了构造器，不仅为每个构造器都增加了两个参数，还添加父类了的构造方法调用。  </li><li>添加了两个类方法<br>      编译器为枚举类添加了 <code>values()</code> 和 <code>valueOf()</code>。<code>values()</code>方法返回一个枚举类型的数组，可用于遍历枚举类型。<code>valueOf()</code>方法也是新增的，而且是重载了父类的<code>valueOf()</code>方法</li></ul><p><strong>注意了</strong>： 正因为枚举类型的真正构造器是再编译时才生成的，所以我们没法创建枚举类型的实例，以及继承扩展枚举类型（即使是被处理成abstract类）。枚举类型的实例只能由编译器来处理创建。</p><h2 id="使用接口组织枚举"><a href="#使用接口组织枚举" class="headerlink" title="使用接口组织枚举"></a>使用接口组织枚举</h2><p>前面说了，<strong>枚举类型是无法被子类继承扩展的</strong>，这就造成无法满足以下两种情况的需求：</p><ul><li><p>希望扩展原来的枚举类型中的元素；</p></li><li><p>希望使用子类对枚举类型中的元素进行分组；</p></li></ul><p>看一个例子：对食物进行分类，大类是 Food,Food下面有好几种食物类别，类别上才是具体的食物；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Food</span> &#123;  </span><br><span class="line">   <span class="keyword">enum</span> <span class="title class_">Appetizer</span> <span class="keyword">implements</span> <span class="title class_">Food</span> &#123;  </span><br><span class="line">       SALAD, SOUP, SPRING_ROLLS  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">enum</span> <span class="title class_">Coffee</span> <span class="keyword">implements</span> <span class="title class_">Food</span> &#123;  </span><br><span class="line">       BLACK_COFFEE, DECAF_COFFEE, ESPERSSO, TEA;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">enum</span> <span class="title class_">Dessert</span> <span class="keyword">implements</span> <span class="title class_">Food</span> &#123;  </span><br><span class="line">       FRUIT, GELATO, TIRAMISU;  </span><br><span class="line">   &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口Food作为一个大类，3种枚举类型做为接口的子类；Food管理着这些枚举类型。<strong>对于枚举而言，实现接口是使其子类化的唯一办法</strong>，所以嵌套在Food中的每个枚举类都实现了Food接口。从而“所有这东西都是某种类型的Food”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> Food.Coffee.ESPERSSO;<span class="comment">//ESPERSSO不仅是coffee,也属于大类Food，达到分类的效果</span></span><br></pre></td></tr></table></figure><h2 id="使用枚举来实现单例模式"><a href="#使用枚举来实现单例模式" class="headerlink" title="使用枚举来实现单例模式"></a>使用枚举来实现单例模式</h2><p>对于序列化和反序列化，因为每一个枚举类型和枚举变量在JVM中都是唯一的，即Java在序列化和反序列化枚举时做了特殊的规定，枚举的writeObject、readObject、readObjectNoData、writeReplace和readResolve等方法是被编译器禁用的，因此，<strong>对于枚举单例，是不存在实现序列化接口后调用readObject会破坏单例的问题</strong>。所以，枚举单例是单利模式的最佳实现方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span>  <span class="title class_">EnumSingletonDemo</span> &#123;  </span><br><span class="line">   SINGLETON;  </span><br><span class="line">   <span class="comment">//其他方法、成员等  </span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单例的使用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> EnumSingletonDemo.SINGLETON.otherMethod();</span><br></pre></td></tr></table></figure><h3 id="EmunSet和EnumMap"><a href="#EmunSet和EnumMap" class="headerlink" title="EmunSet和EnumMap"></a>EmunSet和EnumMap</h3><h2 id="EnumSet"><a href="#EnumSet" class="headerlink" title="EnumSet"></a>EnumSet</h2><p>EnumSet是一个抽象类，继承了<code>AbstractSet</code>类，其本质上就是一个Set<strong>。只不过，Enumset是要与枚举类型一起使用的专用 Set 实现。枚举 set 中所有键都必须来自单个枚举类型，该枚举类型在创建 set 时显式或隐式地指定</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">EnumSet</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br></pre></td></tr></table></figure><p>尽管JDK没有提供<code>EnumSet</code>的实现子类，但是<code>EnumSet</code>新增的方法都是static方法，而且这些方法都是用来创建一个EnumSet的对象。因此可以看做是一个对枚举中的元素进行操作的Set，而且性能也很高。看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">   <span class="comment">//创建对象，并指定EnumSet存储的枚举类型  </span></span><br><span class="line">   EnumSet&lt;FavouriteColor&gt; set = EnumSet.allOf(FavouriteColor.class);  </span><br><span class="line">   <span class="comment">//移除枚举元素  </span></span><br><span class="line">   set.remove(FavouriteColor.BLACK);  </span><br><span class="line">   set.remove(FavouriteColor.BLUE);  </span><br><span class="line">   <span class="keyword">for</span>(FavouriteColor color : set) &#123;<span class="comment">//遍历set  </span></span><br><span class="line">       System.out.println(color);  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><blockquote><p>RED<br>GREEN<br>WHITE<br>BROWN</p></blockquote><p>EnumSet不支持同步访问。实现线程安全的方式是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;MyEnum&gt; s = Collections.synchronizedSet(EnumSet.noneOf(MyEnum.class));</span><br></pre></td></tr></table></figure><h2 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a>EnumMap</h2><p><code>EnumMap</code>是一个类，同样也是<strong>与枚举类型键一起使用的专用 Map 实现。枚举映射中所有键都必须来自单个枚举类型，该枚举类型在创建映射时显式或隐式地指定。枚举映射在内部表示为数组。此表示形式非常紧凑且高效。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumMap</span>&lt;K <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;K&gt;, V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K, V&gt;</span><br></pre></td></tr></table></figure><p>简单使用的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">   EnumMap&lt; FavouriteColor,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">EnumMap</span>&lt;&gt;(FavouriteColor.class);  </span><br><span class="line">   map.put(FavouriteColor.BLACK,<span class="number">1</span> );  </span><br><span class="line">   map.put(FavouriteColor.BLUE, <span class="number">2</span>);  </span><br><span class="line">   map.put(FavouriteColor.BROWN, <span class="number">3</span>);  </span><br><span class="line">   System.out.println(map.get(FavouriteColor.BLACK));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，防止意外的同步操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    Map&lt;EnumKey, V&gt; m  </span><br><span class="line">        = Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">EnumMap</span>&lt;EnumKey, V&gt;(...));</span><br></pre></td></tr></table></figure><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li>枚举类型继承于Enum类，所以只能用实现接口，不能再继承其他类。</li><li>枚举类型会编译器处理成 抽象类（含抽象方法）或 final类。</li><li>枚举成员都是public static final 的枚举实例常量。枚举成员必须是最先声明,且只能声明一行（逗号隔开，分号结束）。</li><li>构造方法必须是 private，如果定义了有参的构造器，就要注意枚举成员的声明。没有定义构造方法时，编译器为枚举类自动添加的是一个带两个参数的构造方法,并不是无参构造器。</li><li>编译器会为枚举类添加 values() 和 valueOf()两个方法。</li><li>没有抽象方法的枚举类，被编译器处理成 final 类。如果是包含抽象方法的枚举类则被处理成抽象abstract类。</li><li>Enum实现了Serializable接口，并且几乎所有方法都是 final方法</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;枚举类型&quot;&gt;&lt;a href=&quot;#枚举类型&quot; class=&quot;headerlink&quot; title=&quot;枚举类型&quot;&gt;&lt;/a&gt;枚举类型&lt;/h1&gt;&lt;h3 id=&quot;枚举成员&quot;&gt;&lt;a href=&quot;#枚举成员&quot; class=&quot;headerlink&quot; title=&quot;枚举成员&quot;&gt;&lt;/a</summary>
      
    
    
    
    
    <category term="java" scheme="https://boneink.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java-数组类型</title>
    <link href="https://boneink.github.io/2022/05/20/java-%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B/"/>
    <id>https://boneink.github.io/2022/05/20/java-%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B/</id>
    <published>2022-05-20T04:00:00.000Z</published>
    <updated>2022-05-20T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在java中，数组也是一种引用类型，即是一种类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">   <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> <span class="type">int</span>[].class;  </span><br><span class="line">   <span class="type">Class</span> <span class="variable">cIn</span> <span class="operator">=</span> Integer[].class;  </span><br><span class="line">   <span class="type">Class</span> <span class="variable">ccIn</span> <span class="operator">=</span> Integer[][].class;  </span><br><span class="line">   System.out.println(c.getName());  </span><br><span class="line">   System.out.println(cIn.getName());  </span><br><span class="line">   System.out.println(ccIn.getName());  </span><br><span class="line">   <span class="type">Class</span> <span class="variable">f</span> <span class="operator">=</span> <span class="type">float</span>[].class;  </span><br><span class="line">   <span class="type">Class</span> <span class="variable">flo</span> <span class="operator">=</span> Float[].class;  </span><br><span class="line">   System.out.println(f.getName());  </span><br><span class="line">   System.out.println(flo.getName());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出的结果：</strong></p><blockquote><p>[I<br>[Ljava.lang.Integer;<br>[[Ljava.lang.Integer;<br>[F<br>[Ljava.lang.Float;</p></blockquote><p>“[ ” 表示一维数组，<strong>“[[”则表示二维数组，如此类推下去。同时，如果是引用类型，则还要“[”后面还要跟一个”L“+类的全限定名。而如果是基本类型，则只要跟对应的大写字母。</strong></p><h3 id="数组分类"><a href="#数组分类" class="headerlink" title="数组分类"></a>数组分类</h3><p><strong>数组类可以分类可以分成两类</strong>：</p><ul><li>基本类型的数组类； </li><li>引用类型的数组类；<br>这两种数组类的最大区别在于他们的祖先类不同。</li></ul><p>对于基本类型来说，<strong>基本类型数组类的父类一个，就是Object类。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">   <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];  </span><br><span class="line">   <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> a;<span class="comment">//编译通过，类型转换成功；  </span></span><br><span class="line">   <span class="comment">//打印一下数组的超类  </span></span><br><span class="line">   System.out.println(<span class="string">&quot;int[]的superClass是： &quot;</span>+<span class="type">int</span>[].class.getSuperclass());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><blockquote><p>int[]的superClass是： class java.lang.Object</p></blockquote><p><strong>对于引用类型的数组类，其所有的祖先类除了Object类外，还包括下面所说的类：</strong><br>如果A是B的祖先类，A[]也是B[]的祖先类，其他维度也如此类推，不同维度间，没有任何关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_3</span> &#123;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">   Children[] childrens = <span class="keyword">new</span> <span class="title class_">Children</span>[<span class="number">3</span>];  </span><br><span class="line">   Ancestor[] ancestors = childrens; <span class="comment">//编译通过，类型上转成功  </span></span><br><span class="line">   <span class="comment">// 判断childrens 是不是 Ancestor或者是其子类的实例，进一步证明 Children[] 是  Ancestor[]的子孙类  </span></span><br><span class="line">   System.out.println(<span class="string">&quot;childrens instanceof Ancestor[] : &quot;</span> + (childrens <span class="keyword">instanceof</span> Ancestor[]));  </span><br><span class="line">&#125;    </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ancestor</span>&#123;<span class="comment">//祖先类  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_">Ancestor</span>&#123;<span class="comment">//父类，继承于Ancestor  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Children</span> <span class="keyword">extends</span> <span class="title class_">Parent</span>&#123;<span class="comment">//子类，继承于Parent  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><blockquote><p>childrens instanceof Ancestor[] : true</p></blockquote><p>如果这时候我们调用执行下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Children[].class.getSuperclass());</span><br><span class="line">System.out.println(Children.class.getSuperclass());</span><br></pre></td></tr></table></figure><p>输出的结果却是：</p><blockquote><p>class java.lang.Object<br>class Parent</p></blockquote><p>getSuperclass()的API描述：<br>返回表示此 Class 所表示的实体（类、接口、基本类型或 void）的超类的 Class。如果此 Class 表示 Object 类、一个接口、一个基本类型或 void，则返回 null。如果此对象表示一个数组类，则返回表示该 Object 类的 Class 对象。<br>-返回：<br>   此对象所表示的类的超类。<br>因此，在第一行代码调用后的结果会是Object</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数组类型&quot;&gt;&lt;a href=&quot;#数组类型&quot; class=&quot;headerlink&quot; title=&quot;数组类型&quot;&gt;&lt;/a&gt;数组类型&lt;/h1&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h</summary>
      
    
    
    
    
    <category term="java" scheme="https://boneink.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java-可变参数列表介绍</title>
    <link href="https://boneink.github.io/2022/05/19/java-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%E4%BB%8B%E7%BB%8D/"/>
    <id>https://boneink.github.io/2022/05/19/java-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%E4%BB%8B%E7%BB%8D/</id>
    <published>2022-05-19T04:00:00.000Z</published>
    <updated>2022-05-19T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="可变参数简介"><a href="#可变参数简介" class="headerlink" title="可变参数简介"></a>可变参数简介</h2><p>可变参数是指指定类型的数量可变的一个及以上的入参变量。其核心的特点可以用一句话来表述“数量可变的同类参数”，英文单词表示为“variable number of arguments”。<br>在不确定参数的个数时，可以使用可变的参数列表。<br>每个方法最多只有一个可变参数，因为：可变参数必须是方法的最后一个参数。<br>参数传递时，如果只有一个参数且为数组，则将该参数直接传入方法，否则将参数填充进新数组中，再传进方法里。<br>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span>&#123;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">   <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;  </span><br><span class="line">   varArgMethod(<span class="number">5</span>, <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,a);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">varArgMethod</span><span class="params">(<span class="type">int</span> b,<span class="type">int</span>... arr)</span> &#123;  </span><br><span class="line">   <span class="comment">//索引遍历  </span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;  </span><br><span class="line">       System.out.println(arr[i]);  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，对于可变参数的数组，可以当作普通数组使用，查看反编译可知：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;  </span><br><span class="line">       <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;  </span><br><span class="line">       varArgMethod(<span class="number">5</span>, <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, a&#125;);<span class="comment">//参数列表被编译器处理成了一个int[]数组  </span></span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">transient</span> <span class="keyword">void</span> <span class="title function_">varArgMethod</span><span class="params">(<span class="type">int</span> b, <span class="type">int</span> arr[])</span> &#123; <span class="comment">//形参被编译器处理成数组  </span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)  </span><br><span class="line">           System.out.println(arr[i]);  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器不仅将可变参数处理成数组<code>varArgMethod(int b, int arr[])</code>，还处理了调用可变参数方法处的参数列表，把参数列表封装进一个数组<code>varArgMethod(5, new int[]&#123;7, 8, 9, 10, a&#125;)</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;可变参数简介&quot;&gt;&lt;a href=&quot;#可变参数简介&quot; class=&quot;headerlink&quot; title=&quot;可变参数简介&quot;&gt;&lt;/a&gt;可变参数简介&lt;/h2&gt;&lt;p&gt;可变参数是指指定类型的数量可变的一个及以上的入参变量。其核心的特点可以用一句话来表述“数量可变的同类参数”，</summary>
      
    
    
    
    
    <category term="java" scheme="https://boneink.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java-常量池与装拆箱机制</title>
    <link href="https://boneink.github.io/2022/05/17/java-%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%B8%8E%E8%A3%85%E6%8B%86%E7%AE%B1%E6%9C%BA%E5%88%B6/"/>
    <id>https://boneink.github.io/2022/05/17/java-%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%B8%8E%E8%A3%85%E6%8B%86%E7%AE%B1%E6%9C%BA%E5%88%B6/</id>
    <published>2022-05-17T04:00:00.000Z</published>
    <updated>2022-05-17T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>java的常量池分为以下三类：</p><ul><li><p>class文件常量池，编译阶段）</p></li><li><p>运行时常量池（又称动态常量池，运行阶段）</p></li><li><p>字符串常量池（全局的常量池）</p><p>  <strong>常量</strong> 可分为 <strong>字面常量</strong>（也称为直接常量）和 <strong>符号常量</strong>。<br>  <strong>字面常量</strong>： 是指在程序中无需预先定义就可使用的数字、字符、boolen值、字符串等。简单的说，就是确定值的本身。如 10，2L，2.3f，3.5，“hello”，’a’，true、false、null 等等。<br>  <strong>符号常量</strong>：　是指在程序中用标识符预先定义的，其值在程序中不可改变的量。如 <code>final int a = 5</code>;</p><p>  <strong>常量池</strong><br>  常量池引入的 <strong>目的</strong> 是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。这是一种 享元模式 的实现。</p></li></ul><h3 id="class文件常量池"><a href="#class文件常量池" class="headerlink" title="class文件常量池"></a>class文件常量池</h3><p>class文件常量池，也被称为 <strong>静态常量池</strong> ，它是.class文件所包含的一项信息。用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)。<br>该常量池内的信息：<br><strong>字面量</strong>： 就是上面所说的字面常量。<br><strong>符号引用</strong>： 是一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可（它与直接引用区分一下，<strong>直接引用</strong> 一般是指向方法区的本地指针，相对偏移量或是一个能间接定位到目标的句柄）。<strong>符号引用可以看作是一个虚拟地址，只有在JVM加载完类，确认了字面量的地址，才会将 符号引用 换成 直接引用</strong>。一般包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p><strong>运行时常量池</strong>，又称为 <strong>动态常量池</strong> ，是JVM在完成加载类之后将class文件中常量池载入到内存中，并保存在方法区中。也就是说，运行时常量池中的常量，基本来源于各个class文件中的常量池。 <strong>运行时常量池相对于CLass文件常量池的另外一个重要特征是具备 动态性 ，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。</strong><br>jvm在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，<strong>jvm就会将class常量池中的内容存放到运行时常量池中，也就是说，每个class对应运行时常量池中的一个独立空间，每个class文件存放的位置互不干扰</strong>。而在解析阶段，就会将符号引用替换成对应的直接引用。<br>不过，<strong>String类型</strong> 的字面常量要注意：并不是直接在堆上分配空间来创建对象的，JVM为String 字符串额外维护了一个常量池 <strong>字符串常量池</strong>，所以遇到字符串常量是要先去字符串池中寻找是否有重复，如果有，则返回对应的引用。否则，才创建并添加到字符串常量池中。换句话说，<strong>对于String类型的字面常量，必须要在 字符串常量池 中维护一个全局的引用。</strong></p><h3 id="字符串常量池（string-pool也有叫做string-literal-pool）"><a href="#字符串常量池（string-pool也有叫做string-literal-pool）" class="headerlink" title="字符串常量池（string pool也有叫做string literal pool）"></a>字符串常量池（string pool也有叫做string literal pool）</h3><p>字符串常量池存储的就是字符串的字面常量。详细一点，字符串常量池里的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中。<br>对于运行时常量池和字符串常量池，jdk1.6之前，二者都放在方法区，jdk1.7将字符串常量池移到了堆外内存。运行时常量池为每个class文件的常量池提供一个运行时的内存空间，字符串常量池为所有的class文件的String类型的字面常量维护一个公共的常量池，<strong>Class文件的常量池加载进运行时常量池后，其String字面常量的引用指向要与字符串常量池的维护的要一致</strong>。</p><h2 id="自动装箱拆箱机制-与-缓存机制"><a href="#自动装箱拆箱机制-与-缓存机制" class="headerlink" title="自动装箱拆箱机制 与 缓存机制"></a>自动装箱拆箱机制 与 缓存机制</h2><h3 id="自动装拆箱机制介绍"><a href="#自动装拆箱机制介绍" class="headerlink" title="自动装拆箱机制介绍"></a>自动装拆箱机制介绍</h3><p><strong>装箱</strong>： 可以自动将基本类型直接转换成对应的包装类型。<br><strong>拆箱</strong>： 自动将包装类型转换成对应的基本类型值；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//普通的创建对象方式  </span></span><br><span class="line">   <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">5</span>);  </span><br><span class="line">   <span class="comment">//装箱  </span></span><br><span class="line">   <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">5</span>;  </span><br><span class="line">   <span class="comment">//拆箱  </span></span><br><span class="line">   <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> b+<span class="number">5</span>;</span><br></pre></td></tr></table></figure><pre><code>Java中基本数据类型和包装类型的区别1、包装类是对象，拥有方法和字段，对象的调用都是通过引用对象的地址；基本类型不是   2、包装类型是引用的传递；基本类型是值的传递   3、声明方式不同：                  基本数据类型不需要 new 关键字；                  包装类型需要 new 在堆内存中进行 new 来分配内存空间   4、存储位置不同：                基本数据类型直接将值保存在值栈中；                  包装类型是把对象放在堆中，然后通过对象的引用来调用他们   5、初始值不同：                int 的初始值为 0 、 boolean 的初始值为 false                   包装类型的初始值为 null   6、使用方式不同：                基本数据类型直接赋值使用就好；                  包装类型是在集合如 coolectionMap 时使用</code></pre><h3 id="自动装箱拆箱的原理"><a href="#自动装箱拆箱的原理" class="headerlink" title="自动装箱拆箱的原理"></a>自动装箱拆箱的原理</h3><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_6</span> &#123;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">   <span class="comment">//装箱  </span></span><br><span class="line">   <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">5</span>;  </span><br><span class="line">   <span class="comment">//拆箱  </span></span><br><span class="line">   <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> b+<span class="number">5</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_6</span>  </span><br><span class="line">&#123;  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>   &#123;  </span><br><span class="line">       <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> Integer.valueOf(<span class="number">5</span>);  </span><br><span class="line">       <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> b.intValue() + <span class="number">5</span>;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质上，自动装箱和拆箱，是自动调用了<code>Integer.valueOf()</code>（装箱） 和 <code>Integer.initValue()</code>（拆箱）来完成的。</p><h3 id="包装类的缓存机制"><a href="#包装类的缓存机制" class="headerlink" title="包装类的缓存机制"></a>包装类的缓存机制</h3><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">       <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;  </span><br><span class="line">       <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">5</span>;  </span><br><span class="line">       <span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">129</span>;  </span><br><span class="line">       <span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">129</span>;  </span><br><span class="line">       System.out.println(<span class="string">&quot;a==b &quot;</span>+ (a == b));  </span><br><span class="line">       System.out.println(<span class="string">&quot;c==d &quot;</span>+ (c == d));  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果：<br>    a &#x3D;&#x3D; b  true<br>    c &#x3D;&#x3D; d  false<br>变量a、b、c、d是由装箱得到的，而装箱则是编译器自动添加了Integer.valueOf()方法，而其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;  </span><br><span class="line">       <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)  </span><br><span class="line">           <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];  </span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>代码很简单，判断装箱所使用的基本类型值是否在 [ IntegerCache.low, IntegerCache.high] 的范围内，如果在，返回IntegerCache.cache数组中对应下标的元素。否则，才新建一个对象。<br>IntegerCache的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;  </span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;  </span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;  </span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];  </span><br><span class="line">       <span class="keyword">static</span> &#123;  </span><br><span class="line">           <span class="comment">// high value may be configured by property  </span></span><br><span class="line">           <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;  </span><br><span class="line">           <span class="type">String</span> <span class="variable">integerCacheHighPropValue</span> <span class="operator">=</span>  </span><br><span class="line">               sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);  </span><br><span class="line">           <span class="comment">//获取上限值  </span></span><br><span class="line">           <span class="keyword">if</span> (integerCacheHighPropValue != <span class="literal">null</span>) &#123;  </span><br><span class="line">               <span class="keyword">try</span> &#123;  </span><br><span class="line">                   <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> parseInt(integerCacheHighPropValue);  </span><br><span class="line">                   i = Math.max(i, <span class="number">127</span>);  </span><br><span class="line">                   <span class="comment">// Maximum array size is Integer.MAX_VALUE  </span></span><br><span class="line">                   h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);  </span><br><span class="line">               &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;  </span><br><span class="line">                   <span class="comment">// If the property cannot be parsed into an int, ignore it.  </span></span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">           high = h;  </span><br><span class="line">           <span class="comment">//创建数组  </span></span><br><span class="line">           cache = <span class="keyword">new</span> <span class="title class_">Integer</span>[(high - low) + <span class="number">1</span>];  </span><br><span class="line">           <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low;  </span><br><span class="line">           <span class="comment">//填充数组  </span></span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; cache.length; k++)  </span><br><span class="line">               cache[k] = <span class="keyword">new</span> <span class="title class_">Integer</span>(j++);  </span><br><span class="line">           <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)  </span></span><br><span class="line">           <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">private</span> <span class="title function_">IntegerCache</span><span class="params">()</span> &#123;&#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>从源码中，可以知道，<code>IntegerCache.cache</code>是一个final的Integer数组，这个数组存储的Integer对象元素的值范围是[-128，127]。而且这个数组的初始化代码是包裹在static代码块中，也就是说<code>IntegerCache.cache</code>  <strong>数组的初始化是在类加载时完成的。</strong></p><p>变量a和b的使用的基本类型值为5，未超出[-128,127]的范围，所以就使用缓存数组中的元素，所以a、b的地址是一样的。而c、d使用的基本类型值为129，超出缓存范围，所以都是各自在堆上创建一个对，地址自然就不一样了。</p><h2 id="总结和补充："><a href="#总结和补充：" class="headerlink" title="总结和补充："></a>总结和补充：</h2><ul><li>包装类与String类很相似，都是非可变类，即一经创建后，便不可以修改。正因为这种特性，两者的对象实例在多线程下是安全的，不用担心异步修改的情况，这为他们实现共享提供了很好的保证，只需创建一个对象共享便可。</li><li>包装类的共享实现并不是由JVM来维护一个常量池，而是使用了缓存机制（数组），而且这个缓存是在类加载时完成初始化，并且不可再修改。</li><li>包装类的数组缓存范围是有限，只缓存基本类型值在一个字节范围内，也就是说 -128 ~ 127。（Character的范围是 0~127）</li><li>目前并不是所有包装类都提供缓存机制，只有Byte、Character、Short、Integer 4个包装类提供，Long、Float、Double 不提供。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;常量池&quot;&gt;&lt;a href=&quot;#常量池&quot; class=&quot;headerlink&quot; title=&quot;常量池&quot;&gt;&lt;/a&gt;常量池&lt;/h2&gt;&lt;p&gt;java的常量池分为以下三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;class文件常量池，编译阶段）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;</summary>
      
    
    
    
    
    <category term="java" scheme="https://boneink.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java-java四种访问权限</title>
    <link href="https://boneink.github.io/2022/05/16/java-java%E5%9B%9B%E7%A7%8D%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/"/>
    <id>https://boneink.github.io/2022/05/16/java-java%E5%9B%9B%E7%A7%8D%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/</id>
    <published>2022-05-16T04:00:00.000Z</published>
    <updated>2022-05-16T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java四种访问权限"><a href="#java四种访问权限" class="headerlink" title="java四种访问权限"></a>java四种访问权限</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>访问权限控制</strong>： 指的是本类及本类内部的成员（成员变量、成员方法、内部类）对其他类的可见性，即这些内容是否允许其他类访问。</p><p>Java 中一共有四种访问权限控制，其权限控制的大小情况是这样的：<strong>public &gt; protected &gt; default(包访问权限) &gt; private</strong> ,具体的权限控制看下面表格，列所指定的类是否有权限允许访问行的权限控制下的内容：</p><table><thead><tr><th>访问权限</th><th>本类</th><th>本包的类</th><th>子类</th><th>非子类的外包类</th></tr></thead><tbody><tr><td>public</td><td>是</td><td>是</td><td>是</td><td>是</td></tr><tr><td>protected</td><td>是</td><td>是</td><td>是</td><td>否</td></tr><tr><td>default</td><td>是</td><td>是</td><td>否</td><td>否</td></tr><tr><td>private</td><td>是</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><p><strong>1、public：</strong> 所修饰的类、变量、方法，在内外包均具有访问权限；<br><strong>2、protected：</strong> 这种权限是为继承而设计的，protected所修饰的成员，对所有子类是可访问的，但只对同包的类是可访问的，对外包的非子类是不可以访问；<br><strong>3、包访问权限（default）：</strong> 只对同包的类具有访问的权限，外包的所有类都不能访问；<br><strong>4、private：</strong> 私有的权限，只对本类的方法可以使用；</p><p><strong>注意： 要区分开 protected 权限、包访问权限，正确使用它们；</strong></p><ul><li>当某个成员能被所有的子类继承，但不能被外包的非子类访问，就是用protected；</li><li>当某个成员的访问权限只对同包的类开放，包括不能让外包的类继承这个成员，就用包访问权限；<br><strong>使用访问权限控制的原因：</strong><br>1）使用户不要碰触那些他们不该碰触的部分；<br>2）类库设计者可以更改类的内部工作的方式，而不会担心这样会对用户产生重大影响；<br>即分割用户操作和类内部工作区域，减少彼此影响。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;java四种访问权限&quot;&gt;&lt;a href=&quot;#java四种访问权限&quot; class=&quot;headerlink&quot; title=&quot;java四种访问权限&quot;&gt;&lt;/a&gt;java四种访问权限&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="java" scheme="https://boneink.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java-switch语句</title>
    <link href="https://boneink.github.io/2022/05/15/java-switch%E8%AF%AD%E5%8F%A5/"/>
    <id>https://boneink.github.io/2022/05/15/java-switch%E8%AF%AD%E5%8F%A5/</id>
    <published>2022-05-15T04:00:00.000Z</published>
    <updated>2022-05-15T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><h3 id="switch-语法格式："><a href="#switch-语法格式：" class="headerlink" title="switch 语法格式："></a>switch 语法格式：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式) &#123;  </span><br><span class="line">       <span class="keyword">case</span> 常量表达式或枚举常量:  </span><br><span class="line">           语句;  </span><br><span class="line">           <span class="keyword">break</span>;  </span><br><span class="line">       <span class="keyword">case</span> 常量表达式或枚举常量 :  </span><br><span class="line">           语句;  </span><br><span class="line">           <span class="keyword">break</span>;  </span><br><span class="line">       ......  </span><br><span class="line">       <span class="keyword">default</span>: 语句;  </span><br><span class="line">           <span class="keyword">break</span>;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>switch 匹配的表达式可以是：</strong></p><ul><li>byte、short、char、int类型及 这4种类型的包装类型；</li><li>枚举类型； </li><li>String 类型；</li></ul><p><strong>case 匹配的表达式可以是：</strong></p><ul><li>常量表达式；</li><li>枚举常量；</li></ul><p><strong>注意一点：</strong> case提供了switch表达式的入口地址，一旦switch表达式与某个case分支匹配，则从该分支的语句开始执行，一直执行下去，即其后的所有case分支的语句也会被执行，直到遇到break语句。</p><h3 id="编译器对-switch-表达式的各种类型的处理："><a href="#编译器对-switch-表达式的各种类型的处理：" class="headerlink" title="编译器对 switch 表达式的各种类型的处理："></a>编译器对 switch 表达式的各种类型的处理：</h3><p><strong>在底层中，swtich 只能支持4种基本类型，其他几个类型是通过一些方式来间接处理的</strong>。</p><ol><li>包装类：<br>通过拆箱，获得其对应的数值：<br>如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">       <span class="type">Byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;  </span><br><span class="line">       <span class="keyword">switch</span> (b) &#123;  </span><br><span class="line">       <span class="keyword">case</span> <span class="number">1</span>:  </span><br><span class="line">           System.out.println(<span class="string">&quot;匹配成功&quot;</span>);  </span><br><span class="line">           <span class="keyword">break</span>;  </span><br><span class="line">       <span class="keyword">case</span> <span class="number">2</span>:  </span><br><span class="line">           System.out.println(<span class="string">&quot;匹配成功&quot;</span>);  </span><br><span class="line">           <span class="keyword">break</span>;  </span><br><span class="line">       &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>对应的反编译：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">      <span class="type">Byte</span> <span class="variable">b</span> <span class="operator">=</span> Byte.valueOf((<span class="type">byte</span>)<span class="number">2</span>);  </span><br><span class="line">       <span class="keyword">switch</span>(b.byteValue())  </span><br><span class="line">       &#123;  </span><br><span class="line">       <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// &#x27;\001&#x27;  </span></span><br><span class="line">           System.out.println(<span class="string">&quot;\u5339\u914D\u6210\u529F&quot;</span>);  </span><br><span class="line">           <span class="keyword">break</span>;  </span><br><span class="line">       <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// &#x27;\002&#x27;  </span></span><br><span class="line">           System.out.println(<span class="string">&quot;\u5339\u914D\u6210\u529F&quot;</span>);  </span><br><span class="line">           <span class="keyword">break</span>;  </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li><li>枚举类型：<br>以JDK提供的枚举类型的线程状态类 <code>Thread.state</code> 类为例：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   Thread.<span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> Thread.State.RUNNABLE;  </span><br><span class="line">   <span class="keyword">switch</span> (state) &#123;  </span><br><span class="line">   <span class="keyword">case</span> NEW:  </span><br><span class="line">       System.out.println(<span class="string">&quot;线程处于创建状态&quot;</span>);  </span><br><span class="line">       <span class="keyword">break</span>;  </span><br><span class="line">   <span class="keyword">case</span> RUNNABLE:  </span><br><span class="line">       System.out.println(<span class="string">&quot;线程处于可运行状态&quot;</span>);  </span><br><span class="line">       <span class="keyword">break</span>;  </span><br><span class="line">   <span class="keyword">case</span> TERMINATED:  </span><br><span class="line">       System.out.println(<span class="string">&quot;线程结束&quot;</span>);  </span><br><span class="line">       <span class="keyword">break</span>;  </span><br><span class="line">   <span class="keyword">default</span>:  </span><br><span class="line">       <span class="keyword">break</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   反编译代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Sex</span> <span class="variable">sex</span> <span class="operator">=</span> Sex.MALE;  </span><br><span class="line">       <span class="keyword">switch</span>($SWITCH_TABLE$Test_2018_1_14$Sex()[sex.ordinal()])  </span><br><span class="line">       &#123;  </span><br><span class="line">       <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// &#x27;\001&#x27;  </span></span><br><span class="line">           System.out.println(<span class="string">&quot;sex:male&quot;</span>);  </span><br><span class="line">           <span class="keyword">break</span>;  </span><br><span class="line">       <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// &#x27;\002&#x27;  </span></span><br><span class="line">           System.out.println(<span class="string">&quot;sex:female&quot;</span>);  </span><br><span class="line">           <span class="keyword">break</span>;  </span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>   从编译代码中发现，编译器对于枚举类型的处理，是通过创建一个辅助数组来处理，这个数组是通过一个<code>$SWITCH_TABLE$java$lang$Thread$State()</code> 方法创建的，数组是一个int[]类型数组，数组很简单，<strong>在每个枚举常量的序号所对应的数组下标位置的赋一个值，按序号大小赋值，从1开始递增</strong>。 其代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int 数组  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> $SWITCH_TABLE$java$lang$Thread$State[];  </span><br><span class="line"><span class="comment">//创建数组的方法  </span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span>[] $SWITCH_TABLE$java$lang$Thread$State()  </span><br><span class="line">   &#123;  </span><br><span class="line">       $SWITCH_TABLE$java$lang$Thread$State;  </span><br><span class="line">       <span class="keyword">if</span>($SWITCH_TABLE$java$lang$Thread$State == <span class="literal">null</span>) goto _L2; <span class="keyword">else</span> goto _L1  </span><br><span class="line">_L1:  </span><br><span class="line">       <span class="keyword">return</span>;  </span><br><span class="line">_L2:  </span><br><span class="line">       JVM INSTR pop ;  </span><br><span class="line">       <span class="type">int</span> ai[] = <span class="keyword">new</span> <span class="title class_">int</span>[Thread.State.values().length];  </span><br><span class="line">       <span class="keyword">try</span>  </span><br><span class="line">       &#123;  </span><br><span class="line">           ai[Thread.State.BLOCKED.ordinal()] = <span class="number">3</span>;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">catch</span>(NoSuchFieldError _ex) &#123; &#125;  </span><br><span class="line">       <span class="keyword">try</span>  </span><br><span class="line">       &#123;  </span><br><span class="line">           ai[Thread.State.NEW.ordinal()] = <span class="number">1</span>;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">catch</span>(NoSuchFieldError _ex) &#123; &#125;  </span><br><span class="line">       <span class="keyword">try</span>  </span><br><span class="line">       &#123;  </span><br><span class="line">           ai[Thread.State.RUNNABLE.ordinal()] = <span class="number">2</span>;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">catch</span>(NoSuchFieldError _ex) &#123; &#125;  </span><br><span class="line">       <span class="keyword">try</span>  </span><br><span class="line">       &#123;  </span><br><span class="line">           ai[Thread.State.TERMINATED.ordinal()] = <span class="number">6</span>;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">catch</span>(NoSuchFieldError _ex) &#123; &#125;  </span><br><span class="line">       <span class="keyword">try</span>  </span><br><span class="line">       &#123;  </span><br><span class="line">           ai[Thread.State.TIMED_WAITING.ordinal()] = <span class="number">5</span>;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">catch</span>(NoSuchFieldError _ex) &#123; &#125;  </span><br><span class="line">       <span class="keyword">try</span>  </span><br><span class="line">       &#123;  </span><br><span class="line">           ai[Thread.State.WAITING.ordinal()] = <span class="number">4</span>;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">catch</span>(NoSuchFieldError _ex) &#123; &#125;  </span><br><span class="line">       <span class="type">return</span> <span class="variable">$SWITCH_TABLE$java$lang$Thread$State</span> <span class="operator">=</span> ai;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>String类型：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">       <span class="type">String</span>  <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;China&quot;</span>;  </span><br><span class="line">       <span class="keyword">switch</span> (s) &#123;  </span><br><span class="line">       <span class="keyword">case</span> <span class="string">&quot;America&quot;</span>:  </span><br><span class="line">                System.out.println(<span class="string">&quot;匹配到美国&quot;</span>);  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">       <span class="keyword">case</span> <span class="string">&quot;China&quot;</span>:  </span><br><span class="line">               System.out.println(<span class="string">&quot;匹配到中国&quot;</span>);  </span><br><span class="line">               <span class="keyword">break</span>;  </span><br><span class="line">       <span class="keyword">case</span> <span class="string">&quot;Japan&quot;</span>:  </span><br><span class="line">                System.out.println(<span class="string">&quot;匹配到日本&quot;</span>);  </span><br><span class="line">       <span class="keyword">default</span>:  </span><br><span class="line">           <span class="keyword">break</span>;  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>反编译：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>   &#123;  </span><br><span class="line">       <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;China&quot;</span>;  </span><br><span class="line">       String s1;  </span><br><span class="line">       <span class="keyword">switch</span>((s1 = s).hashCode())  </span><br><span class="line">       &#123;  </span><br><span class="line">       <span class="keyword">default</span>:  </span><br><span class="line">           <span class="keyword">break</span>;  </span><br><span class="line">       <span class="keyword">case</span> <span class="number">65078583</span>:  </span><br><span class="line">           <span class="keyword">if</span>(s1.equals(<span class="string">&quot;China&quot;</span>))  </span><br><span class="line">               System.out.println(<span class="string">&quot;\u5339\u914D\u5230\u4E2D\u56FD&quot;</span>);  </span><br><span class="line">           <span class="keyword">break</span>;  </span><br><span class="line">       <span class="keyword">case</span> <span class="number">71341030</span>:  </span><br><span class="line">           <span class="keyword">if</span>(s1.equals(<span class="string">&quot;Japan&quot;</span>))  </span><br><span class="line">               System.out.println(<span class="string">&quot;\u5339\u914D\u5230\u65E5\u672C&quot;</span>);  </span><br><span class="line">           <span class="keyword">break</span>;  </span><br><span class="line">       <span class="keyword">case</span> <span class="number">775550446</span>:  </span><br><span class="line">           <span class="keyword">if</span>(s1.equals(<span class="string">&quot;America&quot;</span>))  </span><br><span class="line">               System.out.println(<span class="string">&quot;\u5339\u914D\u5230\u7F8E\u56FD&quot;</span>);  </span><br><span class="line">           <span class="keyword">break</span>;  </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>从反编译的代码可以看出，switch 的String变量、case 的String常量都变成对应的字符串的 hash 值。也就是说，switch仍然没有超出它的限制，只是通过<strong>使用 String对象的hash值来进行匹配比较</strong>，从而支持 String 类型。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;switch语句&quot;&gt;&lt;a href=&quot;#switch语句&quot; class=&quot;headerlink&quot; title=&quot;switch语句&quot;&gt;&lt;/a&gt;switch语句&lt;/h2&gt;&lt;h3 id=&quot;switch-语法格式：&quot;&gt;&lt;a href=&quot;#switch-语法格式：&quot; cla</summary>
      
    
    
    
    
    <category term="java" scheme="https://boneink.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java-String性质</title>
    <link href="https://boneink.github.io/2022/05/14/java-String%E6%80%A7%E8%B4%A8/"/>
    <id>https://boneink.github.io/2022/05/14/java-String%E6%80%A7%E8%B4%A8/</id>
    <published>2022-05-14T04:00:00.000Z</published>
    <updated>2022-05-14T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="String性质"><a href="#String性质" class="headerlink" title="String性质"></a>String性质</h2><h3 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h3><p>String一旦创建，就是不可变的，其通过两个方法维护其不可变性：</p><ol><li>final类 和 final的私有成员<br>String的部分源码：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span>  </span><br><span class="line">   <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;  </span><br><span class="line">   <span class="comment">/** The value is used for character storage. */</span>  </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];  </span><br><span class="line">   <span class="comment">/** Cache the hash code for the string */</span>  </span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0  </span></span><br><span class="line">   <span class="comment">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span>  </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">6849794470754667710L</span>;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p> 我们可以发现 <strong>String是一个final类，且3个成员都是私有的</strong>，这就意味着String是不能被继承的，这就防止出现：程序员通过继承重写String类的方法的手段来使得String类是“可变的”的情况。<br> 同时，尽管String是通过维护一个内部的char数组实现的，但是无法通过修改外部char数组元素的方式修改String内容：<br> 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">       <span class="type">char</span>[] arr = <span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;;        </span><br><span class="line">       <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);        </span><br><span class="line">       arr[<span class="number">3</span>]=<span class="string">&#x27;e&#x27;</span>;      </span><br><span class="line">       System.out.println(<span class="string">&quot;str= &quot;</span>+str);  </span><br><span class="line">       System.out.println(<span class="string">&quot;arr[]= &quot;</span>+Arrays.toString(arr));  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p> <strong>运行结果</strong></p><blockquote><p>str&#x3D; abcd<br>arr[]&#x3D; [a, b, c, e]</p></blockquote><p> 字符串str使用数组arr来构造一个对象，当数组arr修改其元素值后，字符串str并没有跟着改变。查看String创建对应的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">char</span> value[])</span> &#123;  </span><br><span class="line">       <span class="built_in">this</span>.value = Arrays.copyOf(value, value.length);  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p> 可以看出<strong>String在使用外部char数组构造对象时，是重新复制了一份外部char数组</strong>，从而不会让外部char数组的改变影响到String对象。<br>2. 一旦发生改变就创建新对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex, <span class="type">int</span> endIndex)</span> &#123;  </span><br><span class="line">       <span class="comment">//........  </span></span><br><span class="line">       <span class="keyword">return</span> ((beginIndex == <span class="number">0</span>) &amp;&amp; (endIndex == value.length)) ? <span class="built_in">this</span>  </span><br><span class="line">               : <span class="keyword">new</span> <span class="title class_">String</span>(value, beginIndex, subLen);  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p> 从源码可以看出，如果不是切割整个字符串的话，就会新建一个对象。也就是说，<strong>只要与原字符串不相等，就会新建一个String对象</strong>。</p><h3 id="tring的-操作-与-字符串常量池"><a href="#tring的-操作-与-字符串常量池" class="headerlink" title="tring的+操作 与 字符串常量池"></a>tring的+操作 与 字符串常量池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">       <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Love You&quot;</span>;        </span><br><span class="line">       <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;Love&quot;</span>+<span class="string">&quot; You&quot;</span>;  </span><br><span class="line">       <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s2 + <span class="string">&quot;&quot;</span>;  </span><br><span class="line">       <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Love You&quot;</span>);  </span><br><span class="line">       System.out.println(<span class="string">&quot;s == s2 &quot;</span>+(s==s2));  </span><br><span class="line">       System.out.println(<span class="string">&quot;s == s3 &quot;</span>+(s==s3));  </span><br><span class="line">       System.out.println(<span class="string">&quot;s == s4 &quot;</span>+(s==s4));  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><blockquote><p>s &#x3D;&#x3D; s2  true<br>s &#x3D;&#x3D; s3  false<br>s &#x3D;&#x3D; s4  false</p></blockquote><p>由于编译器在编译期间会对代码尽可能优化，所以常量表达式的计算会在编译期间完成。因此s2的值在编译期间已经完成，并同s一起在类加载时创建并维护在字符串常量池中，由于常量池中的每个字符串只存在一个，因此s2和s指向同一个对象，二者相等。但s3和s4的表达式中含有非常量，需要在执行时才能计算。因此不会和s相等。<br>而对于+操作，通过jad命令 jad MyTest.class反编译代码可得：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span>  </span><br><span class="line">&#123;  </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">MyTest</span><span class="params">()</span>   &#123;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>   &#123;  </span><br><span class="line">       <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Love You&quot;</span>;  </span><br><span class="line">       <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;Love You&quot;</span>;<span class="comment">//已经得到计算结果  </span></span><br><span class="line">       <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> (<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(String.valueOf(s2))).toString();  </span><br><span class="line">       <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Love You&quot;</span>);  </span><br><span class="line">       System.out.println((<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;s == s2 &quot;</span>)).append(s == s2).toString());  </span><br><span class="line">       System.out.println((<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;s == s3 &quot;</span>)).append(s == s3).toString());  </span><br><span class="line">       System.out.println((<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;s == s4 &quot;</span>)).append(s == s4).toString());  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，编译器将 + 号处理成了<code>StringBuilder.append()</code>方法。也就是说，在运行期间，链接字符串的计算都是通过 创建StringBuilder对象，调用<code>append()</code>方法来完成的，而且是每一个链接字符串的表达式都要创建一个 StringBuilder对象。因此<strong>对于循环中反复执行字符串链接时，应该考虑直接使用StringBuilder来代替 + 链接，避免重复创建StringBuilder的性能开销。</strong> </p><h4 id="String-intern-方法："><a href="#String-intern-方法：" class="headerlink" title="String.intern()方法："></a>String.intern()方法：</h4><p>该方法可以将String类型的对象转移到常量池中，但在jdk6和jdk7中，该方法实现的方式不同：</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td>JDK6</td><td>JDK7 及之后</td></tr><tr><td>intern() 方法</td><td>会把首次遇到的字符串实例复制到常量池中，并返回此引用</td><td>会把首次遇到的字符串实例的引用添加到常量池中，并返回此引用</td></tr></tbody></table><p>同时，jdk7中，如果某个字符串不再被引用，便会从常量池中回收。<br>通过两段代码理解两种实现方法的不同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>); <span class="comment">//常量池中创建&quot;1&quot;，堆中创建&quot;1&quot;</span></span><br><span class="line">s1.intern();          <span class="comment">//常量池中已有&quot;1&quot;，所以jdk6和jkd7都是返回指向常量池&quot;1&quot;的引用，</span></span><br><span class="line">                      <span class="comment">//但因为该语句没有赋值操作，所以s1仍指向堆中&quot;1&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;      <span class="comment">//s2指向常量池中已存在的&quot;1&quot;</span></span><br><span class="line">System.out.println(s1==s2);  <span class="comment">//s1指向堆中&quot;1&quot;，s2指向常量池中&quot;1&quot;，false</span></span><br></pre></td></tr></table></figure><p> jdk6、7、8 都返回 false<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>); <span class="comment">//常量池生成一个&quot;1&quot;，堆生成一个&quot;11&quot;</span></span><br><span class="line">                                               <span class="comment">//s3指向堆中&quot;11&quot;</span></span><br><span class="line">                                       <span class="comment">//中间还有2个匿名的new String(&quot;1&quot;)暂不讨论</span></span><br><span class="line">s3.intern();             <span class="comment">//因为常量池中不存在&quot;11&quot;，</span></span><br><span class="line">                         <span class="comment">//jdk6会将堆中&quot;11&quot;复制到常量池中，</span></span><br><span class="line">                         <span class="comment">//jdk7则将堆中&quot;11&quot;的引用添加到常量池中，</span></span><br><span class="line">                         <span class="comment">//此时s3仍指向堆中&quot;11&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;        <span class="comment">//因为常量池中已存在&quot;11&quot;或其引用，s4指向常量池中&quot;11&quot;</span></span><br><span class="line">System.out.println(s3==s4);  <span class="comment">//jdk6中，s4指向常量池中&quot;11&quot;，s3指向堆中&quot;11&quot;，false</span></span><br><span class="line">                             <span class="comment">//jdk7中，s4指向常量池中指向堆中&quot;11&quot;的引用，true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p> 在 jdk6 中返回 false，jdk7 及以上返回 true<br> intern() 方法优点：执行速度非常快，直接使用 &#x3D;&#x3D; 进行比较要比使用 equals() 方法快很多；内存占用少。虽然 intern() 方法的优点看上去很诱人，但由于 intern() 操作每次都需要与常量池中的数据进行比较以查看常量池中是否存在等值数据，同时 JVM 需要确保常量池中的数据的唯一性，这就涉及到加锁机制，这些操作都是有需要占用 CPU 时间的，所以如果进行 intern 操作的是大量不会被重复利用的 String 的话，则有点得不偿失。由此可见，String.intern() 主要 <strong>适用于只有有限值，并且这些有限值会被重复利用的场景</strong>，如数据库表中的列名、人的姓氏、编码类型等。<br>此外，在比较字符串是否相等时，除了常见的equal()，还可以使用hashCode()，比较二者的该方法返回值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;String性质&quot;&gt;&lt;a href=&quot;#String性质&quot; class=&quot;headerlink&quot; title=&quot;String性质&quot;&gt;&lt;/a&gt;String性质&lt;/h2&gt;&lt;h3 id=&quot;不可变性&quot;&gt;&lt;a href=&quot;#不可变性&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="java" scheme="https://boneink.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java-加强型for循环与Iterator</title>
    <link href="https://boneink.github.io/2022/05/13/java-%E5%8A%A0%E5%BC%BA%E5%9E%8Bfor%E5%BE%AA%E7%8E%AF%E4%B8%8EIterator/"/>
    <id>https://boneink.github.io/2022/05/13/java-%E5%8A%A0%E5%BC%BA%E5%9E%8Bfor%E5%BE%AA%E7%8E%AF%E4%B8%8EIterator/</id>
    <published>2022-05-13T04:00:00.000Z</published>
    <updated>2022-05-13T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="加强型for循环与Iterator"><a href="#加强型for循环与Iterator" class="headerlink" title="加强型for循环与Iterator"></a>加强型for循环与Iterator</h2><ol><li><p>for-Each循环</p><p>数组中：</p><p>在数组中的 for-Each 最终会被编译器处理成一个普通的for循环，也就是说 for-Each循环是完全与普通for循环等价的，没有任何特殊的命令。</p><p>虽然for-Each 写起来方便，但也有以下几个局限性：</p><ul><li><p>只能对元素进行顺序的访问；</p></li><li><p>只能访问数组或集合中的所有元素；</p></li><li><p>循环中没有当前的索引，无法对指定的元素操作。如更换当前索引位置的元素。</p></li></ul><p>集合中：</p><p>直接采用普通for循环和get()方法进行list遍历。每次调用get()时都会对list进行一次遍历，因此比较消耗性能。</p><p>因此一般采用迭代器进行遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    <span class="comment">//获取集合的迭代器</span></span><br><span class="line">    Iterator&lt;String&gt; itor = list.iterator();</span><br><span class="line">    <span class="comment">//集合的普通for循环</span></span><br><span class="line">    <span class="keyword">for</span>(;itor.hasNext();)&#123;<span class="comment">//相当于 while(itor.hasNext())</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">item</span> <span class="operator">=</span> itor.next();</span><br><span class="line">        System.out.println(item);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对应的for-Each循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(String item:list)&#123;<span class="comment">//for-Each</span></span><br><span class="line">    System.out.println(item);</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p> 针对for-Each循环的处理：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>   &#123;  </span><br><span class="line">       <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();  </span><br><span class="line">       list.add(<span class="string">&quot;aa&quot;</span>);  </span><br><span class="line">       list.add(<span class="string">&quot;bb&quot;</span>);  </span><br><span class="line">       <span class="keyword">for</span>(String item:list)  </span><br><span class="line">       &#123;  </span><br><span class="line">           <span class="keyword">if</span>(<span class="string">&quot;bb&quot;</span>.equals(item))  </span><br><span class="line">               list.add(<span class="string">&quot;cc&quot;</span>);  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p> 其对应的反编译代码：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>   &#123;  </span><br><span class="line">       <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();  </span><br><span class="line">       list.add(<span class="string">&quot;aa&quot;</span>);  </span><br><span class="line">       list.add(<span class="string">&quot;bb&quot;</span>);  </span><br><span class="line">       <span class="keyword">for</span>(<span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator(); iterator.hasNext();)  </span><br><span class="line">       &#123;  </span><br><span class="line">           <span class="type">String</span> <span class="variable">item</span> <span class="operator">=</span> (String)iterator.next();  </span><br><span class="line">           <span class="keyword">if</span>(<span class="string">&quot;bb&quot;</span>.equals(item))  </span><br><span class="line">               list.add(<span class="string">&quot;cc&quot;</span>);  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br> <strong>与数组类似，编译器最终也就是将集合中的for-Each循环处理成集合的普通for循环</strong>。<br> 集合循环遍历时所使用的迭代器Iterator有一个要求：<strong>在迭代的过程中，除了使用迭代器（如:<code>Iterator.remove()</code>方法）对集合增删元素外，是不允许直接对集合进行增删操作。</strong> 否则将会抛出 ConcurrentModificationException异常。所以， <strong>由于集合的for-Each循环本质上使用的还是Iterator来迭代，因此也要注意这个陷阱</strong>  。<br> 集合中的for-Each循环的局限性与数组的for-Each循环是一样的。集合的for-Each循环是不能对集合进行增删操作、也不能获取索引。而集合的普通for循环可以使用的迭代器提供了对集合的增删方法（如：<code>Iterator.remove</code>，<code>ListIterator.add()</code>），获取索引的方法（如：<code>ListIterator.nextIndex()</code>、<code>ListIterator.previousIndex()</code>）。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;加强型for循环与Iterator&quot;&gt;&lt;a href=&quot;#加强型for循环与Iterator&quot; class=&quot;headerlink&quot; title=&quot;加强型for循环与Iterator&quot;&gt;&lt;/a&gt;加强型for循环与Iterator&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;f</summary>
      
    
    
    
    
    <category term="java" scheme="https://boneink.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java-自增自减与贪心规则</title>
    <link href="https://boneink.github.io/2022/05/12/java-%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E4%B8%8E%E8%B4%AA%E5%BF%83%E8%A7%84%E5%88%99/"/>
    <id>https://boneink.github.io/2022/05/12/java-%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E4%B8%8E%E8%B4%AA%E5%BF%83%E8%A7%84%E5%88%99/</id>
    <published>2022-05-12T04:00:00.000Z</published>
    <updated>2022-05-12T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="自增自减与贪心规则"><a href="#自增自减与贪心规则" class="headerlink" title="自增自减与贪心规则"></a>自增自减与贪心规则</h3><ol><li>自增自减是包含两个两个操作，不是线程安全的</li></ol><p>   自增自减运算符包含两个操作：<strong>一个加1（减1）的操作和一个赋值的操作</strong></p><p>   <strong>自增自减不是原子性操作，也就是说不是线程安全的运算。</strong> 因此，在多线程下，如果你要对共享变量实现自增自减操作，就要加锁，或者使用JDK提供的原子操作类（如<code>AtomincInteger</code>，<code>AtomicLong</code>等）提供的原子性自增自减方。</p><p>   来看个例子，验证一下。下面的例子提供三个静态变量（一个是原子操作类），创建了10个线程，每个线程都对这三个变量以不同的方式进行加1操作,并循环1000次。</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;    </span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;    </span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">//原子性操作类    </span></span><br><span class="line"><span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;<span class="comment">//创建10个线程            </span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;                </span><br><span class="line">            <span class="meta">@Override</span>                </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;                    </span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;<span class="comment">//计算1000次</span></span><br><span class="line">                        a = a + <span class="number">1</span>;</span><br><span class="line">                        b++;</span><br><span class="line">                        atomicInt.incrementAndGet();<span class="comment">//自增的原子性方法</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;        <span class="comment">// 判断当前的活动线程是不是只有main线程，以确保10个计算线程执行完成。</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;a=a+1在多线程下的结果是：&quot;</span> + a);</span><br><span class="line">        System.out.println(<span class="string">&quot;b++在多线程下的结果是：&quot;</span> + b);</span><br><span class="line">        System.out.println(<span class="string">&quot;原子操作类AtomicInteger在多线程下的结果是：&quot;</span> + atomicInt.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   运行结果：</p><blockquote><p>a&#x3D;a+1在多线程下的结果是：8883<br>b++在多线程下的结果是：8974<br>原子操作类AtomicInteger在多线程下的结果是：10000</p></blockquote><p>     从运行的结果可以看出，<code>a=a+1、b++</code>不是线程安全的，没有计算出正确的结果10000。也就是说这两个表达式都不是原子性操作。事实上，它们都包含了两个计算操作。</p><ol start="2"><li><p>编译器的贪心规则：</p><ul><li><p>Java中的运算是从左往右进行的；</p></li><li><p>java编译器有一种规则——贪心规则。<strong>也就是说，编译器会尽可能多地结合有效的符号。</strong></p></li></ul><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;    </span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">5</span>;    </span><br><span class="line"><span class="type">int</span> c=a+++b;    </span><br><span class="line">System.out.println(<span class="string">&quot;a的值是: &quot;</span>+a);    </span><br><span class="line">System.out.println(<span class="string">&quot;b的值是: &quot;</span>+b);</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>a的值是: 6<br>b的值是: 5</p></blockquote><p>从结果可以确认，<code>a+++b</code> 其实是解析成了 <code>a++ +b</code></p><p>贪心规则的主要目的就是为了分析String字符串，看看下面的例子就会明白：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;\17&quot;</span>;    </span><br><span class="line">System.out.println(<span class="string">&quot;\\17 转义字符的值是：&quot;</span>+s+<span class="string">&quot;  长度是：&quot;</span>+s.length());    </span><br><span class="line">s = <span class="string">&quot;\171&quot;</span>;    </span><br><span class="line">System.out.println(<span class="string">&quot;\\171 转义字符的值是：&quot;</span>+s+<span class="string">&quot;  长度是：&quot;</span>+s.length());    </span><br><span class="line">s = <span class="string">&quot;\1717&quot;</span>;    </span><br><span class="line">System.out.println(<span class="string">&quot;\\1717 转义字符的值是：&quot;</span>+s+<span class="string">&quot;  长度是：&quot;</span>+s.length());    </span><br><span class="line">s = <span class="string">&quot;\17178&quot;</span>;    </span><br><span class="line">System.out.println(<span class="string">&quot;\\17178 转义字符的值是：&quot;</span>+s+<span class="string">&quot;  长度是：&quot;</span>+s.length());</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>\17 转义字符的值是：   长度是：1<br>\171 转义字符的值是：y   长度是：1<br>\1717 转义字符的值是：y7   长度是：2<br>\17178 转义字符的值是：y78   长度是：3</p></blockquote><p>“\17” 经转义得到一个特殊字符 “” 。而“\171” 转义后也得到一个字符 “y”。但 “\1717”、“\17178” 得到的字符串大于1，不再是一个字符，分别是 “y7”、“y78”。</p><p>也就是说,“\1717” 字符串只转义了“\171” 部分，再链接 “7” 部分。“\17178” 字符串只转义了 “\171” 部分,再连接 “78”。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;自增自减与贪心规则&quot;&gt;&lt;a href=&quot;#自增自减与贪心规则&quot; class=&quot;headerlink&quot; title=&quot;自增自减与贪心规则&quot;&gt;&lt;/a&gt;自增自减与贪心规则&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;自增自减是包含两个两个操作，不是线程安全的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;</summary>
      
    
    
    
    
    <category term="java" scheme="https://boneink.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java-基本数据类型</title>
    <link href="https://boneink.github.io/2022/05/11/java-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://boneink.github.io/2022/05/11/java-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2022-05-11T04:00:00.000Z</published>
    <updated>2022-05-11T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><ol><li><p>基本数据类型中，取值范围较大的是高级类型，低的是低级，低级向高级转换可以直接转换（隐式），反之则要显式强制转换,字面常量也可以隐式转换： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>;  <span class="comment">//8是字面常量</span></span><br><span class="line">    <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">9</span>;  <span class="comment">//9是字面常量</span></span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">9</span>+<span class="number">5</span>;<span class="comment">//常量表达式</span></span><br><span class="line">    <span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> (<span class="type">short</span>) (c+<span class="number">10</span>); <span class="comment">//变量表达式，需要显式强制转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>整形字面常量隐式转换的限制：</strong></p><ul><li>整形字面常量的大小超出目标类型所能表示的范围时，要手动强制类型转换。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte b = 128;//编译错误，128超出byte类型所能表示的范围byte c = (byte)128;//编译通过</span><br></pre></td></tr></table></figure><ul><li><p>对于传参数时，必须要显式地进行强制类型转换，明确转换的类型</p><ol start="2"><li><p><em><em>复合运算符（+&#x3D;、-&#x3D;、</em>&#x3D;、&#x2F;&#x3D;、%&#x3D;）是可以将右边表达式的类型自动强制转换成左边的类型</em>*</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>;      </span><br><span class="line">    <span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">5</span>;     </span><br><span class="line">    s += a;    </span><br><span class="line">    s += a+<span class="number">5</span>;   </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>  <code>s+=a、s+=a+5</code>;的表达式计算结果都是int类型，但都不需要手动强制转换。其实，如果是反编译这段代码的class文件，你会发现s+&#x3D;a;，其实是被编译器处理成了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s=(<span class="type">short</span>)(s+a)</span><br></pre></td></tr></table></figure><p><strong>也就是说对于所有的复合运算的隐式类型转换，其实是编译器自动添加类型转换的代码。</strong></p></li></ol></li></ul><ol start="3"><li><p>char类型在基本类中是一个比较特殊的存在。这种特殊性在于<strong>char类型是一个无符号类型，所以char类型与其他基本类型不是子集与父集间的关系（其他类型都是有符号的类型）。也就是说，char类型与byte、short之间的转换都需要显式的强制类型转换（小类型自动转换成大类型失败）。</strong></p><p>  同时，<strong>由于char类型是一个无符号类型，所以对于整形字面常量的隐式转换的限制，不仅包括字面常量数值的大小不能超出2个字节，还包括字面常量数值不能为负数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>; <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">2</span>;<span class="comment">//编译通过     </span></span><br><span class="line">c = <span class="number">100000000000</span>;<span class="comment">//编译不通过，超出char类型的范围 </span></span><br><span class="line"><span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> -<span class="number">2</span><span class="comment">//字面常量为负数，编译不通过      </span></span><br><span class="line">d = (<span class="type">char</span>)-<span class="number">100</span>;<span class="comment">//编译通过 char f = (char)b; //编译通过，必须显式的强制类型转换      </span></span><br><span class="line">f = b;<span class="comment">//编译不通过，不能隐式转换 </span></span><br><span class="line"><span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> c;<span class="comment">//编译通过，可以不需要强制类型转换 </span></span><br><span class="line"><span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> (<span class="type">short</span>) c;<span class="comment">//编译通过，必须显式地强制类型转换</span></span><br></pre></td></tr></table></figure><p>  char类型是无符号的类型，这种无符号也体现在在其转换成int类型时，也就是说，<strong>char类型在扩展时，也是按无符号的方式扩展，扩展位填0</strong>。我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> -<span class="number">5</span>;</span><br><span class="line">   <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>)s;     </span><br><span class="line">   System.out.println(c==s);  <span class="comment">//false    </span></span><br><span class="line">   System.out.println(<span class="string">&quot;(int)c = &quot;</span>+(<span class="type">int</span>)c); <span class="comment">//转换成int类型，值为65531    </span></span><br><span class="line">   System.out.println(<span class="string">&quot;(short)c = &quot;</span>+(<span class="type">short</span>)c); <span class="comment">//-5    </span></span><br><span class="line">   System.out.println(<span class="string">&quot;(int)s = &quot;</span>+(<span class="type">int</span>)s);<span class="comment">//-5</span></span><br></pre></td></tr></table></figure></li></ol><p>运行结果：</p><blockquote><p>false<br> (int)c &#x3D; 65531<br> (short)c &#x3D; -5<br> (int)s &#x3D; -5</p></blockquote><p>  <strong>从上面的结果发现，char类型的c 与 short类s其实存储字节码内容是一样的，但由于前者是无符号，所以扩展成int类型的结果是 65531，而不是 -5。运算符&#x3D;&#x3D;比较的就是他们扩展成int类型的值，所以为fasle。</strong></p><p><strong>对char类型的类型转换，可以总结成以下几点：</strong></p><ul><li><p>char类型与byte、short的相互转换，都需要显式地强类型制转换。</p></li><li><p>对于数值是负数的，都需要进行显式地强制类型转换，特别是在整形字面常量的隐式转换中。</p></li><li><p>char类型转换成int、long类型是符合 小类型转大类型的规则，即无需要强制类型转换。</p></li></ul><ol start="4"><li><p><strong>java的运算结果的类型有两个性质：</strong></p><ul><li><p>运算结果的类型必须是int类型或int类型以上。</p></li><li><p>最高类型低于int类型的，运算结果都为int类型。否则，运算结果与表达式中最高类型一致。</p></li></ul></li><li><p>浮点类型</p><p>浮点型所能表示的有效位是有限的，所以哪怕是整数，只要超出有效位数，也只能存储相似值，也就是该数值的最低有效位将会丢失,从而造精度丢失。<br><strong>float类型的二进制有效位是24位，对应十进制的7 ~ 8位数字；double类型的二进制53位，对应十进制的10 ~ 11位数字。</strong></p><p>double、float类型 所能表示的范围比int、long类型表示的范围要广，也浮点类型属于大类型。但是，并不能完美地表整形，浮点类型的精度丢失会造成一些问题。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    </span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3000000</span>;    </span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">30000000</span>;    </span><br><span class="line"><span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> a;    </span><br><span class="line"><span class="type">float</span> <span class="variable">f2</span> <span class="operator">=</span> b;    </span><br><span class="line">System.out.println(<span class="string">&quot;3000000==3000001 &quot;</span>+(f1==f1+<span class="number">1</span>));    </span><br><span class="line">System.out.println(<span class="string">&quot;30000000==30000001 &quot;</span>+(f2==f2+<span class="number">1</span>));    </span><br><span class="line">System.out.println(<span class="string">&quot;3000000的有效二进制位数：&quot;</span>+ Integer.toBinaryString(a).length());    </span><br><span class="line">System.out.println(<span class="string">&quot;30000000的有效二进制位数：&quot;</span>+ Integer.toBinaryString(b).length());&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>3000000 &#x3D;&#x3D; 3000001  false<br>30000000 &#x3D;&#x3D; 30000001  true<br>3000000的有效二进制位数： 22<br>30000000的有效二进制位数： 25</p></blockquote><p>上面的例子很好体现了精度丢失所带来的后果：<code>30000000==30000001</code> 的比较居然为true了。而造成这种结果的原因就是 30000000的有效二进制位数是25位，超出了float所能表示的有效位24位，最后一位就被舍去，所以就造成在刚加的1也被舍去，因此30000000的加一操作前后的浮点型表示是一样的。</p><p>当然，<strong>并不是超出浮点型的有效位就不能精确表示，其实，主要看的是最高有效位与最低非0有效位之间的 “间隙”，如果间隙的在浮点型的有效位数内，自然可以精确表示，因为舍去的低有效位都是0，自然就无所谓了。</strong>如果上面的例子的浮点型用的是double就不会丢失精度了，因为double的精度是52位。</p><p><strong>解决浮点型精度丢失的问题</strong>：JDK为此提供了两个高精度的大数操作类给我们：BigInteger、BigDecimal。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本数据类型&quot;&gt;&lt;a href=&quot;#基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;基本数据类型&quot;&gt;&lt;/a&gt;基本数据类型&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;基本数据类型中，取值范围较大的是高级类型，低的是低级，低级向高级转换可以直接转换（隐式），</summary>
      
    
    
    
    
    <category term="java" scheme="https://boneink.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>挖矿木马总结</title>
    <link href="https://boneink.github.io/2022/03/01/%E6%8C%96%E7%9F%BF%E6%9C%A8%E9%A9%AC%E6%80%BB%E7%BB%93/"/>
    <id>https://boneink.github.io/2022/03/01/%E6%8C%96%E7%9F%BF%E6%9C%A8%E9%A9%AC%E6%80%BB%E7%BB%93/</id>
    <published>2022-03-01T04:00:00.000Z</published>
    <updated>2022-03-01T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="挖矿木马总结"><a href="#挖矿木马总结" class="headerlink" title="挖矿木马总结"></a>挖矿木马总结</h1><h3 id="腾讯《2020年挖矿木马年度报告》"><a href="#腾讯《2020年挖矿木马年度报告》" class="headerlink" title="腾讯《2020年挖矿木马年度报告》"></a>腾讯《2020年挖矿木马年度报告》</h3><p>2020 年各类数字加密货币价格迎来暴涨，比特币价格一度超过 5 万美元 &#x2F; BTC，市值达到 9200 亿美 元，是 2019 年底的 10 倍之多，达到了历史最高点。同期挖矿木马最偏好的门罗币价格也同步增长 6 倍，这意味着黑客通过进行门罗币挖矿，兑现后收益可达到以往收益的 6 倍。在如此大利益诱惑之下， 黑产团伙已闻风而动，纷纷加入了对主机计算资源的争夺，一个典型现象就是，有大量挖矿木马在运行 时，会尝试清除竞争对手木马。</p><h4 id="挖矿家族Top"><a href="#挖矿家族Top" class="headerlink" title="挖矿家族Top"></a>挖矿家族Top</h4><p>2020 年度挖矿木马家族排名前三的分别为 DTLMiner（永恒之蓝下载器木马）、H2Miner、 GuardMiner，榜单中有通过永恒之蓝漏洞传播的为 DTLMiner、NSABuffMiner、 NSAGluptebaMiner，有利用 Redis、Hadoop、Weblogic、Drupal、thinkphp 等应用程序漏洞传播的 为 H2Miner、GuardMiner、z0Miner、8220Miner 等家族，以及主要通过弱口令爆破进行传播的为 KoiMiner 家族。</p><p><img src="https://wx2.sinaimg.cn/large/69b019d1gy1gnzmju6hq1j20fc0btdg1.jpg"></p><h4 id="入侵通道"><a href="#入侵通道" class="headerlink" title="入侵通道"></a>入侵通道</h4><ol><li><p>利用漏洞</p><p>远程代码执行漏洞（RCE）可以让远程攻击者直接向后台服务器远程注入操作系统命令或者恶意代码，从而控制后台系统，挖矿木马攻击时最常用的远程代码执行漏洞 TOP 统计如下：</p></li></ol><p><img src="https://wx4.sinaimg.cn/large/69b019d1gy1gnzmm3b76sj20fe09v0ue.jpg"></p><p><img src="https://wx4.sinaimg.cn/large/69b019d1gy1gnzmmn5o43j20fo0an3z2.jpg"></p><ol start="2"><li><p>爆破攻击</p><p>用户在设置系统登陆密码时，为了方便记忆往往采用默认的空口令或者非常简单的密码例如 admin、root、test、111111、123456 等，使用这些密码导致黑客可以轻易猜解并登陆，从而入侵系统。</p><p>许多挖矿木马在传播时也会针对系统的弱密码进行爆破攻击，根据腾讯安全 2020 年云上安全报告提供的数据，默认用户名、端口名被爆破攻击的次数达数十亿次之多。常被挖矿木马爆破攻击的服务类型包括 SSH、Mssql、Redis 等，各类型爆破攻击对应的挖矿家族如下：</p><p>MS SQL</p><p>永恒之蓝下载器木马、GuardMiner 、MrbMiner、BasedMiner、贪吃蛇挖矿木马、快 GO 旷工</p><p>SSH 爆破</p><p>永恒之蓝下载器木马、Ks3_Miner、LoggerMiner、8220Miner、DDG</p><p>Redis 爆破</p><p>永恒之蓝下载器木马、H2Miner、GuardMiner、DDG</p><p>Msql 爆破</p><p>Mykings</p></li><li><p>僵尸网络渠道</p><p>具有僵尸网络特征的挖矿木马 TOP 榜如下，其中前三位是 DTLMiner（永恒之蓝下载器木马）、H2Miner、GuardMiner 为老牌僵尸网络，由于控制该僵尸网络的幕后黑客团伙仍在不断更新其攻击方法，使其在出现后的数年里仍然保持很高的活跃度。</p><p>在 2020 年新活跃的挖矿木马家族以 Linux 服务器为攻击对象的居多，例如通过 SSH 弱口令攻击的 Outlaw、Prometei，通过 Docker Remote API 漏洞入侵的 TeamTNT，以及通过 Nexus Repository Manager 3 弱密码入侵，利用 Mysql、Tomcat 弱口令爆破，Weblogic 远程代码执行漏洞进行横向扩散的 Sysrv-hello 家族等等。</p><p><img src="https://wx2.sinaimg.cn/large/69b019d1gy1gnzmnlovikj20fu0btt90.jpg"></p></li><li><p>入侵后开展恶意行为</p><p>4.1 通过linux定时任务</p><p>4.2 通过linux系统服务：启动项&#x2F;安装服务</p><p>4.3 Windows WMI</p></li></ol><h4 id="挖矿类型："><a href="#挖矿类型：" class="headerlink" title="挖矿类型："></a>挖矿类型：</h4><p><strong>基于浏览器的挖矿</strong></p><p>基于浏览器的挖矿劫持的实际攻击对象是网站的服务器。受害者经常是僵尸网络的一部分，因为单个受害者还无法完成工作量证明，一般是多个受害者一起完成一个特定任务。恶意JS脚本（大多数攻击者会直接使用修改的coinhive脚本）一般会被注入网页的广告或者自加载资源，以便用户访问网页时可以自动执行。</p><p>由于受害的是用户，而被攻击的服务器本身没有受到什么损害，所以该攻击难以被网站管理员发现。</p><p>正常的coinhive使用时，会事先询问用户是否允许进行挖矿，用户同意后，赚取的收益的30%由coinhive获得，余下的由网站获得。而攻击者修改后的coinhive脚本运行时，获得的收益全由攻击者获得。</p><p><strong>基于恶意软件的挖矿：</strong></p><p>感染计算机，安装加密矿工（样本），并使用从受害者电脑窃取得来的信息来建立用于非法资金转移的钱包。无需像勒索软件那样对目标进行勒索获取赎金，而是直接从良性互联网用户那里获得加密货币。</p><p>偷渡式挖矿，在受害者系统上只停留很短的时间，然后进入下一个受害者，接着会再次回来并重复这一过程。这种短时间的可用性使其很难被检测到。</p><p>偷渡式下载是一种常见的攻击方法，当用户访问一个嵌入恶意代码的网站时，它会滥用浏览器的合法功能开始自动文件下载或提示下载诱骗用户运行恶意程序。基于恶意软件的挖矿劫持一般会采用这种形式。</p><h3 id="常见的加密货币："><a href="#常见的加密货币：" class="headerlink" title="常见的加密货币："></a>常见的加密货币：</h3><p><strong>比特币</strong>：</p><ol><li>生成coinbase交易，并与其他所有准备打包进区块的交易组成交易列表，通过Merkle树算法生成Merkle根哈希；</li><li>把Merkle根哈希及其他相关字段组装成区块头，将区块头的80字节数据作为工作量证明的输入；</li><li>不停地变更区块头中的随机数，即nonce的数值，并对每次变更后的区块头做双重SHA256运算，将结果值与当前网络的目标值做对比，如果小于目标值则解题成功，工作量证明完成。</li></ol><p><strong>以太坊</strong></p><p>Ethash是以太坊1.0中使用的PoW(工作量证明)算法,它是Hashimoto算法结合Dagger之后产生的一个变种。它的特点是计算的效率基本与CPU无关，却和内存大小和内存带宽正相关。因此通过共享内存的方式大规模部署的矿机芯片并不能在挖矿效率上有线性或者超线性的增长。</p><p>该算法的一般流程如下：</p><p>首先根据块信息计算一个种子(seed, c++代码中为seedhash)<br>使用这个种子，计算出一个16MB的cache数据。轻客户端需要存储这份cache.<br>通过cache，计算出一个1GB(初始大小)的数据集(DAG)，DAG可以理解为是一个完整的搜索空间，全客户端和矿工需要存储完整的DAG，挖矿过程中需要从DAG中重复的随机抽取数据拿去和其他数据计算mixhash，DAG中每个元素的生成只依赖于cache中的少量数据。每到一个新的纪元DAG会完全不一样，并且它的大小也随时间线性增长。<br>由于仅根据cache就可以使用少量内存快速的计算出DAG中指定位置的数据，所以轻客户端只需要存储cache就可以高效的进行校验。</p><p><strong>门罗币</strong></p><p>Monero门罗币XMR计划于2019年的10月份启用最新的RandomX 算法以取代原来的CryptoNight挖矿算法，以继续优化抗ASIC+降低GPU优势来保持门罗POW网络的分散性</p><p>RandomX的行为类似于键控散列函数：它接受一个键。任意输入并产生256位的结果。在底层，RandomX使用虚拟机在一个特殊的指令集中执行程序，该指令集由整数运算、浮点运算和分支组成。这些程序可以动态转换为CPU的本机代码。将RandomX程序转换为x86-64程序集的示例是program.asm…还提供了一种便携式解释模式。</p><p>RandomX可以在具有不同内存需求的两种主要模式下工作：<br>Fast模式-需要2080 MIB共享内存。（该算法要求挖矿者为进程提供超过2G的 RAM，这可能会使加密攻击更难隐藏。）<br>Light模式-只需要256 MIB共享内存，但运行速度要慢得多</p><p><strong>狗狗币</strong></p><p>scrpyt算法是由著名的FreeBSD黑客 Colin Percival为他的备份服务 Tarsnap开发的，当初的设计是为了降低CPU负荷，尽量少的依赖cpu计算，利用CPU闲置时间进行计算，因此scrypt不仅计算所需时间长，而且占用的内存也多，使得并行计算多个摘要异常困难，因此利用rainbow table进行暴力攻击更加困难。scrypt没有在生产环境中大规模应用，并且缺乏仔细的审察和广泛的函数库支持。所以scrpyt一直没有推广开，但是由于其内存依赖的设计特别符合当时对抗专业矿机的设计，成为数字货币算法发展的一个主要应用方向。</p><p>后来有人在SCRYPT的基础上稍作修改形成Scrypt –N算法，改进思路都一样，都是追求更大的内存消耗和计算时间，以有效阻止ASIC专用矿机。</p><p>Scrypt是内存依赖型的POW算法，莱特币采用此算法。第一个使用Scrypt算法的数字货币是Tenebrix，而后该算法被莱特币使用。莱特币创始人在莱特币创世帖中介绍了莱特币采用的共识机制，挖矿算法，发行总量，挖矿难度等相关重要信息。李启威说明了莱特币所使用的挖矿算法为数字货币Tenebrix所使用的Scrypt算法，是一种符合PoW共识机制的算法。Scrypt算法过程中也需要计算哈希值，但是，Scrypt计算过程中需要使用较多的内存资源。</p><p>其它使用Scrypt算法的数字货币还有数码币（DigitalCoin）、狗狗币（DogeCoin）、幸运币（LuckyCoin）、世界币（WorldCoin）等。</p><p><strong>莱特币</strong></p><p>Scrypt算法</p><h3 id="近年来恶意挖矿软件总结："><a href="#近年来恶意挖矿软件总结：" class="headerlink" title="近年来恶意挖矿软件总结："></a>近年来恶意挖矿软件总结：</h3><table><thead><tr><th>文献名</th><th>时间</th><th>期刊&#x2F;会议</th><th>等级</th><th>作者</th><th>学校&#x2F;单位</th><th>贡献</th><th>检测类型</th><th>检测方法</th><th>不足&#x2F;总结</th></tr></thead><tbody><tr><td>Cryptocurrency malware hunting: A deep Recurrent Neural Network  approach</td><td>2020</td><td>Applied  Soft Computing (ASC)</td><td>SCI  Q1</td><td>Abbas  Yazdinejad, Hamed HaddadPajouh, Ali Dehghantanha, Reza M. Parizi, Gautam  Srivastava, Mu-Yen Chen,</td><td>Cyber  Science Lab, School of Computer Science, University of Guelph, Ontario,  Canada</td><td>1.  一个用于检测MS Windows平台上加密货币恶意软件威胁的三层深度循环神经网络(RNN)模型。     2. 一个包含500个真实世界的加密货币恶意软件应用程序和200多个合法加密货币应用程序的数据集。     3. 对传统ml算法和提出的模型进行对比分析，以展示rnnon检测加密货币恶意软件威胁的有效性。</td><td>二进制文件检测</td><td>反编译提取操作码，对每个样本的操作码创建一个特征向量，利用矢量化的数据对深度神经网络模型进行训练。</td><td>拓展：增加字节码、头文件和系统调用等特征，从而降低假阳性率</td></tr><tr><td>An Application Agnostic Defense Against the Dark Arts of  Cryptojacking</td><td>2021</td><td>2021  51st Annual IEEE&#x2F;IFIP International Conference on Dependable Systems and  Networks (DSN)</td><td>CCF  B</td><td>N.  Lachtar, A. A. Elkhail, A. Bacha and H. Malik</td><td></td><td>1.  提出一种应用无关的设计，利用微架构和操作系统层的创新防御加密劫持攻击     2. 演示了通常出现在加密函数中的监控指令     3. 户应用程序的各种指令类型与加密劫持检测的高准确性的相关性     4. 提出一种针对代码混淆、多线程和限制型攻击的健壮设计，同时保留较低误报率。</td><td>二进制文件检测</td><td>分析和统计哈希操作相关的操作码，通过机器学习进行分类操作</td><td></td></tr><tr><td>MineSweeper An In-depth Look into Drive-by Cryptocurrency Mining  and Its Defense</td><td>2018</td><td>Proceedings  of the 2018 ACM SIGSAC Conference on Computer and Communications Security</td><td>CCF  A</td><td>Radhesh  Krishnan Konoth, Emanuele Vineti, Veelasha Moonsamy, Martina Lindorfer,  Christopher Kruegel, Herbert Bos, and Giovanni Vigna</td><td>New  York, NY, USA,</td><td>1.  对偷渡式采矿进行了首次深入评估。       - 互联网上的偷渡式挖矿行为的普遍程度。       - 目前存在多少种偷渡式挖矿服务。       - 偷渡式挖矿采用的规避策略。       - 不同类型的偷渡式挖矿采用的方法。       - 不同类型的偷渡式挖矿的利润。       - 在不同的偷渡式挖矿服务中找到共同特征用于检测。     2. 讨论了为何当前基于黑名单和CPU使用的防御是无效的。     3. 提出了MINESWEEPER这一新的检测方法，通过静态分析识别密码函数，并在运行时监控缓存事件。</td><td>浏览器脚本检测</td><td>1.  匹配原语中的加密计数，计算相似度评分     2. 对于新变体和其他散列算法，计算每个函数循环中加密操作码的计数，对比阈值     3. 对于高度模糊的Wasm模块，检测CPU负载</td><td>1.  爬虫仍需优化。     2. 针对其他设备（如Android手机）的活动研究。     3. 基于静态分析的方法仍容易混淆（但考虑到利润，攻击者会得不偿失）     4. 目前仅针对Wasm的挖矿代码，未来可以考虑分析asm.js。     5. Wasm的加密函数可能会用在其他地方，可能会出现假阳性（但目前wasm还没有被其他用例广泛使用）</td></tr><tr><td>MINOS: A Lightweight Real-Time Cryptojacking Detection System</td><td>2021</td><td>Network  and Distributed Systems Security (NDSS) Symposium 2021</td><td>CCF  B</td><td>Arış,  Ahmet &amp; Naseem, Faraz &amp; Babun, Leonardo &amp; Tekiner, Ege &amp;  Uluagac, Selcuk.</td><td></td><td>1.  提出一种新的加密劫持行为检测机制，在轻量级和端到端框架中实现Wasm二进制分类器：MINOS     2. 提出一种新的Wasm二分类计数，利用二值的灰度图像表示来训练卷积神经网络。     3. MINOS以最小的开销，在真实场景的数据集上以98.97%的准确率检测基于wasm的加密劫持。</td><td>浏览器脚本检测</td><td>收集网站产生的Wasm文件，转换成为灰度图像并导入CNN中进行分类</td><td>未对混淆的分类结果进行阐述</td></tr><tr><td>Cryptomining makes noise Detecting cryptojacking via Machine  Learning</td><td>2021</td><td>Computer  Communications</td><td>CCF  C     SCI Q2</td><td>Maurantonio  Caprolua,Simone Raponia     , Gabriele Oligeria     and Roberto Di Pietroa</td><td></td><td>1.  定义了包含加密劫持攻击的海绵攻击:未经基础设施所有者授权,利用第三方软硬件资源获取个人利益的恶意行为。     2. 详细分析了三种主要加密货币:Bitcoin、Monero和Bytecoin产生的真实网络流量。     3. 分析了两大VPN品牌:NordVPN和ExpressVPN的VPN隧道如何处理由Crypto-clients产生的网络流量。     4. 提出一个基于机器学习的框架:Crypto-Aegis,用于检测几种不同形式的crypto-mining,如单独挖矿和池采矿。     5. 与其他文献中的方案进行了对比,第一个利用机器学习技术通过分析网络流量来检测加密客户端</td><td>流量检测</td><td>分析进站出站流量包大小和达到时间间隔</td><td>1.  本文的错误分类情况大多出现在加密货币之间的错误分类     2. 本文所选正常软件的样本类型偏少     3. 可以考虑综合出站入栈流量</td></tr><tr><td>MineHunter: A Practical Cryptomining Traffic Detection Algorithm  Based on Time Series Tracking</td><td>2021</td><td>Annual  Computer Security Applications Conference (ACSAC)</td><td>CCF  B</td><td>Shize  Zhang, Zhiliang Wang, Jiahai Yang, Xin Cheng, XiaoQian Ma, Hui Zhang, Bo  Wang, Zimu Li, and Jianping Wu</td><td>Association  for Computing Machinery, New York, NY, USA</td><td>1.  分析了加密挖矿的网络流量特征，将加密挖矿的流序列与加密货币的块创建序列相关联     2. 提出一种时间序列跟踪的加密挖掘流量监测算法     3. 在校园网环境中进行了大规模评价实验，效果很好。</td><td>流量监测</td><td>按照加密挖矿的周期和时间间隔对流量进行分类</td><td>未能解决对挖矿软件进行流量分析时，样本的比例悬殊较大引起的高误报率问题</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;挖矿木马总结&quot;&gt;&lt;a href=&quot;#挖矿木马总结&quot; class=&quot;headerlink&quot; title=&quot;挖矿木马总结&quot;&gt;&lt;/a&gt;挖矿木马总结&lt;/h1&gt;&lt;h3 id=&quot;腾讯《2020年挖矿木马年度报告》&quot;&gt;&lt;a href=&quot;#腾讯《2020年挖矿木马年度报告》&quot; c</summary>
      
    
    
    
    
    <category term="恶意软件检测" scheme="https://boneink.github.io/tags/%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8B/"/>
    
    <category term="入侵检测" scheme="https://boneink.github.io/tags/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/"/>
    
    <category term="木马检测" scheme="https://boneink.github.io/tags/%E6%9C%A8%E9%A9%AC%E6%A3%80%E6%B5%8B/"/>
    
    <category term="网络安全" scheme="https://boneink.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>一元多项式的乘法与加法运算</title>
    <link href="https://boneink.github.io/2021/02/15/%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E4%B9%98%E6%B3%95%E4%B8%8E%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97/"/>
    <id>https://boneink.github.io/2021/02/15/%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E4%B9%98%E6%B3%95%E4%B8%8E%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97/</id>
    <published>2021-02-15T04:00:00.000Z</published>
    <updated>2021-02-15T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一元多项式的乘法与加法运算"><a href="#一元多项式的乘法与加法运算" class="headerlink" title="一元多项式的乘法与加法运算"></a>一元多项式的乘法与加法运算</h2><p> 来自PTA平台的一道算法题：</p><p>设计函数分别求两个一元多项式的乘积与和。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出<code>0 0</code>。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 3 4 -5 2  6 1  -2 0</span><br><span class="line">3 5 20  -7 4  3 1</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">15 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 1</span><br><span class="line">5 20 -4 4 -5 2 9 1 -2 0</span><br></pre></td></tr></table></figure><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>个人倾向于使用java来解题，毕竟不用涉及指针之类的。</p><p>开始想的是采用HashMap进行键值对映射，将指数作为key值，系数作为对应的value，相对来说很容易实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        Map&lt;Integer, Integer&gt; item1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n1; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">y1</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            item1.put(y1, x1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        Map&lt;Integer, Integer&gt; item2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n2; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x2</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">y2</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            item2.put(y2, x2);</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; resMul = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry1 : item1.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry2 : item2.entrySet()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">reKeyMul</span> <span class="operator">=</span> entry1.getKey() + entry2.getKey();</span><br><span class="line">                <span class="type">int</span> <span class="variable">reValueMul</span> <span class="operator">=</span> entry1.getValue() * entry2.getValue();</span><br><span class="line">                <span class="keyword">if</span> (reValueMul != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (resMul.get(reKeyMul) != <span class="literal">null</span>) &#123;</span><br><span class="line">                        reValueMul += resMul.get(reKeyMul);</span><br><span class="line">                    &#125;</span><br><span class="line">                    resMul.put(reKeyMul, reValueMul);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; resAdd = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        temp.putAll(item2);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : item1.entrySet()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="comment">//resAdd.put(key, entry.getValue());</span></span><br><span class="line">            <span class="type">int</span> reAdd;</span><br><span class="line">            <span class="keyword">if</span> (temp.get(key) != <span class="literal">null</span>) &#123;</span><br><span class="line">                reAdd = entry.getValue() + temp.get(key);</span><br><span class="line">                temp.remove(key);</span><br><span class="line">            &#125; <span class="keyword">else</span> reAdd = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (reAdd != <span class="number">0</span>)</span><br><span class="line">                resAdd.put(key, reAdd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : temp.entrySet()) &#123;</span><br><span class="line">            resAdd.put(entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resMul.size() == <span class="number">0</span>) System.out.println(<span class="string">&quot;0 0&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            resMul.entrySet().stream().sorted((e1, e2) -&gt; e2.getKey().compareTo(e1.getKey())).forEach(e -&gt; System.out.print(e.getValue() + <span class="string">&quot; &quot;</span> + e.getKey() + <span class="string">&quot; &quot;</span>));</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resAdd.size() == <span class="number">0</span>) System.out.println(<span class="string">&quot;0 0&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            resAdd.entrySet().stream().sorted((e1, e2) -&gt; e2.getKey().compareTo(e1.getKey()));</span><br><span class="line">           Iterator&lt;Map.Entry&lt;Integer,Integer&gt;&gt; iterator=resAdd.entrySet().iterator();</span><br><span class="line">           Map.Entry&lt;Integer,Integer&gt; entry=iterator.next();</span><br><span class="line">           System.out.print(entry.getValue()+<span class="string">&quot; &quot;</span>+entry.getKey());</span><br><span class="line">           <span class="comment">//for( key:resAdd.keySet())</span></span><br><span class="line"><span class="comment">//            //Iterator&lt;Map.Entry&lt;Integer,Integer&gt;&gt; iterator=resAdd.keySet().iterator();</span></span><br><span class="line"><span class="comment">//            Map.Entry&lt;Integer,Integer&gt; key=iterator.next();</span></span><br><span class="line"><span class="comment">//            System.out.print(key.get);</span></span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                entry=iterator.next();</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>+entry.getValue()+<span class="string">&quot; &quot;</span>+entry.getKey());</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在自己的计算机上运行sample没有问题，遂丢到平台查看效果。果然不出所料，结果全部超时，这就意味着要采取更加基础和效率的方式进行。</p><p>采取数组方式记录结果，通过角标表示指数，已知指数绝对值大小不超过1000，即用指数+1000作为角标即可，对应的位置存储系数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Item</span><span class="params">(<span class="type">int</span> y, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.y = y;</span><br><span class="line">            <span class="built_in">this</span>.x = x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getY</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setY</span><span class="params">(<span class="type">int</span> y)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.y = y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getX</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setX</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        <span class="comment">//Map&lt;Integer, Integer&gt; item1 = new HashMap&lt;&gt;();</span></span><br><span class="line">        Item[] items1 = <span class="keyword">new</span> <span class="title class_">Item</span>[n1];</span><br><span class="line">        <span class="type">int</span>[] resSum=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2005</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n1; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">y1</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            items1[i]=<span class="keyword">new</span> <span class="title class_">Item</span>(y1,x1);</span><br><span class="line">            resSum[y1+<span class="number">1000</span>]+=x1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        Item[] items2 = <span class="keyword">new</span> <span class="title class_">Item</span>[n2];</span><br><span class="line">       <span class="comment">// Map&lt;Integer, Integer&gt; items2 = new HashMap&lt;&gt;();</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n2; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x2</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">y2</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            items2[i]=<span class="keyword">new</span> <span class="title class_">Item</span>(y2,x2);</span><br><span class="line">            resSum[y2+<span class="number">1000</span>]+=x2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] resMul=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4010</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n1;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n2;j++)&#123;</span><br><span class="line">                resMul[items1[i].getY()+items2[j].getY()+<span class="number">1000</span>]+=items1[i].getX()*items2[j].getX();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">4009</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(resMul[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag!=<span class="number">0</span>)</span><br><span class="line">                    System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(resMul[i]+<span class="string">&quot; &quot;</span>+(i-<span class="number">1000</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">0</span>)System.out.print(<span class="string">&quot;0 0&quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2004</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(resSum[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag!=<span class="number">0</span>)</span><br><span class="line">                    System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(resSum[i]+<span class="string">&quot; &quot;</span>+(i-<span class="number">1000</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">0</span>)System.out.print(<span class="string">&quot;0 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一元多项式的乘法与加法运算&quot;&gt;&lt;a href=&quot;#一元多项式的乘法与加法运算&quot; class=&quot;headerlink&quot; title=&quot;一元多项式的乘法与加法运算&quot;&gt;&lt;/a&gt;一元多项式的乘法与加法运算&lt;/h2&gt;&lt;p&gt; 来自PTA平台的一道算法题：&lt;/p&gt;
&lt;p&gt;设计函</summary>
      
    
    
    
    
    <category term="Java" scheme="https://boneink.github.io/tags/Java/"/>
    
    <category term="算法练习" scheme="https://boneink.github.io/tags/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"/>
    
    <category term="PTA" scheme="https://boneink.github.io/tags/PTA/"/>
    
  </entry>
  
  <entry>
    <title>从“马宝国”看泛娱乐化</title>
    <link href="https://boneink.github.io/2020/12/01/%E6%97%A5%E8%AE%B0-%E4%BB%8E%E2%80%9C%E9%A9%AC%E5%AE%9D%E5%9B%BD%E2%80%9D%E7%9C%8B%E6%B3%9B%E5%A8%B1%E4%B9%90%E5%8C%96/"/>
    <id>https://boneink.github.io/2020/12/01/%E6%97%A5%E8%AE%B0-%E4%BB%8E%E2%80%9C%E9%A9%AC%E5%AE%9D%E5%9B%BD%E2%80%9D%E7%9C%8B%E6%B3%9B%E5%A8%B1%E4%B9%90%E5%8C%96/</id>
    <published>2020-11-30T21:50:00.000Z</published>
    <updated>2020-11-30T21:50:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深夜小记"><a href="#深夜小记" class="headerlink" title="深夜小记"></a>深夜小记</h2><hr><p>“马宝国”其人其事，在网上流传已成烂梗，原以为只是老骗子一个，除去几句翻来覆去的“名人语录”，便也无他罢了。前几日竟见有媒体专访，乃至导演邀约，评论区亦有“路人”为之开脱，可说是魔幻一般的现实。<br>于是乎便有了“《人民日报》揭批马保国闹剧”一回，看来上头是要警惕泛娱乐化这一趋势。而除去《人民日报》“二流报纸”本质，单就马保国其人，本质上骗子一枚，烂梗一个，并无可取之处。<br>大家玩一玩梗，笑一笑他，这叫适度。<br>可有人因此将玩梗的心情移情到其人本身，说些“他还是个七八十的老爷爷，能这样很不容易了”，“他至少给我带来了欢乐”，“他也就只是个骗子”之类的话，这叫自作多情。<br>他现在七八十，可以想象行骗了多久，又有多少人受骗。为老而不尊，实为老贼。<br>而给我们带来欢乐的，是那些辛苦的视频制作者，而不是他。以此为其脱罪，“窃他人之果”，实为匪盗。<br>如果没有这些恶搞视频，那我们又会如何看待此人，这是一个有趣的事情。我们现在因为一个无意间的恶搞，想要轻易原谅一个老贼，甚至还允许他通过流量骗到更多的钱。那未来一大盗，一土匪，一恶魔，亦可通过一段视频，轻易获得谅解。见微而知著，实为大患。<br>强大的国家不怕几粒“老鼠屎”，怕的是大家都开始喜欢尝“老鼠屎”。<br>文化娱乐，既要松绑，又要警惕。<br> <img src="http://boneink.life/img/diary/natu.png"  align=center /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;深夜小记&quot;&gt;&lt;a href=&quot;#深夜小记&quot; class=&quot;headerlink&quot; title=&quot;深夜小记&quot;&gt;&lt;/a&gt;深夜小记&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;“马宝国”其人其事，在网上流传已成烂梗，原以为只是老骗子一个，除去几句翻来覆去的“名人语录”，便也无他罢了。前几日</summary>
      
    
    
    
    
    <category term="日记" scheme="https://boneink.github.io/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>毕业设计《三国演义》在线统计与分析系统</title>
    <link href="https://boneink.github.io/2020/05/23/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E3%80%8A%E4%B8%89%E5%9B%BD%E6%BC%94%E4%B9%89%E3%80%8B%E5%9C%A8%E7%BA%BF%E7%BB%9F%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F/"/>
    <id>https://boneink.github.io/2020/05/23/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E3%80%8A%E4%B8%89%E5%9B%BD%E6%BC%94%E4%B9%89%E3%80%8B%E5%9C%A8%E7%BA%BF%E7%BB%9F%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-05-23T04:00:00.000Z</published>
    <updated>2020-05-23T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="毕业设计《三国演义》在线设计与分析系统"><a href="#毕业设计《三国演义》在线设计与分析系统" class="headerlink" title="毕业设计《三国演义》在线设计与分析系统"></a>毕业设计《三国演义》在线设计与分析系统</h2><blockquote><p>项目基于 Spring MVC框架，前端使用了Bootstrap和jQuery进行页面设计，使用Mybatis进行sql连接，分词处理使用了开源的Jieba分词库，数据的图表展示使用了EChart进行处理，另外通讯用的是tomcat。<br>项目地址：<a href="https://github.com/BoneInk/RTK-Analysis-System">https://github.com/BoneInk/RTK-Analysis-System</a></p></blockquote><p>记录在这个项目的编写过程中，自己遇到的一些难点和坑点：</p><h3 id="Jieba分词库的选择和使用"><a href="#Jieba分词库的选择和使用" class="headerlink" title="Jieba分词库的选择和使用"></a>Jieba分词库的选择和使用</h3><p>作为一个JavaWeb的项目，直接使用Java版的Jieba库莫过于最舒服的事情，但是自己最初蠢了，试图将Jieba库的源码直接复制进自己的项目中，成功调试出一堆bug。<br>正确的操作：将源代码在IDEA中打开后，导出为jar包，在自己的JavaWeb项目中导入lib中即可调用。</p><h3 id="注册登录弹窗和注册时的用户名可用性实时提醒"><a href="#注册登录弹窗和注册时的用户名可用性实时提醒" class="headerlink" title="注册登录弹窗和注册时的用户名可用性实时提醒"></a>注册登录弹窗和注册时的用户名可用性实时提醒</h3><p>之前大三刚上手时就已经学到了如何实现弹窗，但是作为一个难点，还是要稍微圈起来记一下。<br>在自己的登录页添加如下代码，作为基础框架：</p><pre><code><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal fade&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myModal&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal-dialog&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal-content&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal-header&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal-body&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal-footer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre><p>再添加如下代码作为调用弹窗的按钮：<br>    <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;fp-btn&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">href</span>=<span class="string">&quot;/html/login.html&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;tooltip&quot;</span> <span class="attr">data-placement</span>=<span class="string">&quot;buttom&quot;</span> <span class="attr">data-toggle</span>=<span class="string">&quot;modal&quot;</span> <span class="attr">data-target</span>=<span class="string">&quot;#myModal&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;login btn-fp&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">href</span>=<span class="string">&quot;/html/regis.html&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;tooltip&quot;</span> <span class="attr">data-placement</span>=<span class="string">&quot;buttom&quot;</span> <span class="attr">data-toggle</span>=<span class="string">&quot;modal&quot;</span> <span class="attr">data-target</span>=<span class="string">&quot;#myModal&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;register btn-fp&quot;</span> <span class="attr">value</span>=<span class="string">&quot;注册&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><br>弹出的注册窗口代码：</p>   <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal-title&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;text-center&quot;</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal-body&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span> <span class="attr">id</span>=<span class="string">&quot;regis&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入用户名(必填)&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;ajax&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>密码<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入密码(必填)&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>邮箱<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入邮箱(必填)&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;text-left&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary btn-lg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color: #418a72;color: white&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点击我获取验证码&quot;</span> <span class="attr">id</span>=<span class="string">&quot;valiDate&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;change()&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>验证码<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;validate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入验证码&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;text-right&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-default&quot;</span>  <span class="attr">style</span>=<span class="string">&quot;background-color: #498a5d;color: white&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;注册&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;checkForm1()&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn bg-danger&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color: #8a1843;color: white&quot;</span> <span class="attr">data-dismiss</span>=<span class="string">&quot;modal&quot;</span>&gt;</span>取消<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此处需要使用jQuery Ajax验证用户名的可用性：</p><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">$(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    $(<span class="string">&quot;#name&quot;</span>).<span class="title function_">blur</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="comment">//按下“name”按键触发</span></span><br><span class="line">        $.<span class="title function_">post</span>(<span class="string">&quot;/user/isValidName&quot;</span>, &#123;<span class="comment">//通过POST方法调用指定地址的Controller方法 or jsp页面 or servlet</span></span><br><span class="line">                <span class="attr">name</span>: $(<span class="variable language_">this</span>).<span class="title function_">val</span>(),<span class="comment">//发送的参数</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">function</span> (<span class="params">data</span>) &#123;<span class="comment">//返回后调用该方法</span></span><br><span class="line">                <span class="keyword">if</span> (data.<span class="property">res</span> == <span class="string">&quot;no&quot;</span>) &#123;</span><br><span class="line">                    $(<span class="string">&quot;#ajax&quot;</span>).<span class="title function_">html</span>(<span class="string">&quot;用户名已存在！&quot;</span>);</span><br><span class="line">                    $(<span class="variable language_">this</span>).<span class="title function_">select</span>();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    $(<span class="string">&quot;#ajax&quot;</span>).<span class="title function_">html</span>(<span class="string">&quot;用户名可用&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;json&quot;</span>);<span class="comment">//指定返回的数据类型</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></code></pre><p>后端对应的Controller:<br>    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/isValidName&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@ResponseBody</span></span><br><span class="line">    JSON <span class="title function_">isValidName</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name)</span> &#123;</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">json</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();<span class="comment">//生成json对象</span></span><br><span class="line">        <span class="keyword">if</span> ((User) userService.findUserByName(name) != <span class="literal">null</span>) &#123;<span class="comment">//调用方法和数据库进行数据交换</span></span><br><span class="line">            json.put(<span class="string">&quot;res&quot;</span>, <span class="string">&quot;no&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> json.put(<span class="string">&quot;res&quot;</span>, <span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> json;<span class="comment">//返回json数据</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>登录页面：</p><pre><code><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal-title&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;text-center&quot;</span>&gt;</span>登陆<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal-body&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span> <span class="attr">id</span>=<span class="string">&quot;login&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入用户名&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>密码<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入密码&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;text-left&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary btn-lg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color: #418a72;color: white&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点击我获取验证码&quot;</span> <span class="attr">id</span>=<span class="string">&quot;valiDate&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;change()&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>验证码<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;validate&quot;</span>  <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入验证码&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;text-right&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color: #498a5d;color: white&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登陆&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;checkForm()&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn bg-danger&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color: #8a1843;color: white&quot;</span> <span class="attr">data-dismiss</span>=<span class="string">&quot;modal&quot;</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span>取消<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre><p>对应的js控制代码：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> xmlHttp;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkForm1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> form=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;regis&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span>(form.<span class="property">name</span>.<span class="property">value</span> .<span class="title function_">trim</span>()== <span class="string">&quot;&quot;</span>) &#123;<span class="comment">//判断用户名是否为空</span></span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;用户名不能为空!&quot;</span>);</span><br><span class="line">        form.<span class="property">account</span>.<span class="title function_">focus</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(form.<span class="property">password</span>.<span class="property">value</span> .<span class="title function_">trim</span>()== <span class="string">&quot;&quot;</span>) &#123;<span class="comment">//判断密码是否为空</span></span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;密码不能为空!&quot;</span>);</span><br><span class="line">        form.<span class="property">pwd</span>.<span class="title function_">focus</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>($(<span class="string">&quot;#ajax&quot;</span>).<span class="title function_">text</span>()==<span class="string">&quot;用户名已存在！&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;该用户名不可用&quot;</span>);</span><br><span class="line">        form.<span class="property">pwd</span>.<span class="title function_">focus</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(form.<span class="property">validate</span>.<span class="property">value</span>!=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;valiDate&quot;</span>).<span class="property">value</span>)&#123;<span class="comment">//验证码是否正确</span></span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;验证码错误！请重新输入&quot;</span>)</span><br><span class="line">        form.<span class="property">validate</span>.<span class="title function_">focus</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    form.<span class="property">action</span>=<span class="string">&quot;/user/addUser&quot;</span>;</span><br><span class="line">    form.<span class="property">method</span>=<span class="string">&quot;post&quot;</span>;</span><br><span class="line">    form.<span class="title function_">submit</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getCode</span>(<span class="params">n</span>) &#123;<span class="comment">//生成验证码的数字</span></span><br><span class="line">    <span class="keyword">var</span> all=<span class="string">&quot;azxcvbnmsdfghjklqwertyuiopZXCVBNMASDFGHJKLQWERTYUIOP0123456789&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> b=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">var</span> index=<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">62</span>);<span class="comment">//从这62个字母或数字中取一个</span></span><br><span class="line">        b+=all.<span class="title function_">charAt</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">change</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;valiDate&quot;</span>).<span class="property">value</span>=<span class="title function_">getCode</span>(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkForm</span>(<span class="params"></span>) &#123;<span class="comment">//检查登陆界面的表单是否符合标准</span></span><br><span class="line">    <span class="keyword">var</span> form=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;login&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span>(form.<span class="property">name</span>.<span class="property">value</span> .<span class="title function_">trim</span>()== <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;用户名不能为空!&quot;</span>);</span><br><span class="line">        form.<span class="property">id</span>.<span class="title function_">focus</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(form.<span class="property">password</span>.<span class="property">value</span>.<span class="title function_">trim</span>() == <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;密码不能为空!&quot;</span>);</span><br><span class="line">        form.<span class="property">pwd</span>.<span class="title function_">focus</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(form.<span class="property">validate</span>.<span class="property">value</span>!=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;valiDate&quot;</span>).<span class="property">value</span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;验证码错误！请重新输入&quot;</span>)</span><br><span class="line">        form.<span class="property">validate</span>.<span class="title function_">focus</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    form.<span class="property">action</span>=<span class="string">&quot;/user/findUser&quot;</span>;</span><br><span class="line">    form.<span class="property">method</span>=<span class="string">&quot;post&quot;</span>;</span><br><span class="line">    form.<span class="title function_">submit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="文件上传和读取"><a href="#文件上传和读取" class="headerlink" title="文件上传和读取"></a>文件上传和读取</h3><p>文件上传需要使用<code>commons-io-2.6.jar</code>和<code>commons-fileupload-1.4.jar</code>两个包，然后在文件提交时，标注文件上传类型为’file’。<br>    <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/UploadServlet&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">                            或上传自定义文档：</span><br><span class="line">                        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;txt&quot;</span> <span class="attr">style</span>=<span class="string">&quot;float:left;width: 150px&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;确认&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn-sgst&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-top: auto&quot;</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;btn-sgst&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-top: auto&quot;</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;重置&quot;</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>之后在接收的servlet中，进行文件的临时存放和读取：</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">    <span class="type">DiskFileItemFactory</span> <span class="variable">sf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DiskFileItemFactory</span>();<span class="comment">//实例化磁盘被文件列表工厂</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> request.getServletContext().getRealPath(<span class="string">&quot;/upload&quot;</span>);<span class="comment">//得到上传文件的存放目录</span></span><br><span class="line">    sf.setRepository(<span class="keyword">new</span> <span class="title class_">File</span>(path));<span class="comment">//设置文件存放目录</span></span><br><span class="line">    sf.setSizeThreshold(<span class="number">1024</span> * <span class="number">1024</span>);<span class="comment">//设置文件上传小于1M放在内存中</span></span><br><span class="line">    <span class="type">ServletFileUpload</span> <span class="variable">sfu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletFileUpload</span>(sf);</span><br><span class="line">    <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String) session.getAttribute(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;FileItem&gt; lst = sfu.parseRequest(request);<span class="comment">//得到request中所有的元素</span></span><br><span class="line">        <span class="keyword">for</span> (FileItem fileItem : lst) &#123;</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fileItem.getInputStream(), <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                arrayList.add(line);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            session.setAttribute(<span class="string">&quot;content&quot;</span>, arrayList);</span><br><span class="line">            fileItem.delete();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="关键词对照统计及后续的排序："><a href="#关键词对照统计及后续的排序：" class="headerlink" title="关键词对照统计及后续的排序："></a>关键词对照统计及后续的排序：</h3><p>因为中文的习惯、各种官职、别称的存在以及Jieba分词库对中文分词仍不能做到100%准确分词的情况，所以会有分割后的同义词的存在，故应先根据同义词表生成关键词的Map表，由于Map的key值唯一，故关键词的Map表按照{“别称”,”原名”}的形式存放映射关系。<br>对照统计相对简单，Jieba分词的API可以把文段内容自动切割成{“word”,”startIndex”,”endIndex”}的形式，并且封装在SegToken对象中，直接获取其中的word数据即可，之后对照关键词Map进行统计，统计结果也相应的存放在Map表中，格式为{“原名”，”词频”}。<br>由于Map并不存在顺序一说，故只能先将其转换为List后，调用方法进行排序：<br>    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Map.Entry&lt;String, Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Map.Entry&lt;String, Integer&gt;&gt;(map.entrySet()); <span class="comment">//转换为list</span></span><br><span class="line">      Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Map.Entry&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2)</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> o2.getValue().compareTo(o1.getValue());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure><br>值得一提的是，此时的List内的单位元素，是一个个的Map的实体（疑似套娃）。</p><h3 id="合并章节时实现两级选项联动"><a href="#合并章节时实现两级选项联动" class="headerlink" title="合并章节时实现两级选项联动"></a>合并章节时实现两级选项联动</h3><p>目的是为了实现前一个选项选择完毕后，后一个选项给从前一个选项的数值到最大章节数的选项。此处考虑到并不需要过多数据交互，仅是一个简单的判断就行，所以仅使用DOM即可实现。<br>    html的布局代码如下：<br>    <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">           合并分析：</span><br><span class="line">       <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">       起始-&gt;<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;start&quot;</span> <span class="attr">name</span>=<span class="string">&quot;start&quot;</span> <span class="attr">onchange</span>=<span class="string">&quot;cChange()&quot;</span>&gt;</span>&lt;%</span><br><span class="line">       for (int p = 2; p &lt; resList.size(); p++) &#123;</span><br><span class="line">   %&gt;</span><br><span class="line">       <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&lt;%=p%&gt;&quot;</span>&gt;</span>&lt;%=p%&gt;</span><br><span class="line">       <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">       &lt;%</span><br><span class="line">           &#125;</span><br><span class="line">       %&gt;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">       -&gt;<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;to&quot;</span> <span class="attr">name</span>=<span class="string">&quot;to&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span>-&gt;结尾</span><br><span class="line">       <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;确认&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><br>此处涉及的逻辑有，前一个选项选择完毕后，后一个选择先清空所有选项，再重新增加符合要求的选项。因为相对于一般的组件内容改动，此处的’select’标签可调用的方法不同较多，因此花了很多时间在上面，以前使用的子节点和父母节点的方法貌似在这里无法生效。因此，查了很多地方才发现，其实方法很简单：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;selectid&quot;</span>).<span class="property">options</span>.<span class="property">length</span> = <span class="number">0</span>;<span class="comment">//方法一</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">formName</span>.<span class="property">selectName</span>.<span class="property">options</span>.<span class="property">length</span> = <span class="number">0</span>;<span class="comment">//方法二</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;selectid&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;&quot;</span>;<span class="comment">//方法三</span></span><br></pre></td></tr></table></figure><br>我这里选择了这三种之外的一种方法：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cChange</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> t = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> tt = t.<span class="property">options</span>[t.<span class="property">selectedIndex</span>].<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">var</span> opp = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;to&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span> (opp.<span class="property">options</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        opp.<span class="title function_">removeChild</span>(opp.<span class="property">options</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> max = &lt;%=resList.<span class="title function_">size</span>()%&gt;;</span><br><span class="line">    <span class="keyword">var</span> i = tt;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= max; i++) &#123;</span><br><span class="line">        opp.<span class="title function_">add</span>(<span class="keyword">new</span> <span class="title class_">Option</span>(i, i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h3 id="数据的图形化展示"><a href="#数据的图形化展示" class="headerlink" title="数据的图形化展示"></a>数据的图形化展示</h3><p>此处@王小雨同学，不愧是做了一年前端的，直接指向EChart，官方示例很容易懂，连各个组件都能定制化下载，节约了不少空间（不过即便如此，调用起来也因为其js的代码量过大而出现卡顿的情况。ps：绝对不是因为我电脑性能不够23333333。）<br>简单的直接上手即可处理完毕，此处随便贴一个柱形图的调用代码：<br>先添加一个空白的div:<br>    <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100%;height:1500px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>//此处的div大小决定了生成图表的最大值，调整这个的大小远比调整grid的大小来的实用</span><br></pre></td></tr></table></figure><br>调用的js：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">    &lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> myChart = echarts.<span class="title function_">init</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;main&#x27;</span>));<span class="comment">//此处选择要使用的div</span></span><br><span class="line">    <span class="keyword">var</span> option = &#123;</span><br><span class="line">        <span class="attr">title</span>: &#123;</span><br><span class="line">            <span class="attr">text</span>: <span class="string">&#x27;全文分析结果&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">grid</span>: &#123;<span class="comment">//改标签可进行图表的大小调整，但真正来讲，还得看依附的div的大小</span></span><br><span class="line">            <span class="attr">left</span>: <span class="string">&#x27;3%&#x27;</span>,</span><br><span class="line">            <span class="attr">right</span>: <span class="string">&#x27;4%&#x27;</span>,</span><br><span class="line">            <span class="attr">bottom</span>: <span class="string">&#x27;3%&#x27;</span>,</span><br><span class="line">            <span class="attr">containLabel</span>: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">tooltip</span>: &#123;</span><br><span class="line">            <span class="attr">trigger</span>: <span class="string">&#x27;axis&#x27;</span>,</span><br><span class="line">            <span class="attr">axisPointer</span>: &#123;</span><br><span class="line">                <span class="attr">type</span>: <span class="string">&#x27;shadow&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">xAxis</span>: &#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;value&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">yAxis</span>: &#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;category&#x27;</span>,</span><br><span class="line">            <span class="attr">inverse</span>:<span class="literal">true</span>,<span class="comment">//这句可将数据排序反转，主要为了解决竖向显示时小的数据在前边的问题</span></span><br><span class="line">            <span class="attr">axisLabel</span>: &#123;</span><br><span class="line">                <span class="attr">interval</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">data</span>: [&lt;%<span class="comment">//在哪个轴显示自变量，就在哪个轴里调用数据名</span></span><br><span class="line">        int m=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(key.<span class="title function_">equals</span>(<span class="string">&quot;noKey&quot;</span>)) m=<span class="number">100</span>;</span><br><span class="line">        <span class="keyword">else</span> m=list.<span class="title function_">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;m&amp;&amp;i&lt;list.<span class="title function_">size</span>();i++)&#123;</span><br><span class="line">            <span class="title class_">Map</span>.<span class="property">Entry</span>&lt;<span class="title class_">String</span> ,<span class="title class_">Integer</span>&gt; mapping=list.<span class="title function_">get</span>(i);</span><br><span class="line">        %&gt;<span class="string">&quot;&lt;%=mapping.getKey()%&gt;&quot;</span>,</span><br><span class="line">                &lt;%</span><br><span class="line">                &#125;</span><br><span class="line">                %&gt;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">series</span>: [&#123;<span class="comment">//此处导入数据</span></span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;词频&#x27;</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">            <span class="attr">data</span>: [&lt;%</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;m&amp;&amp;i&lt;list.<span class="title function_">size</span>();i++)&#123;</span><br><span class="line">            <span class="title class_">Map</span>.<span class="property">Entry</span>&lt;<span class="title class_">String</span> ,<span class="title class_">Integer</span>&gt; mapping=list.<span class="title function_">get</span>(i);</span><br><span class="line">        %&gt;<span class="string">&quot;&lt;%=mapping.getValue()%&gt;&quot;</span>,</span><br><span class="line">                &lt;%</span><br><span class="line">                &#125;</span><br><span class="line">                %&gt;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">itemStyle</span>: &#123;</span><br><span class="line">                <span class="attr">normal</span>: &#123;</span><br><span class="line">                    <span class="attr">color</span>: <span class="keyword">function</span> (<span class="params">params</span>) &#123;</span><br><span class="line">                        <span class="keyword">var</span> colorList = [<span class="string">&#x27;#c23531&#x27;</span>, <span class="string">&#x27;#2f4554&#x27;</span>, <span class="string">&#x27;#61a0a8&#x27;</span>, <span class="string">&#x27;#d48265&#x27;</span>, <span class="string">&#x27;#91c7ae&#x27;</span>, <span class="string">&#x27;#749f83&#x27;</span>, <span class="string">&#x27;#ca8622&#x27;</span>, <span class="string">&#x27;#bda29a&#x27;</span>, <span class="string">&#x27;#6e7074&#x27;</span>, <span class="string">&#x27;#546570&#x27;</span>, <span class="string">&#x27;#c4ccd3&#x27;</span>];</span><br><span class="line">                        <span class="keyword">var</span> index;</span><br><span class="line">                        <span class="comment">//给大于颜色数量的柱体添加循环颜色的判断</span></span><br><span class="line">                        <span class="keyword">if</span> (params.<span class="property">dataIndex</span> &gt;= colorList.<span class="property">length</span>) &#123;</span><br><span class="line">                            index = params.<span class="property">dataIndex</span> % colorList.<span class="property">length</span>;</span><br><span class="line">                            <span class="keyword">return</span> colorList[index];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> colorList[params.<span class="property">dataIndex</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">label</span>: &#123;</span><br><span class="line">                <span class="attr">show</span>: <span class="literal">true</span>, <span class="comment">//开启显示</span></span><br><span class="line">                <span class="attr">position</span>: <span class="string">&#x27;right&#x27;</span>, <span class="comment">//在上方显示</span></span><br><span class="line">                <span class="attr">textStyle</span>: &#123; <span class="comment">//数值样式</span></span><br><span class="line">                    <span class="attr">color</span>: <span class="string">&#x27;black&#x27;</span>,</span><br><span class="line">                    <span class="attr">fontSize</span>: <span class="number">13</span>,</span><br><span class="line">                    <span class="attr">fontWeight</span>: <span class="number">200</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;;</span><br><span class="line">    myChart.<span class="title function_">setOption</span>(option);</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">onresize</span> = myChart.<span class="property">resize</span>;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><br>因为自己的图表需要根据后台传来的数据生成，因此嵌入了不少Java代码，但整体上还是能看到各个必要的组件的调用格式的，必要部分已经做了注释。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以下为无关废话：<br>作为自己真正意义上的第一次完全独立完成一个较大且较为完备的项目，至少目前达到了1：能用，2：能看，3：代码不那么乱的程度，从整体的开发流程来看，前期因为了解的少，以至于花了很多时间在看各种文档和论文上，最后真正实施起来，其实花的时间很少，也就两周不到2333333，中间还熬了不少夜。值得一提的是，像登陆注册系统和合并章节分词统计结果这种功能，我开始并没有想做，因为不能说你让我做我就做，我说，那我必须要先试一下……</p><blockquote><p>（真实内心os）你看，我都用了Spring MVC框架了，不得来个数据库看看嘛，我都用数据库了，不得来个Mybatis省一下力气嘛，而且看起来还更整洁好看。</p></blockquote><p>然后就跟老师讲觉得自己做的好像还不够的样子（我也不知道哪来的精力这么讲）。</p><blockquote><p>老师：你做个每章节最高词频的统计表出来，然后再做个合并章节统计的功能出来是不是更好点？<br>我：嗯？嗯。（自己说的胡话，怎么也要吞下去）</p></blockquote><p>总的来说，自己还是熬了两夜做出来了老师要做的这个（顺便把自己还没填完的自定义上传文本的坑搞定了），成就感满满。<br>话说我还是很喜欢《三国演义》的，这种古人写的战争爽文，百看不厌好嘛。虽然自己项目做完第一时间做的是丢进去一篇《金瓶梅》测试了下自定义上传文本的效果。（主要是脑海中无限回想郭德纲那句：老爷子爱看书啊，书房里满满的三架子，各种版本的《金瓶梅》。）听说我们学校还有个教授是专门研究《金瓶梅》里的风土人情的？果然ghs才是第一生产力。<br>   &#96;&#96;&#96;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;毕业设计《三国演义》在线设计与分析系统&quot;&gt;&lt;a href=&quot;#毕业设计《三国演义》在线设计与分析系统&quot; class=&quot;headerlink&quot; title=&quot;毕业设计《三国演义》在线设计与分析系统&quot;&gt;&lt;/a&gt;毕业设计《三国演义》在线设计与分析系统&lt;/h2&gt;&lt;bloc</summary>
      
    
    
    
    
    <category term="JavaWeb" scheme="https://boneink.github.io/tags/JavaWeb/"/>
    
    <category term="jQuery" scheme="https://boneink.github.io/tags/jQuery/"/>
    
    <category term="Spring MVC" scheme="https://boneink.github.io/tags/Spring-MVC/"/>
    
    <category term="Mybatis" scheme="https://boneink.github.io/tags/Mybatis/"/>
    
    <category term="Jieba" scheme="https://boneink.github.io/tags/Jieba/"/>
    
    <category term="EChart" scheme="https://boneink.github.io/tags/EChart/"/>
    
    <category term="Sql" scheme="https://boneink.github.io/tags/Sql/"/>
    
    <category term="Bootstrap" scheme="https://boneink.github.io/tags/Bootstrap/"/>
    
    <category term="tomcat" scheme="https://boneink.github.io/tags/tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Jquery ajax 笔记</title>
    <link href="https://boneink.github.io/2020/05/11/Jquery%20Ajax%20%E7%AC%94%E8%AE%B0/"/>
    <id>https://boneink.github.io/2020/05/11/Jquery%20Ajax%20%E7%AC%94%E8%AE%B0/</id>
    <published>2020-05-11T04:00:00.000Z</published>
    <updated>2020-05-11T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="jQuery-Ajax-笔记"><a href="#jQuery-Ajax-笔记" class="headerlink" title="jQuery Ajax 笔记"></a>jQuery Ajax 笔记</h2><p>实现ajax，目前有两种方法：</p><ol><li>使用JavaScript扩展对象XMLHttpRequest实现Ajax</li><li>使用JjQuery实现ajax</li></ol><p>此处学习总结jQuery ajax方法。<br>常用格式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">    <span class="attr">type</span>:<span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&#x27;sentence.jsp&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">sentence</span>:sentence</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">dataType</span>:<span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">    <span class="attr">async</span>:<span class="literal">false</span>,</span><br><span class="line">    <span class="attr">success</span>:<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">error</span>:<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&#x27;false&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>关键词语法：</p><table><thead><tr><th align="left">名称</th><th align="left">值&#x2F;描述</th></tr></thead><tbody><tr><td align="left">async</td><td align="left">布尔值，表示请求是否异步处理。默认是 true。</td></tr><tr><td align="left">beforeSend(<em>xhr</em>)</td><td align="left">发送请求前运行的函数。</td></tr><tr><td align="left">cache</td><td align="left">布尔值，表示浏览器是否缓存被请求页面。默认是 true。</td></tr><tr><td align="left">complete(<em>xhr,status</em>)</td><td align="left">请求完成时运行的函数（在请求成功或失败之后均调用，即在 success 和 error 函数之后）。</td></tr><tr><td align="left">contentType</td><td align="left">发送数据到服务器时所使用的内容类型。默认是：”application&#x2F;x-www-form-urlencoded”。</td></tr><tr><td align="left">context</td><td align="left">为所有 AJAX 相关的回调函数规定 “this” 值。</td></tr><tr><td align="left">data</td><td align="left">规定要发送到服务器的数据。</td></tr><tr><td align="left">dataFilter(<em>data</em>,<em>type</em>)</td><td align="left">用于处理 XMLHttpRequest 原始响应数据的函数。</td></tr><tr><td align="left">dataType</td><td align="left">预期的服务器响应的数据类型。</td></tr><tr><td align="left">error(<em>xhr,status,error</em>)</td><td align="left">如果请求失败要运行的函数。</td></tr><tr><td align="left">global</td><td align="left">布尔值，规定是否为请求触发全局 AJAX 事件处理程序。默认是 true。</td></tr><tr><td align="left">ifModified</td><td align="left">布尔值，规定是否仅在最后一次请求以来响应发生改变时才请求成功。默认是 false。</td></tr><tr><td align="left">jsonp</td><td align="left">在一个 jsonp 中重写回调函数的字符串。</td></tr><tr><td align="left">jsonpCallback</td><td align="left">在一个 jsonp 中规定回调函数的名称。</td></tr><tr><td align="left">password</td><td align="left">规定在 HTTP 访问认证请求中使用的密码。</td></tr><tr><td align="left">processData</td><td align="left">布尔值，规定通过请求发送的数据是否转换为查询字符串。默认是 true。</td></tr><tr><td align="left">scriptCharset</td><td align="left">规定请求的字符集。</td></tr><tr><td align="left">success(<em>result,status,xhr</em>)</td><td align="left">当请求成功时运行的函数。</td></tr><tr><td align="left">timeout</td><td align="left">设置本地的请求超时时间（以毫秒计）。</td></tr><tr><td align="left">traditional</td><td align="left">布尔值，规定是否使用参数序列化的传统样式。</td></tr><tr><td align="left">type</td><td align="left">规定请求的类型（GET 或 POST）。</td></tr><tr><td align="left">url</td><td align="left">规定发送请求的 URL。默认是当前页面。</td></tr><tr><td align="left">username</td><td align="left">规定在 HTTP 访问认证请求中使用的用户名。</td></tr><tr><td align="left">xhr</td><td align="left">用于创建 XMLHttpRequest 对象的函数。</td></tr></tbody></table><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><ol><li>若url为jsp文件，通过java返回数据，则应用语句<code>request.setAttribute();</code>。</li><li>在js中可用<code>$&#123;&#125;</code>或嵌入java<code>&lt;%=%&gt;</code>取出指定名称的返回数据。 </li><li>若指定了返回数据的类型，则返回数据的类型需要与指定类型相同，否则会报错。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;jQuery-Ajax-笔记&quot;&gt;&lt;a href=&quot;#jQuery-Ajax-笔记&quot; class=&quot;headerlink&quot; title=&quot;jQuery Ajax 笔记&quot;&gt;&lt;/a&gt;jQuery Ajax 笔记&lt;/h2&gt;&lt;p&gt;实现ajax，目前有两种方法：&lt;/p&gt;
&lt;o</summary>
      
    
    
    
    
    <category term="JavaWeb" scheme="https://boneink.github.io/tags/JavaWeb/"/>
    
    <category term="jQuery" scheme="https://boneink.github.io/tags/jQuery/"/>
    
    <category term="Ajax" scheme="https://boneink.github.io/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb上传文件</title>
    <link href="https://boneink.github.io/2020/05/11/JavaWeb%E7%AC%94%E8%AE%B0/"/>
    <id>https://boneink.github.io/2020/05/11/JavaWeb%E7%AC%94%E8%AE%B0/</id>
    <published>2020-05-11T04:00:00.000Z</published>
    <updated>2020-05-11T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaWeb上传文件"><a href="#JavaWeb上传文件" class="headerlink" title="JavaWeb上传文件"></a>JavaWeb上传文件</h2><p>前端：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>导入文本分词：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;UploadServlet&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span><span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    &lt;%--名称：<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;txt_name&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span>--%&gt;</span><br><span class="line">    上传文件：<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;txt&quot;</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>/&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;重置&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>设置Servlet：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.fileupload.FileItem;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.fileupload.disk.DiskFileItemFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.fileupload.servlet.ServletFileUpload;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.fileupload.FileUploadException;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.doPost(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        DiskFileItemFactory sf= <span class="keyword">new</span> <span class="title class_">DiskFileItemFactory</span>();<span class="comment">//实例化磁盘被文件列表工厂</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> request.getRealPath(<span class="string">&quot;/upload&quot;</span>);<span class="comment">//得到上传文件的存放目录</span></span><br><span class="line">        sf.setRepository(<span class="keyword">new</span> <span class="title class_">File</span>(path));<span class="comment">//设置文件存放目录</span></span><br><span class="line">        sf.setSizeThreshold(<span class="number">1024</span>*<span class="number">1024</span>);<span class="comment">//设置文件上传小于1M放在内存中</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rename</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;<span class="comment">//文件新生成的文件名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;<span class="comment">//文件原名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;<span class="comment">//普通field字段</span></span><br><span class="line">        <span class="comment">//从工厂得到servletupload文件上传类</span></span><br><span class="line">        <span class="type">ServletFileUpload</span> <span class="variable">sfu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletFileUpload</span>(sf);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;FileItem&gt; lst = sfu.parseRequest(request);<span class="comment">//得到request中所有的元素</span></span><br><span class="line">            <span class="keyword">for</span> (FileItem fileItem : lst) &#123;</span><br><span class="line">                <span class="keyword">if</span>(fileItem.isFormField())&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="string">&quot;name&quot;</span>.equals(fileItem.getFieldName()))&#123;</span><br><span class="line">                        name = fileItem.getString(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//获得文件名称</span></span><br><span class="line">                    fileName = fileItem.getName();</span><br><span class="line">                    fileName = fileName.substring(fileName.lastIndexOf(<span class="string">&quot;\\&quot;</span>)+<span class="number">1</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">houzhui</span> <span class="operator">=</span> fileName.substring(fileName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">                    rename = UUID.randomUUID()+houzhui;</span><br><span class="line">                    fileItem.write(<span class="keyword">new</span> <span class="title class_">File</span>(path, rename));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        response.sendRedirect(<span class="string">&quot;file.jsp&quot;</span>);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：注意导入<code>commons-io-2.6.jar</code>和<code>commons-fileupload-1.4.jar</code>，以区分tomcat中同名的api。</p><p>在<code>web.xml</code>中添加servlet:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>UploadServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>UploadServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>UploadServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/UploadServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时会出现中文文件名名乱码，在<code>doPost()</code>方法中添加如下即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JavaWeb上传文件&quot;&gt;&lt;a href=&quot;#JavaWeb上传文件&quot; class=&quot;headerlink&quot; title=&quot;JavaWeb上传文件&quot;&gt;&lt;/a&gt;JavaWeb上传文件&lt;/h2&gt;&lt;p&gt;前端：&lt;/p&gt;
&lt;figure class=&quot;highlight h</summary>
      
    
    
    
    
    <category term="JavaWeb" scheme="https://boneink.github.io/tags/JavaWeb/"/>
    
  </entry>
  
</feed>
